{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"hca",
				"hcan1"
			],
			[
				"w",
				"while"
			],
			[
				"g",
				"g_plevel1_menu"
			],
			[
				"int",
				"int8_t"
			],
			[
				"me",
				"menu_bar"
			],
			[
				"u",
				"uint8_t"
			],
			[
				"p",
				"pbar"
			],
			[
				"to",
				"touch_key_cnt"
			],
			[
				"TOUCH_ke",
				"TOUCH_KEY_VALUE_CONFIRM_HOLD"
			],
			[
				"touch",
				"touch_key_cnt"
			],
			[
				"uin",
				"uint16_t"
			],
			[
				"touc",
				"touch_key_val"
			],
			[
				"le",
				"level"
			],
			[
				"def",
				"define"
			],
			[
				"data",
				"data_left_Length"
			],
			[
				"dat",
				"data_offset"
			],
			[
				"l",
				"length_temp"
			],
			[
				"ui",
				"uint8_t"
			],
			[
				"pot",
				"pdot"
			],
			[
				"LE",
				"LEVEL1_MENU"
			],
			[
				"L",
				"LEVEL1_MENU"
			],
			[
				"TOU",
				"TOUCH_KEY_VALUE_CONFIRM"
			],
			[
				"level2",
				"level2_offset"
			],
			[
				"level2_",
				"level2_menu_index"
			],
			[
				"Gt",
				"GT32L32_FLASH_BASE"
			],
			[
				"Men",
				"Menu_MAX_FOOD_NUM"
			],
			[
				"menu_update_wo",
				"MENU_UPDATE_WORK_STATUS_RUNNING"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "#include \"includes.h\" \n\n\n#include \"utils.h\"\n#include \"rfal_nfc.h\"\n#include \"st25r3916.h\"\n\n//int main(void)\n//{\n//\tsysterm_init();\n// \n//\t\n//\twhile(1)\n//\t{\n//\t  HAL_GPIO_TogglePin(MAIN_LED_GPIO_Port, MAIN_LED_Pin);\n//\t\tapp_dispatch(); \n//\t}\n//}\n\n\n///15693 读写卡测试\n\n//#define EXAMPLE_RFAL_POLLER_DEVICES      10 \n//static uint8_t gDevCnt;  \n// rfalNfcvListenDevice nfcvDevList[EXAMPLE_RFAL_POLLER_DEVICES];      \n\n//\trfalNfcvInventoryRes invRes;\n//\tReturnCode           err;\n//\tuint8_t    i;    \n//\tuint8_t    devCnt;\n//\t\n//\t\n//\tuint8_t block_buff[16];  /* Flags + Block Data + CRC */\n//\tuint16_t read_block_len = 0;\n//\t\n//\t\n//\tuint8_t txData[64] = {0};\n//int main(void)\n//{\n//\t\n\n//\t\n//\tsysterm_init();\n//  \n//\trfalAnalogConfigInitialize();\n//\t if(rfalInitialize() != ERR_NONE)                                                  /* Initialize RFAL */\n//    {\n//\t\t\t HAL_GPIO_TogglePin(MAIN_LED_GPIO_Port, MAIN_LED_Pin);\n//\t\t}\n//\t\t\n\n////\trfalChipMeasureAmplitude(txData);\n////\trfalChipMeasurePhase(txData + 1);\n\n//\t\t\n//\twhile(1)\n//\t{\n//\t  HAL_GPIO_TogglePin(MAIN_LED_GPIO_Port, MAIN_LED_Pin);\n//\t \n////\t\trfalWorker();    \n////\t\t\n////\t\t   /*******************************************************************************/\n////    /* NFC-V Technology Detection                                                  */\n////    /*******************************************************************************/\n////    \n////    rfalNfcvPollerInitialize();                                                       /* Initialize RFAL for NFC-V */\n////    rfalFieldOnAndStartGT();                                                          /* As field is already On only starts GT timer */\n////    \n////    err = rfalNfcvPollerCheckPresence( &invRes );                                     /* Poll for NFC-V devices */\n////    if( err == ERR_NONE )\n////    {\n////      //  gTechsFound |= EXAMPLE_RFAL_POLLER_FOUND_V;\n////    }\n//\t\t\n////\t\tst25r3916TxRxOn();\n////\t\tplatformDelay(10);//可减少延时？？\t\n//\t\t\n//\t\t          \n//\t\trfalNfcvPollerInitialize();        \n//\t\trfalFieldOnAndStartGT();                                                      /* Ensure GT again as other technologies have also been polled */       \n//\t\terr = rfalNfcvPollerCollisionResolution(RFAL_COMPLIANCE_MODE_ISO , (EXAMPLE_RFAL_POLLER_DEVICES - gDevCnt), nfcvDevList, &devCnt );        \n//\t//err = rfalNfcvPollerSleepCollisionResolution((EXAMPLE_RFAL_POLLER_DEVICES - gDevCnt), invResList, &devCnt );   \n\n//\t\tif( (err == ERR_NONE) && (devCnt != 0) )        \n//\t\t{           \n//\t\t\tprintf(\"read tag num %d\\n\", devCnt);\n//\t\t\tfor(int i=0; i<devCnt; i++)\n//\t\t\t{\n//\t\t\t\tprintf(\"uid:\");\n//\t\t\t\tprint_hex(nfcvDevList[i].InvRes.UID, 8);\n//\t\t\t\tprintf(\"\\n\");\n//\t\t\t\t\n//\t\t\t\t\n//\t\t\terr =\t rfalNfcvPollerSelect( RFAL_NFCV_REQ_FLAG_DEFAULT , nfcvDevList[i].InvRes.UID );\n//\t\t\t\tif(ERR_NONE == ERR_NONE)\n//\t\t\t\t{\n//\t\t\t\t\t\tfor(int j=0; j<sizeof(block_buff); j++)\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tblock_buff[j] = j+0x11;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\t\n//\t\t\t\t\t\trfalNfcvPollerWriteSingleBlock(RFAL_NFCV_REQ_FLAG_DEFAULT, nfcvDevList[i].InvRes.UID, 3, block_buff, 4);\n//\t\t\t\t\t\n//\t\t\t\t\t//读取块\n//\t\t\t\t\t\terr = rfalNfcvPollerReadSingleBlock(RFAL_NFCV_REQ_FLAG_DEFAULT, nfcvDevList[i].InvRes.UID, 3, block_buff, 8, &read_block_len);\n//\t\t\t\t\t\tif(ERR_NONE == ERR_NONE)\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tprintf(\"block:\");\n//\t\t\t\t\t\t\tprint_hex(block_buff+1, read_block_len);\n//\t\t\t\t\t\t\tprintf(\"\\n\");\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\t\tprintf(\"rfalNfcvPollerReadSingleBlock() ==> error\\n\");\n//\t\t\t\t\t\t} \n//\t\t\t\t}\n//\t\t\t\telse\n//\t\t\t\t{\n//\t\t\t\t\t\tprintf(\"rfalNfcvPollerSelect() ==> error\\n\");\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n////\t\t\tst25r3916TxRxOff();\n//\t\t// printf(\" NFC-V device UID: %s \\r\\n\", hex2str(gDevList[i].dev.nfcv.InvRes.UID, RFAL_NFCV_UID_LEN));\n//\t}\n//}\n\n\n\n/*!\n *****************************************************************************\n * \\brief Demo Blocking Transceive \n *\n * Helper function to send data in a blocking manner via the rfalNfc module \n *  \n * \\warning A protocol transceive handles long timeouts (several seconds), \n * transmission errors and retransmissions which may lead to a long period of \n * time where the MCU/CPU is blocked in this method.\n * This is a demo implementation, for a non-blocking usage example please \n * refer to the Examples available with RFAL\n *\n * \\param[in]  txBuf      : data to be transmitted\n * \\param[in]  txBufSize  : size of the data to be transmited\n * \\param[out] rxData     : location where the received data has been placed\n * \\param[out] rcvLen     : number of data bytes received\n * \\param[in]  fwt        : FWT to be used (only for RF frame interface, \n *                                          otherwise use RFAL_FWT_NONE)\n *\n * \n *  \\return ERR_PARAM     : Invalid parameters\n *  \\return ERR_TIMEOUT   : Timeout error\n *  \\return ERR_FRAMING   : Framing error detected\n *  \\return ERR_PROTO     : Protocol error detected\n *  \\return ERR_NONE      : No error, activation successful\n * \n *****************************************************************************\n */\nReturnCode demoTransceiveBlocking( uint8_t *txBuf, uint16_t txBufSize, uint8_t **rxData, uint16_t **rcvLen, uint32_t fwt )\n{\n    ReturnCode err;\n    \n    err = rfalNfcDataExchangeStart( txBuf, txBufSize, rxData, rcvLen, fwt );\n    if( err == ERR_NONE )\n    {\n        do{\n            rfalNfcWorker();\n            err = rfalNfcDataExchangeGetStatus();\n        }\n        while( err == ERR_BUSY );\n    }\n    return err;\n}\n\n\n #define DEMO_ENABLE_POLL_MODE                     true\n#define DEMO_ENABLE_LISTEN_MODE                   false\n#define DEMO_ENABLE_P2P_MODE                      false\n#define DEMO_ENABLE_POLL_WRITE_TAG                false\n\n/* APDUs communication data */    \nstatic uint8_t ndefSelectApp[] = { 0x00, 0xA4, 0x04, 0x00, 0x07, 0xD2, 0x76, 0x00, 0x00, 0x85, 0x01, 0x01, 0x00 };\nstatic uint8_t ccSelectFile[] = { 0x00, 0xA4, 0x00, 0x0C, 0x02, 0xE1, 0x03};\nstatic uint8_t readBynary[] = { 0x00, 0xB0, 0x00, 0x00, 0x0F };\n/*static uint8_t ppseSelectApp[] = { 0x00, 0xA4, 0x04, 0x00, 0x0E, 0x32, 0x50, 0x41, 0x59, 0x2E, 0x53, 0x59, 0x53, 0x2E, 0x44, 0x44, 0x46, 0x30, 0x31, 0x00 };*/\n\n\n/*!\n *****************************************************************************\n * \\brief Demo APDUs Exchange\n *\n * Example how to exchange a set of predefined APDUs with PICC. The NDEF\n * application will be selected and then CC will be selected and read.\n * \n *****************************************************************************\n */\n//void demoAPDU( void )\n//{\n//    ReturnCode err;\n//    uint16_t   *rxLen;\n//    uint8_t    *rxData;\n\n\n//    /* Exchange APDU: NDEF Tag Application Select command */\n//    err = demoTransceiveBlocking( ndefSelectApp, sizeof(ndefSelectApp), &rxData, &rxLen, RFAL_FWT_NONE );\n//    printf(\" Select NDEF Application: %s Data: %s\\r\\n\", (err != ERR_NONE) ? \"FAIL\": \"OK\", hex2Str( rxData, *rxLen) );\n\n//    if( (err == ERR_NONE) && rxData[0] == 0x90 && rxData[1] == 0x00)\n//    {\n//        /* Exchange APDU: Select Capability Container File */\n//        err = demoTransceiveBlocking( ccSelectFile, sizeof(ccSelectFile), &rxData, &rxLen, RFAL_FWT_NONE );\n//        printf(\" Select CC: %s Data: %s\\r\\n\", (err != ERR_NONE) ? \"FAIL\": \"OK\", hex2Str( rxData, *rxLen) );\n\n//        /* Exchange APDU: Read Capability Container File  */\n//        err = demoTransceiveBlocking( readBynary, sizeof(readBynary), &rxData, &rxLen, RFAL_FWT_NONE );\n//        printf(\" Read CC: %s Data: %s\\r\\n\", (err != ERR_NONE) ? \"FAIL\": \"OK\", hex2Str( rxData, *rxLen) );\n//    }\n//}\n\n\n#define EXAMPLE_NFCA_DEVICES 10\n/*\n******************************************************************************* \n * GLOBAL FUNCTIONS\n******************************************************************************\n */\n\nvoid exampleNFCARun(void)\n{\n    ReturnCode err;\n    rfalNfcaSensRes sensRes;\n    rfalNfcaSelRes selRes;\n    rfalNfcaListenDevice nfcaDevList[EXAMPLE_NFCA_DEVICES];\n    uint8_t devCnt;\n    uint8_t devIt;\n    rfalInitialize();\n    for (;;)\n    {\n        rfalFieldOff(); /* Turn the Field Off */\n        platformDelay(500);\n        rfalNfcaPollerInitialize(); /* Initialize RFAL for NFC-A */\n        rfalFieldOnAndStartGT();    /* Turns the Field On and starts GT timer */\n        /*******************************************************************************/\n        /* Perform NFC-A Technology detection                                          */\n        err = rfalNfcaPollerTechnologyDetection(RFAL_COMPLIANCE_MODE_NFC, &sensRes);                                           /* Poll for nearby NFC-A devices */\n        if (err == ERR_NONE)                                                                                                   /* NFC-A type card found */\n        { /*******************************************************************************/                                    /* Perform NFC-A Collision Resolution */\n            err = rfalNfcaPollerFullCollisionResolution(RFAL_COMPLIANCE_MODE_NFC, EXAMPLE_NFCA_DEVICES, nfcaDevList, &devCnt); /* Perform collision avoidance */\n            if ((err == ERR_NONE) && (devCnt > 0))\n            {\n                printf(\"NFC-A device(s) found %d\\r\\n\", devCnt);\n                devIt = 0; /* Use the first device on the list */\n                /*******************************************************************************/\n                /* Check if desired device is in Sleep                                         */\n//                if (nfcaDevList[devIt].isSleep)\n                {\n                    err = rfalNfcaPollerCheckPresence(RFAL_14443A_SHORTFRAME_CMD_WUPA, &sensRes); /* Wake up all cards  */\n                    if (err != ERR_NONE)\n                    {\n                        continue;\n                    }\n                    err = rfalNfcaPollerSelect(nfcaDevList[devIt].nfcId1, nfcaDevList[devIt].nfcId1Len, &selRes); /* Select specific device  */\n                    if (err != ERR_NONE)\n                    {\n                        continue;\n                    }\n                }\n                /*******************************************************************************/\n                /* Perform protocol specific activation                                        */\n                switch (nfcaDevList[devIt].type)\n                {\n                case RFAL_NFCA_T1T:                             /* No further activation needed for a T1T (RID already performed)*/\n                    printf(\"NFC-A T1T device found \\r\\n\"); /* NFC-A T1T device found, NFCID/UID is contained in: t1tRidRes.uid */\n                    /* Following communications shall be performed using:                         \n                    *   - Non blocking: rfalStartTransceive() + rfalGetTransceiveState()                         \n                    *   -     Blocking: rfalTransceiveBlockingTx() + rfalTransceiveBlockingRx() or rfalTransceiveBlockingTxRx()    */\n                    break;\n                case RFAL_NFCA_T2T:                             /* No specific activation needed for a T2T */\n                    printf(\"NFC-A T2T device found \\r\\n\"); /* NFC-A T2T device found, NFCID/UID is contained in: nfcaDev.nfcid */\n                    /* Following communications shall be performed using:                         \n                    *   - Non blocking: rfalStartTransceive() + rfalGetTransceiveState()                         \n                    *   -     Blocking: rfalTransceiveBlockingTx() + rfalTransceiveBlockingRx() or rfalTransceiveBlockingTxRx()    */\n                    break;\n                case RFAL_NFCA_T4T:\n                    printf(\"NFC-A T4T (ISO-DEP) device found \\r\\n\"); /* NFC-A T4T device found, NFCID/UID is contained in: nfcaDev.nfcid */\n                    /* Activation should continue using rfalIsoDepPollAHandleActivation(), see exampleRfalPoller.c */\n                    break;\n                case RFAL_NFCA_T4T_NFCDEP:                                /* Device supports T4T and NFC-DEP */\n                case RFAL_NFCA_NFCDEP:                                    /* Device supports NFC-DEP */\n                    printf(\"NFC-A P2P (NFC-DEP) device found \\r\\n\"); /* NFC-A P2P device found, NFCID/UID is contained in: nfcaDev.nfcid */\n                    /* Activation should continue using rfalNfcDepInitiatorHandleActivation(), see exampleRfalPoller.c */\n                    break;\n                }\n//                rfalNfcaPollerSleep(); /* Put device to sleep / HLTA (useless as the field will be turned off anyhow) */\n            }\n        }\n    }\n}\n\n\n\n#define EXAMPLE_RFAL_POLLER_DEVICES      5U  \n rfalNfcaListenDevice nfcvDevList[EXAMPLE_RFAL_POLLER_DEVICES];      \n \nrfalNfcvListenDevice iso_nfcvDevList[EXAMPLE_RFAL_POLLER_DEVICES]; \n\n\tReturnCode           err; \n\tuint8_t    devCnt;\n\t\n\tstatic uint8_t gDevCnt; \n\n\n\tuint8_t block_buff[16];  /* Flags + Block Data + CRC */\n\tuint16_t read_block_len = 0;\n\t rfalNfcaSelRes select_res;\nint main(void)\n{ \n\tsysterm_init();\n  \n\trfalAnalogConfigInitialize();\n\t if(rfalInitialize() != ERR_NONE)                                                  /* Initialize RFAL */\n    {\n\t\t\t HAL_GPIO_TogglePin(MAIN_LED_GPIO_Port, MAIN_LED_Pin);\n\t\t} \n\n\t\tex_device_test();\n\twhile(1)\n\t{\n        \n        //app_dispatch();\n        main_oled_test();\n\tHAL_GPIO_TogglePin(MAIN_LED_GPIO_Port, MAIN_LED_Pin);\n\t\t\n\t\t//读取15693\n\t   st25r3916TxRxOn();    \n\t\tHAL_Delay(10);\n\trfalNfcvPollerInitialize();        \n\trfalFieldOnAndStartGT();   \n\terr = rfalNfcvPollerCollisionResolution(RFAL_COMPLIANCE_MODE_NFC , (EXAMPLE_RFAL_POLLER_DEVICES - gDevCnt), iso_nfcvDevList, &devCnt );  \n\tif( (err == ERR_NONE) && (devCnt != 0) )        \n\t\t{      \n\t\tprintf(\"tag type: iso15693\\r\\n\");\t\t\t\n\t\t\tprintf(\"tag num %d\\n\", devCnt);\n\t\t\tfor(int i=0; i<devCnt; i++)\n\t\t\t{\n\t\t\t\tprintf(\"uid:\");\n\t\t\t\tprint_hex(iso_nfcvDevList[i].InvRes.UID, 8);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\t\t \n\t\tst25r3916TxRxOff();\n\t\t\n\t\t\n\t\tHAL_Delay(50);\n\t\t\n\t\t\n\t\t\n\t\t//读取1443A\n\t\t st25r3916TxRxOn();                                                                   /* Turn the Field Off */\n\t\t\n\t\tHAL_Delay(10);\n\t\t//14443A标签读取\n\t\trfalNfcaPollerInitialize();        \n\t\trfalFieldOnAndStartGT();   \n\t\t\n\t\t \n//\trfalWorker();\n//\t\t rfalNfcWorker();\n                                                   /* Ensure GT again as other technologies have also been polled */       \n\t\terr = rfalNfcaPollerFullCollisionResolution( RFAL_COMPLIANCE_MODE_NFC,  EXAMPLE_RFAL_POLLER_DEVICES - devCnt, nfcvDevList, &devCnt );\n\t\t\n\t\t\tst25r3916TxRxOff();\n\t\t//14443B标签\n//\t\trfalNfcaPollerInitialize();        \n//\t\trfalFieldOnAndStartGT();                                                      /* Ensure GT again as other technologies have also been polled */       \n//\t\terr = rfalNfcaPollerFullCollisionResolution( RFAL_COMPLIANCE_MODE_NFC,  EXAMPLE_RFAL_POLLER_DEVICES - gDevCnt, nfcvDevList, &devCnt );\n\t\t\n\t\n\t\t\n\t\tif( (err == ERR_NONE) && (devCnt != 0) )        \n\t\t{           \n\t\t\tprintf(\"\\r\\ntag type: 14443a\\r\\n\");\t\n\t\t\tprintf(\"tag num %d\\n\", devCnt);\n\t\t\tfor(int i=0; i<devCnt; i++)\n\t\t\t{ \n\t\t\t\tprintf(\"uid length = %d\\n\", nfcvDevList[i].nfcId1Len);\n\t\t\t\tprintf(\"uid:\");\n\t\t\t\tprint_hex(nfcvDevList[i].nfcId1, 10);\n\t\t\t\tprintf(\"\\n\");\n//\t\t\t\t \n//\t\t\terr =\t rfalNfcaPollerSelect(nfcvDevList[i].nfcId1, nfcvDevList[i].nfcId1Len,  &select_res);\n//\t\t\t\tif(ERR_NONE == ERR_NONE)\n//\t\t\t\t{\n//\t\t\t\t\t\tfor(int j=0; j<sizeof(block_buff); j++)\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tblock_buff[j] = j+0x11;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\t\n//\t\t\t\t\t\t err = rfalT2TPollerSectorSelect(0x02);\n// \n//\t\t\t\t if( err != ERR_NONE )\n//\t\t\t\t {\n//\t\t\t\t\t printf(\"  error: %d  Exit...\\r\\n\", err);\n//\t\t\t\t\t// return false;\n//\t\t\t\t }\n//\t\t\t\t \n//\t\t\t\t\t\terr = rfalT2TPollerWrite(0x02, block_buff);\n//\t\t\t\t\t\tif(err != ERR_NONE)\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tprintf(\"write error\\n\");\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\t\n//\t\t\t\t\t\terr = rfalT2TPollerRead(0x02, block_buff, 8, &read_block_len);\n////\t\t\t\t\t\trfalNfcvPollerWriteSingleBlock(RFAL_NFCV_REQ_FLAG_DEFAULT, nfcvDevList[i].InvRes.UID, 3, block_buff, 4);\n////\t\t\t\t\t\n////\t\t\t\t\t//读取块\n////\t\t\t\t\t\terr = rfalNfcvPollerReadSingleBlock(RFAL_NFCV_REQ_FLAG_DEFAULT, nfcvDevList[i].InvRes.UID, 3, block_buff, 8, &read_block_len);\n//\t\t\t\t\t\tif(err == ERR_NONE)\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tprintf(\"block:\");\n//\t\t\t\t\t\t\tprint_hex(block_buff+1, read_block_len);\n//\t\t\t\t\t\t\tprintf(\"\\n\");\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\t\tprintf(\"rfalNfcvPollerReadSingleBlock() ==> error\\n\");\n//\t\t\t\t\t\t} \n//\t\t\t\t}\n//\t\t\t\telse\n//\t\t\t\t{\n//\t\t\t\t\t\tprintf(\"rfalNfcvPollerSelect() ==> error\\n\");\n//\t\t\t\t}\n\t\t\t}\n\t\t}\n\t \n\t\t\n//\t\t\tst25r3916TxRxOff();\n\t\t// printf(\" NFC-V device UID: %s \\r\\n\", hex2str(gDevList[i].dev.nfcv.InvRes.UID, RFAL_NFCV_UID_LEN));\n\t}\n}\n\n\n\n\n//int main(void)\n//{ \n//\tsysterm_init();\n//  \n// exampleNFCARun();\n//\twhile(1)\n//\t{\n//\t  HAL_GPIO_TogglePin(MAIN_LED_GPIO_Port, MAIN_LED_Pin);\n//\t\t \n//\t}\n//}\n\n\n",
			"file": "Src/main.c",
			"file_size": 16688,
			"file_write_time": 132481770592025202,
			"settings":
			{
				"buffer_size": 16660,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"file": "device_lib/st25r3916/ST25R3916/st25r3916.c",
			"settings":
			{
				"buffer_size": 26642,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "\n#ifndef _GT32L32M0180_H_\n#define _GT32L32M0180_H_\n \nextern unsigned char r_dat_bat(unsigned long address,unsigned long byte_long,unsigned char *p_arr);\n\n#define ASCII_5X7              1      //ASCII编码5X7点阵\n#define ASCII_7X8              2      //ASCII编码7X8点阵\n#define ASCII_7X8_F            3      //ASCII编码7X8点阵Fat风格字符（具体字形看规格书）\n#define ASCII_6X12             4      //ASCII编码6X12点阵\n#define ASCII_8X16             5      //ASCII编码8X16点阵\n#define ASCII_8X16_F           6      //ASCII编码8X16点阵Fat风格字符（具体字形看规格书）\n#define ASCII_12X24            7      //ASCII编码12X24点阵\n//#define ASCII_12X24_P          8      //ASCII编码12X24点阵打印体\n#define ASCII_16X32            9      //ASCII编码16X32点阵\n#define ASCII_16X32_F         10      //ASCII编码16X32点阵Fat风格字符（具体字形看规格书）\n#define ASCII_12_A            11      //ASCII编码12x12点阵不等宽Arial风格字符（具体字形看规格书）\t\t\n#define ASCII_12_T            12\t\t  //ASCII编码12X12点阵不等宽Time news Roman风格字符（具体字形看规格书）\n#define ASCII_16_A            13      //ASCII编码16X16点阵不等宽Arial风格字符（具体字形看规格书）\t\t\n#define ASCII_16_T            14\t\t  //ASCII编码16X16点阵不等宽Time news Roman风格字符（具体字形看规格书）\n#define ASCII_24_A            15      //ASCII编码24X24点阵不等宽Arial风格字符（具体字形看规格书）\t\t\n#define ASCII_24_T            16\t\t  //ASCII编码24X24点阵不等宽Time news Roman风格字符（具体字形看规格书）\n#define ASCII_32_A            17      //ASCII编码32X32点阵不等宽Arial风格字符（具体字形看规格书）\t\t\n#define ASCII_32_T            18\t\t  //ASCII编码32X32点阵不等宽Time news Roman风格字符（具体字形看规格书）\n\n#define NUB_14X28\t\t\t\t\t\t\t 0\n#define NUB_20X40\t\t\t\t\t\t\t 1\n#define NUB_28X28\t\t\t\t\t\t\t 2\n#define NUB_40X40\t\t\t\t\t\t\t 3\n\n\n/*************************************************************\n函数用法：\n    unsigned char DZ_Data[数组长度客户自定义];\n    ASCII_GetData(0x41,ASCII_5X7,DZ_Data);      //读取5X7点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为8 BYTE\n\t  ASCII_GetData(0x41,ASCII_7X8,DZ_Data);      //读取7X8点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为8 BYTE\n\t\tASCII_GetData(0x41,ASCII_7X8_F,DZ_Data);\t\t//读取7X8点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为8 BYTE\n\t  ASCII_GetData(0x41,ASCII_6X12,DZ_Data);     //读取6X12点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为12 BYTE\n\t  ASCII_GetData(0x41,ASCII_8X16,DZ_Data);   \t//读取8X16点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为16 BYTE\n\t  ASCII_GetData(0x41,ASCII_8X16_F,DZ_Data);   //读取8X16点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为16 BYTE\n\t  ASCII_GetData(0x41,ASCII_12X24,DZ_Data);\t\t//读取12X24点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为48 BYTE\n\t\tASCII_GetData(0x41,ASCII_16X32,DZ_Data);\t\t//读取16X32点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为64 BYTE\n\t\tASCII_GetData(0x41,ASCII_16X32_F,DZ_Data);\t//读取16X32点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为64 BYTE\n\t\tASCII_GetData(0x41,ASCII_12_A,DZ_Data);     //读取12X12点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为26 BYTE\n\t\tASCII_GetData(0x41,ASCII_12_T,DZ_Data);     //读取12X12点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为26 BYTE\n\t  ASCII_GetData(0x41,ASCII_16_A,DZ_Data);     //读取16X16点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为34 BYTE\n\t\tASCII_GetData(0x41,ASCII_16_T,DZ_Data);     //读取16X16点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为34 BYTE\n\t\tASCII_GetData(0x41,ASCII_24_A,DZ_Data);     //读取24X24点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为74 BYTE\n\t\tASCII_GetData(0x41,ASCII_24_T,DZ_Data);     //读取24X24点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为74 BYTE\n\t\tASCII_GetData(0x41,ASCII_32_A,DZ_Data);     //读取32X32点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为128 BYTE\n\t\tASCII_GetData(0x41,ASCII_32_T,DZ_Data);     //读取32X32点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为128 BYTE\n\t\t\t\t\n*************************************************************/ \nunsigned char  ASCII_GetData(unsigned char  ASCIICode,unsigned long  ascii_kind,unsigned char *DZ_Data);\n\n/*************************************************************\n函数用法：\n    unsigned char DZ_Data[数组长度客户自定义];\n    Dig_Ch_GetData(1,NUB_14X28,DZ_Data);\t//读取14X28点阵数字符号字符点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为56 BYTE\n\t  Dig_Ch_GetData(1,NUB_20X40,DZ_Data);\t//读取20X40点阵数字符号字符点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为120 BYTE\n\t\tDig_Ch_GetData(1,NUB_28X28,DZ_Data);\t//读取28X28点阵数字符号字符点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为112 BYTE\n\t  Dig_Ch_GetData(1,NUB_40X40,DZ_Data);\t//读取40X40点阵数字符号字符点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为200 BYTE\n*************************************************************/ \nunsigned char\t Dig_Ch_GetData(unsigned char  Sequence,unsigned long  NUB_kind,unsigned char *DZ_Data);\n \n/*************************************************************\n函数用法：\n    unsigned char DZ_Data[数组长度客户自定义];\n    gt_12_GetData(0xb0,0xa1,0x00,0x00,DZ_Data); //读取12X12点阵 汉字\"啊\"的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为24 BYTE\n*************************************************************/\nunsigned long  gt_12_GetData(unsigned char c1,unsigned char c2,unsigned char c3,unsigned char c4,unsigned char *DZ_Data);\n\n/*************************************************************\n函数用法：\n    unsigned char DZ_Data[数组长度客户自定义];\n    gt_16_GetData(0xb0,0xa1,0x00,0x00,DZ_Data); //读取16X16点阵 汉字\"啊\"的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为24 BYTE\n*************************************************************/ \nunsigned long  gt_16_GetData(unsigned char  c1, unsigned char  c2, unsigned char  c3, unsigned char  c4,unsigned char *DZ_Data);\n\n/*************************************************************\n函数用法：\n    unsigned char DZ_Data[数组长度客户自定义];\n    gt_24_GetData(0xb0,0xa1,0x00,0x00,DZ_Data); //读取24X24点阵 汉字\"啊\"的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为72 BYTE\n*************************************************************/ \nunsigned long  gt_24_GetData(unsigned char  c1, unsigned char  c2, unsigned char  c3, unsigned char  c4,unsigned char *DZ_Data);\n\n/*************************************************************\n函数用法：\n    unsigned char DZ_Data[数组长度客户自定义];\n    gt_32_GetData(0xb0,0xa1,0x00,0x00,DZ_Data); //读取32X32点阵 汉字\"啊\"的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为128 BYTE\n*************************************************************/ \nunsigned long  gt_32_GetData(unsigned char  c1,unsigned char  c2,unsigned char  c3,unsigned char  c4,unsigned char *DZ_Data);\n\n/*************************************************************\n函数用法：\n    unsigned long BAR_NUM[13]={0,1,2,3,4,5,6,7,8,9,1,2,3};\n    unsigned long BAR_ADDR[13];\n\t\tBAR_CODE13(BAR_NUM,BAR_ADDR); //获取条形码的地址，并将地址存于数组BAR_ADDR中\n*************************************************************/\nunsigned long  BAR_CODE13(unsigned char  * BAR_NUM,unsigned char *BAR_PIC_ADDR);\n/*************************************************************\n函数用法：\n    unsigned long BAR_NUM[13]={0,1,2,3,4,5,6,7,8,9,1,2,3};\n    unsigned long BAR_ADDR[7];\n\t\tBAR_CODE128(BAR_NUM,1,BAR_ADDR); //获取条形码的地址，并将地址存于数组BAR_ADDR中\n起始符有3种模式\n当flag=1时为Code-128-A;\n当flag=2时为Code-128-B;\n当flag=3时为Code-128-C;\t\t\n*************************************************************/\nunsigned long  BAR_CODE128(unsigned char  *BAR_NUM,unsigned char  flag,unsigned char *BAR_PIC_ADDR);\n\n/*************************************************************\n函数用法：\n    unsigned char DZ_Data[数组长度客户自定义];\n    Antenna_CODE_12X12_GetData(0,DZ_Data); //读取12X12点阵天线字符的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为24 BYTE\n*************************************************************/ \nunsigned long  Antenna_CODE_12X12_GetData(unsigned char  NUM,unsigned char *DZ_Data);\n\n/*************************************************************\n函数用法：\n    unsigned char DZ_Data[数组长度客户自定义];\n    Battery_CODE_12X12_GetData(0,DZ_Data); //读取12X12点阵电池字符的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为24 BYTE\n*************************************************************/ \nunsigned long  Battery_CODE_12X12_GetData(unsigned char   NUM,unsigned char *DZ_Data);\n\n/*************************************************************\n函数用法：\n    unsigned char GBCode;\n    GBCode = U2G(0x554A); //将unicode编码数据转换GBK编码\n*************************************************************/ \nunsigned long\tU2G(unsigned int  unicode);\n\n/*************************************************************\n函数用法：\n    unsigned char GBCode;\n    GBCode = U2G_13(0x554A); //将unicode编码数据转换GBK编码（字符区）\n*************************************************************/ \nunsigned int  U2G_13(unsigned int  Unicode);\n\n/*************************************************************\n函数用法：\n    unsigned char GBCode;\n    GBCode = BIG5_G(0xB0DA); //将Big5编码数据转换GBK编码 \n*************************************************************/ \nunsigned long  BIG5_G(unsigned int  B5code);\n \n\n\n#endif\n\n\n\n\n",
			"file": "hardware/inc/GT32L32M0180.h",
			"file_size": 9428,
			"file_write_time": 132478979209828040,
			"settings":
			{
				"buffer_size": 8151,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"contents": "#include \"includes.h\"\n#include \"uart_debug.h\"\n#include \"debug_task.h\"\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n\n#define DEBUG_UART\t\t\t\t\t\t\t\tUSART1 \n#define DEBUG_IRQ_HANDLE(NAME)    NAME##_IRQHandler\n#define DEBUG_REV_COMPLETE_IRQ_HANDLE(NAME)    NAME##_IRQHandler\n\n\nvoid debug_send(uint8_t value)\n{\n\tDEBUG_UART->DR = value;\n\twhile((DEBUG_UART->SR & UART_IT_TXE) == RESET);\n}\n\nuint8_t debug_read(void)\n{\n\tuint8_t value = 0;\n\twhile((DEBUG_UART->SR & UART_IT_RXNE) == RESET);\n\tvalue = DEBUG_UART->DR;\n\treturn value;\n}\n\n/**\n  * 函数功能: 重定向c库函数printf到DEBUG_USARTx\n  * 输入参数: 无\n  * 返 回 值: 无\n  * 说    明：无\n  */\nint fputc(int ch, FILE *f)\n{\n\tdebug_send(ch); \n  return ch;\n}\n\n/**\n  * 函数功能: 重定向c库函数getchar,scanf到DEBUG_USARTx\n  * 输入参数: 无\n  * 返 回 值: 无\n  * 说    明：无\n  */\nint fgetc(FILE * f)\n{\n  uint8_t ch = 0;\n  ch = debug_read();\n  return ch;\n}\n\n\n//接收中断\nvoid DEBUG_IRQ_HANDLE(USART1)(void)\n{\n\tuint8_t value = 0;\n\tif((USART1->SR & UART_IT_RXNE) != 0)\n\t{\n\t\tvalue = USART1->DR;  \n\t\tpush_cmd_cache(value);\t\t//启动调试\n\t}\n\t\n\tif((USART1->SR & UART_IT_IDLE) != 0)\n\t{\n\t\t//清中断标志\n\t\tvalue = USART1->DR;\n\t\tvalue = USART1->SR;\n\t\t//写完成标志 \n\t}\n}\n\n\n\nvoid print_hex(uint8_t *buff, uint16_t len)\n{\n\tfor(int i=0; i<len; i++)\n\t{\n\t\tprintf(\"%02x \", buff[i]);\n\t}\n}\n\n\nvoid logUsartTx(uint8_t *buff, int len)\n{\n\tfor(int i=0; i<len; i++)\n\t{\n\t\tdebug_send(buff[i]);\n\t}\n}\n\nint logUsart(const char* format, ...)\n{\n  #if (USE_LOGGER == LOGGER_ON)\n  {\n    #define LOG_BUFFER_SIZE 256\n    char buf[LOG_BUFFER_SIZE];\n    va_list argptr;\n    va_start(argptr, format);\n    int cnt = vsnprintf(buf, LOG_BUFFER_SIZE, format, argptr);\n    va_end(argptr);  \n      \n    /* */\n    logUsartTx((uint8_t*)buf, strlen(buf));\n    return cnt;\n  }\n  #else\n  {\n    return 0;\n  }\n  #endif /* #if USE_LOGGER == LOGGER_ON */\n}\n\n",
			"file": "event_manage/src/uart_debug.c",
			"file_size": 1838,
			"file_write_time": 132478979152839815,
			"settings":
			{
				"buffer_size": 1772,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"contents": "#include \"bsp_init.h\"\n#include \"main.h\"\n#include \"can_drv.h\" \n\nADC_HandleTypeDef hadc1;\nDMA_HandleTypeDef hdma_adc1;\n\nCAN_HandleTypeDef hcan;\n\nSPI_HandleTypeDef hspi1;\nSPI_HandleTypeDef hspi2;\n\nTIM_HandleTypeDef htim2;\nTIM_HandleTypeDef htim3;\n\nUART_HandleTypeDef huart1;\n\n/**\n  * @brief System Clock Configuration\n  * @retval None\n  */\nvoid SystemClock_Config(void)\n{\n  RCC_OscInitTypeDef RCC_OscInitStruct = {0};\n  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};\n  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};\n\n  /** Initializes the CPU, AHB and APB busses clocks \n  */\n  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;\n  RCC_OscInitStruct.HSEState = RCC_HSE_ON;\n  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;\n  RCC_OscInitStruct.HSIState = RCC_HSI_ON;\n  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;\n  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;\n  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;\n  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /** Initializes the CPU, AHB and APB busses clocks \n  */\n  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK\n                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;\n  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;\n  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;\n\n  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;\n  PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV6;\n  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)\n  {\n    Error_Handler();\n  }\n}\n\n/**\n  * @brief ADC1 Initialization Function\n  * @param None\n  * @retval None\n  */\nstatic void MX_ADC1_Init(void)\n{\n\n  /* USER CODE BEGIN ADC1_Init 0 */\n\n  /* USER CODE END ADC1_Init 0 */\n\n  ADC_ChannelConfTypeDef sConfig = {0};\n\n  /* USER CODE BEGIN ADC1_Init 1 */\n\n  /* USER CODE END ADC1_Init 1 */\n  /** Common config \n  */\n  hadc1.Instance = ADC1;\n  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;\n  hadc1.Init.ContinuousConvMode = ENABLE;\n  hadc1.Init.DiscontinuousConvMode = DISABLE;\n  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;\n  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;\n  hadc1.Init.NbrOfConversion = 2;\n  if (HAL_ADC_Init(&hadc1) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /** Configure Regular Channel \n  */\n  sConfig.Channel = ADC_CHANNEL_9;\n  sConfig.Rank = ADC_REGULAR_RANK_1;\n  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;\n  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /** Configure Regular Channel \n  */\n  sConfig.Channel = ADC_CHANNEL_0;\n  sConfig.Rank = ADC_REGULAR_RANK_2;\n  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /* USER CODE BEGIN ADC1_Init 2 */\n\n  /* USER CODE END ADC1_Init 2 */\n\n}\n  \n/**\n  * @brief CAN Initialization Function\n  * @param None\n  * @retval None\n  */\nstatic void MX_CAN_Init(uint8_t can_addr)\n{\n\tuint32_t filter_value = SIGNAL_SLAVE_FILTERID;\n\tuint32_t filter_mask = SIGNAL_SLAVE_MASK;\n\t\n  /* USER CODE BEGIN CAN_Init 0 */\n\n\tCAN_FilterTypeDef CAN_FilterInitStructure;\n  /* USER CODE END CAN_Init 0 */\n\n  /* USER CODE BEGIN CAN_Init 1 */\n\t//500k\n  /* USER CODE END CAN_Init 1 */\n  hcan.Instance = CAN1;\n  hcan.Init.Prescaler = 12;\n  hcan.Init.Mode = CAN_MODE_NORMAL;\n  hcan.Init.SyncJumpWidth = CAN_SJW_1TQ;\n  hcan.Init.TimeSeg1 = CAN_BS1_3TQ;\n  hcan.Init.TimeSeg2 = CAN_BS2_2TQ;\n  hcan.Init.TimeTriggeredMode = DISABLE;\n  hcan.Init.AutoBusOff = ENABLE;\n  hcan.Init.AutoWakeUp = ENABLE;\n  hcan.Init.AutoRetransmission = DISABLE;\n  hcan.Init.ReceiveFifoLocked = DISABLE;\n  hcan.Init.TransmitFifoPriority = DISABLE;\n  if (HAL_CAN_Init(&hcan) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /* USER CODE BEGIN CAN_Init 2 */\n\t\n\t//判断地址是否为空\n\tif(can_addr != CAN_ADDR_NULL)\t\t//进行地址滤波\n\t{\n\t\t//如果地址不为空，加入地址滤波\n\t\tfilter_value  &= 0xFFFFFF00;\n\t\tfilter_value  |= can_addr;\n\t\tfilter_mask   &= 0xFFFFFF00;\n\t\tfilter_mask   |= 0x000000FF;\n\t}\n\t\n\t/*===========================FIFO0 过滤=============================*/\n\t//单包接收，地址过滤\n\tCAN_FilterInitStructure.FilterBank \t= 0;     /* 过滤器组 */\n\tCAN_FilterInitStructure.FilterMode \t\t= CAN_FILTERMODE_IDMASK;//CAN_FilterMode_IdList;//CAN_FilterMode_IdMask;  /* 屏敝模式 */\n\tCAN_FilterInitStructure.FilterScale \t= CAN_FILTERSCALE_32BIT; ///* 32位 */\n\t \n\tCAN_FilterInitStructure.FilterIdHigh \t\t\t= FILTER_MASK_H(filter_value);  \n\tCAN_FilterInitStructure.FilterIdLow \t\t\t= FILTER_MASK_L(filter_value)|CAN_ID_EXT;\n\tCAN_FilterInitStructure.FilterMaskIdHigh \t= FILTER_MASK_H(filter_mask);\n\tCAN_FilterInitStructure.FilterMaskIdLow \t= FILTER_MASK_L(filter_mask)|CAN_ID_EXT;\n\t  \n\tCAN_FilterInitStructure.FilterFIFOAssignment \t= CAN_FILTER_FIFO0;  ///* 能够通过该过滤器的报文存到fifo0中 */\n\tCAN_FilterInitStructure.FilterActivation = ENABLE;\n\tHAL_CAN_ConfigFilter(&hcan,&CAN_FilterInitStructure);\n\t \n\t\t//判断地址是否为空\n\tif(can_addr != CAN_ADDR_NULL)\t\t//进行地址滤波\n\t{\n\t\tfilter_value = SIGNAL_SLAVE_FILTERID;\n\t\tfilter_mask = SIGNAL_SLAVE_MASK;\n\t\t//如果地址不为空，加入地址滤波\n\t\tfilter_value  &= 0xFFFFFF00;\n\t\tfilter_value  |= 0xFF;\n\t\tfilter_mask   &= 0xFFFFFF00;\n\t\tfilter_mask   |= 0x000000FF;\n\t}\n\t\n\tCAN_FilterInitStructure.FilterBank \t= 1;     /* 过滤器组 ， 添加全局地址0xFF地址*/ \n\tCAN_FilterInitStructure.FilterMode \t\t= CAN_FILTERMODE_IDMASK;//CAN_FilterMode_IdList;//CAN_FilterMode_IdMask;  /* 屏敝模式 */\n\tCAN_FilterInitStructure.FilterScale \t= CAN_FILTERSCALE_32BIT; ///* 32位 */\n\t \n\tCAN_FilterInitStructure.FilterIdHigh \t\t\t= FILTER_MASK_H(filter_value);  \n\tCAN_FilterInitStructure.FilterIdLow \t\t\t= FILTER_MASK_L(filter_value)|CAN_ID_EXT;\n\tCAN_FilterInitStructure.FilterMaskIdHigh \t= FILTER_MASK_H(filter_mask);\n\tCAN_FilterInitStructure.FilterMaskIdLow \t= FILTER_MASK_L(filter_mask)|CAN_ID_EXT;\n\t  \n\tCAN_FilterInitStructure.FilterFIFOAssignment \t= CAN_FILTER_FIFO0;  ///* 能够通过该过滤器的报文存到fifo0中 */\n\tCAN_FilterInitStructure.FilterActivation = ENABLE;\n\tHAL_CAN_ConfigFilter(&hcan,&CAN_FilterInitStructure);\n\t\n\t/*===========================FIFO1 过滤=============================*/\n\t//多包接收\n\t//过滤组\n\t\t\t//判断地址是否为空\n\tif(can_addr != CAN_ADDR_NULL)\t\t//进行地址滤波\n\t{\n\t filter_value = MUTIL_SLAVE_FILTERID;\n\t filter_mask = MUTIL_SLAVE_MASK0;\n\t\t\n\t\t//如果地址不为空，加入地址滤波\n\t\tfilter_value  &= 0xFFFFFF00;\n\t\tfilter_value  |= can_addr;\n\t\tfilter_mask   &= 0xFFFFFF00;\n\t\tfilter_mask   |= 0x000000FF;\n\t}\n\t\n\tCAN_FilterInitStructure.FilterBank \t= 2;     /* 过滤器组 */\n\tCAN_FilterInitStructure.FilterMode \t\t= CAN_FILTERMODE_IDMASK;//CAN_FilterMode_IdList;//CAN_FilterMode_IdMask;  /* 屏敝模式 */\n\tCAN_FilterInitStructure.FilterScale \t= CAN_FILTERSCALE_32BIT; ///* 32位 */\n\t \n\tCAN_FilterInitStructure.FilterIdHigh \t\t\t= FILTER_MASK_H(filter_value);  \n\tCAN_FilterInitStructure.FilterIdLow \t\t\t= FILTER_MASK_L(filter_value)|CAN_ID_EXT;\n\tCAN_FilterInitStructure.FilterMaskIdHigh \t= FILTER_MASK_H(filter_mask);\n\tCAN_FilterInitStructure.FilterMaskIdLow \t= FILTER_MASK_L(filter_mask)|CAN_ID_EXT;\n\t  \n\tCAN_FilterInitStructure.FilterFIFOAssignment \t= CAN_FILTER_FIFO1;  ///* 能够通过该过滤器的报文存到fifo0中 */\n\tCAN_FilterInitStructure.FilterActivation = ENABLE;\n\tHAL_CAN_ConfigFilter(&hcan,&CAN_FilterInitStructure);\n\t\n\t//过滤组\n\t\t\t\t//判断地址是否为空\n\tif(can_addr != CAN_ADDR_NULL)\t\t//进行地址滤波\n\t{\n\t filter_value = MUTIL_SLAVE_FILTERID;\n\t filter_mask = MUTIL_SLAVE_MASK1;\n\t\t\n\t\t//如果地址不为空，加入地址滤波\n\t\tfilter_value  &= 0xFFFFFF00;\n\t\tfilter_value  |= can_addr;\n\t\tfilter_mask   &= 0xFFFFFF00;\n\t\tfilter_mask   |= 0x000000FF;\n\t}\n\t\n\tCAN_FilterInitStructure.FilterBank \t= 3;     /* 过滤器组 */\n\tCAN_FilterInitStructure.FilterMode \t\t= CAN_FILTERMODE_IDMASK;//CAN_FilterMode_IdList;//CAN_FilterMode_IdMask;  /* 屏敝模式 */\n\tCAN_FilterInitStructure.FilterScale \t= CAN_FILTERSCALE_32BIT; ///* 32位 */\n\n\tCAN_FilterInitStructure.FilterIdHigh \t\t\t= FILTER_MASK_H(filter_value);  \n\tCAN_FilterInitStructure.FilterIdLow \t\t\t= FILTER_MASK_L(filter_value)|CAN_ID_EXT;\n\tCAN_FilterInitStructure.FilterMaskIdHigh \t= FILTER_MASK_H(filter_mask);\n\tCAN_FilterInitStructure.FilterMaskIdLow \t= FILTER_MASK_L(filter_mask)|CAN_ID_EXT;\n\n\tCAN_FilterInitStructure.FilterFIFOAssignment \t= CAN_FILTER_FIFO1;  ///* 能够通过该过滤器的报文存到fifo0中 */\n\tCAN_FilterInitStructure.FilterActivation = ENABLE;\n\tHAL_CAN_ConfigFilter(&hcan,&CAN_FilterInitStructure);\n\t \n\t\n//\t//CAN1->IER |= CAN_IT_BOF|CAN_IT_FMP0|CAN_IT_ERR;\n//\t__HAL_CAN_ENABLE_IT(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING);\t//FIFO0消息挂起中断允许.\t \n//\t__HAL_CAN_ENABLE_IT(&hcan, CAN_IT_RX_FIFO1_MSG_PENDING);\t//FIFO0消息挂起中断允许.\t \t\n////  HAL_NVIC_SetPriority(CAN1_RX0_IRQn,1,2);    \t//抢占优先级1，子优先级2\n////  HAL_NVIC_EnableIRQ(CAN1_RX0_IRQn);          \t//使能中断\n\n\n//\tHAL_CAN_Start(&hcan);\n//\tHAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING);\n//\tHAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO1_MSG_PENDING);\n  /* USER CODE END CAN_Init 2 */\n\n}\n\n/**\n  * @brief SPI1 Initialization Function\n  * @param None\n  * @retval None\n  */\nstatic void MX_SPI1_Init(void)\n{\n\n  /* USER CODE BEGIN SPI1_Init 0 */\n\n  /* USER CODE END SPI1_Init 0 */\n\n  /* USER CODE BEGIN SPI1_Init 1 */\n\n  /* USER CODE END SPI1_Init 1 */\n  /* SPI1 parameter configuration*/\n  hspi1.Instance = SPI1;\n  hspi1.Init.Mode = SPI_MODE_MASTER;\n  hspi1.Init.Direction = SPI_DIRECTION_2LINES;\n  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;\n  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;\n  hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;\n  hspi1.Init.NSS = SPI_NSS_SOFT;\n  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;\n  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;\n  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;\n  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;\n  hspi1.Init.CRCPolynomial = 10;\n  if (HAL_SPI_Init(&hspi1) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /* USER CODE BEGIN SPI1_Init 2 */\n//\t__HAL_SPI_ENABLE(&hspi1);\n  /* USER CODE END SPI1_Init 2 */\n\n}\n\n/**\n  * @brief SPI2 Initialization Function\n  * @param None\n  * @retval None\n  */\nstatic void MX_SPI2_Init(void)\n{\n\n  /* USER CODE BEGIN SPI2_Init 0 */\n\n  /* USER CODE END SPI2_Init 0 */\n\n  /* USER CODE BEGIN SPI2_Init 1 */\n\n  /* USER CODE END SPI2_Init 1 */\n  /* SPI2 parameter configuration*/\n  hspi2.Instance = SPI2;\n  hspi2.Init.Mode = SPI_MODE_MASTER;\n  hspi2.Init.Direction = SPI_DIRECTION_2LINES;\n  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;\n  hspi2.Init.CLKPolarity = SPI_POLARITY_HIGH;\n  hspi2.Init.CLKPhase = SPI_PHASE_2EDGE;\n  hspi2.Init.NSS = SPI_NSS_SOFT;\n  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;\n  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;\n  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;\n  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;\n  hspi2.Init.CRCPolynomial = 10;\n  if (HAL_SPI_Init(&hspi2) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /* USER CODE BEGIN SPI2_Init 2 */\n\t__HAL_SPI_ENABLE(&hspi2);\n  /* USER CODE END SPI2_Init 2 */\n\n}\n\n/**\n  * @brief TIM2 Initialization Function\n  * @param None\n  * @retval None\n  */\nstatic void MX_TIM2_Init(void)\n{\n\n  /* USER CODE BEGIN TIM2_Init 0 */\n\n  /* USER CODE END TIM2_Init 0 */\n\n  TIM_MasterConfigTypeDef sMasterConfig = {0};\n  TIM_OC_InitTypeDef sConfigOC = {0};\n\n  /* USER CODE BEGIN TIM2_Init 1 */\n\n  /* USER CODE END TIM2_Init 1 */\n  htim2.Instance = TIM2;\n  htim2.Init.Prescaler = 72-1;\n  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;\n  htim2.Init.Period = 20000;\n  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;\n  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;\n  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;\n  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;\n  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  sConfigOC.OCMode = TIM_OCMODE_PWM1;\n  sConfigOC.Pulse = 0;\n  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;\n  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;\n  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /* USER CODE BEGIN TIM2_Init 2 */\n\n\tHAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3); \n  /* USER CODE END TIM2_Init 2 */\n  HAL_TIM_MspPostInit(&htim2);\n\n}\n\n/**\n  * @brief TIM3 Initialization Function\n  * @param None\n  * @retval None\n  */\nstatic void MX_TIM3_Init(void)\n{\n\n  /* USER CODE BEGIN TIM3_Init 0 */\n\n  /* USER CODE END TIM3_Init 0 */\n\n  TIM_MasterConfigTypeDef sMasterConfig = {0};\n  TIM_OC_InitTypeDef sConfigOC = {0};\n\n  /* USER CODE BEGIN TIM3_Init 1 */\n\n  /* USER CODE END TIM3_Init 1 */\n  htim3.Instance = TIM3;\n  htim3.Init.Prescaler = 71;\n  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;\n  htim3.Init.Period = 1000;\n  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;\n  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;\n  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;\n  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;\n  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  sConfigOC.OCMode = TIM_OCMODE_PWM1;\n  sConfigOC.Pulse = 1000;\n  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;\n  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;\n  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /* USER CODE BEGIN TIM3_Init 2 */\n\n\tHAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1); \n  /* USER CODE END TIM3_Init 2 */\n  HAL_TIM_MspPostInit(&htim3);\n\n}\n\n/**\n  * @brief USART1 Initialization Function\n  * @param None\n  * @retval None\n  */\nstatic void MX_USART1_UART_Init(void)\n{\n\n  /* USER CODE BEGIN USART1_Init 0 */\n\n  /* USER CODE END USART1_Init 0 */\n\n  /* USER CODE BEGIN USART1_Init 1 */\n\n  /* USER CODE END USART1_Init 1 */\n  huart1.Instance = USART1;\n  huart1.Init.BaudRate = 115200;\n  huart1.Init.WordLength = UART_WORDLENGTH_8B;\n  huart1.Init.StopBits = UART_STOPBITS_1;\n  huart1.Init.Parity = UART_PARITY_NONE;\n  huart1.Init.Mode = UART_MODE_TX_RX;\n  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;\n  huart1.Init.OverSampling = UART_OVERSAMPLING_16;\n  if (HAL_UART_Init(&huart1) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /* USER CODE BEGIN USART1_Init 2 */\n\t__HAL_UART_ENABLE(&huart1);\n  /* USER CODE END USART1_Init 2 */\n\n}\n\n/** \n  * Enable DMA controller clock\n  */\nstatic void MX_DMA_Init(void) \n{\n\n  /* DMA controller clock enable */\n  __HAL_RCC_DMA1_CLK_ENABLE();\n\n  /* DMA interrupt init */\n  /* DMA1_Channel1_IRQn interrupt configuration */\n  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);\n  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);\n\n}\n\n/**\n  * @brief GPIO Initialization Function\n  * @param None\n  * @retval None\n  */\nstatic void MX_GPIO_Init(void)\n{\n  GPIO_InitTypeDef GPIO_InitStruct = {0};\n\n  /* GPIO Ports Clock Enable */ \n  __HAL_RCC_GPIOC_CLK_ENABLE();\n  __HAL_RCC_GPIOD_CLK_ENABLE();\n  __HAL_RCC_GPIOA_CLK_ENABLE();\n  __HAL_RCC_GPIOB_CLK_ENABLE();\n\n  /*Configure GPIO pin Output Level */\n  HAL_GPIO_WritePin(MAIN_LED_GPIO_Port, MAIN_LED_Pin, GPIO_PIN_RESET);\n\t\n  /*Configure GPIO pin Output Level */\n  HAL_GPIO_WritePin(GPIOA, PTC_CTRL_Pin|ST25R_CS_Pin|BEEP_Pin, GPIO_PIN_RESET);\n\n  /*Configure GPIO pin Output Level */\n  HAL_GPIO_WritePin(GPIOB, MOTOR_POWER_Pin, GPIO_PIN_RESET);\n\t\n\tHAL_GPIO_WritePin(GPIOB, OLED_DC_Pin|OLED_RES1_Pin|OELD_RES2_Pin|OLED_CS2_Pin \n\t\t\t\t\t\t\t\t\t\t\t\t|CS_FLASH_Pin|OLED_CS1_Pin, GPIO_PIN_SET);\n\n \n\t  /*Configure GPIO pin : MAIN_LED_Pin */\n  GPIO_InitStruct.Pin = MAIN_LED_Pin;\n  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n  HAL_GPIO_Init(MAIN_LED_GPIO_Port, &GPIO_InitStruct);\n\t\n  /*Configure GPIO pins : PTC_CTRL_Pin ST25R_CS_Pin BEEP_Pin */\n  GPIO_InitStruct.Pin = PTC_CTRL_Pin|ST25R_CS_Pin|BEEP_Pin;\n  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n\n  /*Configure GPIO pin : ST25R_IRQ_Pin */\n  GPIO_InitStruct.Pin = ST25R_IRQ_Pin;\n  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  HAL_GPIO_Init(ST25R_IRQ_GPIO_Port, &GPIO_InitStruct);\n\n  /*Configure GPIO pins : OLED_DC_Pin OLED_RES1_Pin OELD_RES2_Pin OLED_CS2_Pin \n                           MOTOR_POWER_Pin CS_FLASH_Pin OLED_CS1_Pin */\n  GPIO_InitStruct.Pin = OLED_DC_Pin|OLED_RES1_Pin|OELD_RES2_Pin|OLED_CS2_Pin \n                          |MOTOR_POWER_Pin|CS_FLASH_Pin|OLED_CS1_Pin;\n  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);\n\n  /*Configure GPIO pin : HALL_Pin */\n  GPIO_InitStruct.Pin = HALL_Pin;\n  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  HAL_GPIO_Init(HALL_GPIO_Port, &GPIO_InitStruct);\n\n  /* EXTI interrupt init*/\n  HAL_NVIC_SetPriority(EXTI3_IRQn, 0, 0);\n  HAL_NVIC_EnableIRQ(EXTI3_IRQn);\n\n}\n\n/* USER CODE BEGIN 4 */\n\n/* USER CODE END 4 */\n\n/**\n  * @brief  This function is executed in case of error occurrence.\n  * @retval None\n  */\nvoid Error_Handler(void)\n{\n  /* USER CODE BEGIN Error_Handler_Debug */\n  /* User can add his own implementation to report the HAL error return state */\n\n  /* USER CODE END Error_Handler_Debug */\n}\n\n#ifdef  USE_FULL_ASSERT\n/**\n  * @brief  Reports the name of the source file and the source line number\n  *         where the assert_param error has occurred.\n  * @param  file: pointer to the source file name\n  * @param  line: assert_param error line source number\n  * @retval None\n  */\nvoid assert_failed(uint8_t *file, uint32_t line)\n{ \n  /* USER CODE BEGIN 6 */\n  /* User can add his own implementation to report the file name and line number,\n     tex: printf(\"Wrong parameters value: file %s on line %d\\r\\n\", file, line) */\n  /* USER CODE END 6 */\n}\n#endif /* USE_FULL_ASSERT */\n\n\n\n\n\n\n/*==================================================================================\n* 函 数 名： bsp_init\n* 参    数： None\n* 功能描述:  板级初始化\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-24 111301\n==================================================================================*/\nvoid bsp_init(uint8_t can_addr)\n{\n\tSystemClock_Config();\n\n\tMX_GPIO_Init();\n\n\tMX_DMA_Init(); \n\tMX_ADC1_Init();\n\tMX_CAN_Init(can_addr);\n\tMX_SPI1_Init();\n\tMX_SPI2_Init();\n\tMX_TIM2_Init();\n\tMX_TIM3_Init();\n\tMX_USART1_UART_Init();\n}\n\n/*==================================================================================\n* 函 数 名： systerm_init_complete\n* 参    数： None\n* 功能描述:  系统初始化完成\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-08 143228\n==================================================================================*/\nvoid systerm_init_complete(void)\n{\n\t\n\t//使能CAN总线\n\t__HAL_CAN_ENABLE_IT(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING);\t//FIFO0消息挂起中断允许.\t \n\t__HAL_CAN_ENABLE_IT(&hcan, CAN_IT_RX_FIFO1_MSG_PENDING);\t//FIFO0消息挂起中断允许.\t \n\tHAL_CAN_Start(&hcan);\n\tHAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING);\n\tHAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO1_MSG_PENDING);\n}\n",
			"file": "hardware/src/bsp_init.c",
			"file_size": 19219,
			"file_write_time": 132481764563570166,
			"settings":
			{
				"buffer_size": 18869,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"file": "device_lib/ST_RFID/hardware/ST25R3911/Src/main.c",
			"settings":
			{
				"buffer_size": 13132,
				"line_ending": "Unix"
			}
		},
		{
			"file": "device_lib/ST_RFID/hardware/ST25R3911/Src/dispatcher.c",
			"settings":
			{
				"buffer_size": 96065,
				"line_ending": "Unix"
			}
		},
		{
			"file": "device_lib/ST_RFID/hardware/common/utils/Src/stream_dispatcher.c",
			"settings":
			{
				"buffer_size": 7932,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"ex_device.h\"\n#include \"led_beep.h\"\n\n/*==================================================================================\n* 函 数 名： door_open\n* 参    数： None\n* 功能描述:  开门\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-19 163734\n==================================================================================*/\nvoid door_open(void)\n{\n\tMOTOR_ENABLE_OUT(); \t//开  留一定的余量，防止舵机卡到\n\tSERVO_SET_PWM(2400);\n\tHAL_Delay(500);\t\t\t\t//后期不能使用延时操作\n\tMOTOR_DISABLE_OUT()\t;\n}\n\n/*==================================================================================\n* 函 数 名： door_open\n* 参    数： None\n* 功能描述:  开门\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-19 164031\n==================================================================================*/\nvoid door_close(void)\n{\n\tSERVO_SET_PWM(10); \t\t//等待关, 留一定的余量，防止舵机卡到\n\tMOTOR_ENABLE_OUT();\n\tHAL_Delay(500);\t\t\t\t\t//后期不能使用延时操作\n\tMOTOR_DISABLE_OUT();\n}\n\n/*==================================================================================\n* 函 数 名： set_light_mode\n* 参    数： None\n* 功能描述:  设置照明灯状态和亮度\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-19 164031\n==================================================================================*/\nvoid set_light_mode(uint8_t type, int level)\n{\n\t//LIGHT_ENABLE_OUT();\n//\tfor(int i=0; i<=1000; i++)\n//\t{\n\t\tLIGHT_DISABLE_OUT();\n\t\tLIGHT_SET_PWM(level)\t;\n\n\t\tLIGHT_ENABLE_OUT();\n\t\t//HAL_Delay(10);\n//\t}\n}\n\n/*==================================================================================\n* 函 数 名： get_door_state\n* 参    数： None\n* 功能描述:  获取门状态\n* 返 回 值： 0:关  0x1：开\n* 备    注： \n* 作    者：  xiaozh\n* 创建时间： 2019-09-24 124042\n==================================================================================*/\nuint8_t get_door_state(void)\n{\n\tif(READ_HALL_STATUE())\n\t{\n\t\treturn 0;\n\t}\n\telse \n\t{\n\t\treturn 0x01;\n\t}\n}\n\n/*==================================================================================\n* 函 数 名： set_debug_led_state\n* 参    数： None\n* 功能描述:  设置调试灯状态\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-04 141233\n==================================================================================*/\nvoid debug_led_control(uint8_t state)\n{\n\tif(state != 0)\n\t{\n\t MAIN_LED_GPIO_Port->BRR = (uint32_t)MAIN_LED_Pin;\n\t}\n\telse\n\t{\n\t MAIN_LED_GPIO_Port->BSRR = (uint32_t)MAIN_LED_Pin;\n\t}\n}\n\n\n \nvoid ex_device_test()\n{\n\tset_light_mode(0,  1000);\n\tdoor_open();\n\t//BEEP_ON();\n\tHAL_Delay(10000);\n\tdoor_close();\n\tset_light_mode(0,  0);\n\t//BEEP_OFF();\n}\n\n\n",
			"file": "hardware/src/ex_device.c",
			"file_size": 2658,
			"file_write_time": 132481775854876128,
			"settings":
			{
				"buffer_size": 2449,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"contents": "#ifndef  __CAN_DRV_H\n#define  __CAN_DRV_H\n#include <stdint.h>\n#include \"main.h\"\n\n\n#define  CAN_GLOBAL_ADDR\t\t\t0xFF\t\t//can总线全局地址\n#define  CAN_MASTER_ADDR\t\t\t0xAE\t\t//主节点地址\n#define  CAN_ADDR_NULL\t\t\t\t0xFE\t\t\t\t\t//空地址 \n#define  CAN_STD_ID\t\t\t\t\t\t0x12\t\t\t\t\t//标准帧ID\n#define  CAN_FRAME_TYPE\t\t\tCAN_ID_EXT\t\t//本网络中通信都使用扩展帧，波特率250kbps\n\n\n//从机过滤设置\n#define SIGNAL_SLAVE_FILTERID\t\t\t0x0000FF00\t\t//设置过滤，不接收从机数据,只接收主机地址\n#define SIGNAL_SLAVE_MASK\t\t\t\t\t0x0300AE00\t\t//设置掩码，不接收从机数据，只接收单帧数据\n\n\n#define MUTIL_SLAVE_FILTERID\t\t\t0x0300FF00\t\t//设置过滤，不接收从机数据,只接收主机地址 \n#define MUTIL_SLAVE_MASK0\t\t\t\t\t0x0100AE00\t\t//设置掩码，不接收从机数据，只接收单帧数据\n#define MUTIL_SLAVE_MASK1\t\t\t\t\t0x0200AE00\t\t//设置掩码，不接收从机数据，只接收单帧数据\n \n#define MAX_CAN_NUM\t\t\t\t\t\t\t8+1\t//数据域长度\n#define MAX_CACHE_NUM\t\t\t\t\t\t32\t//最大缓存池\n#define MAX_RX_CAN_NUM\t\t\t\t\t256\t\t//最大can接收返回buff\n\n\ntypedef union\n{\n\tstruct\n\t{\n\t\tuint32_t d_addr:8;\t\t\t//目的地址，接收方地址， 0xFF为广播\n\t\tuint32_t s_addr:8;\t\t  //源地址，发送方的地址\n\t\tuint32_t png_cmd:8;\t\t\t//命令字 \n\t\tuint32_t is_sigle:2;\t\t//是否连包，0：为单帧数据  1：连包数据 2:连包结尾\n\t\tuint32_t a_res:3;\t\t\t\t//可用保留\n\t\tuint32_t res:3;\t\t\t\t\t//保留位\n\t}_bit;\n\t\n\tuint32_t EX_ID;\t\t\t//29位\n}_Ex_id,*_pEx_id;\n\ntypedef struct\n{\n\t_Ex_id  ex_id;\t\t//扩展帧ID\t\n\t\n\tuint8_t  byte_count;\n\tuint8_t  data[MAX_CAN_NUM];\n}_Can_Msg,*_pCan_Msg;\n \n\n \nuint8_t  can_sed_pkg_without_cache(void* can_msg); \n#endif\n",
			"file": "hardware/inc/can_drv.h",
			"file_size": 1485,
			"file_write_time": 132478979209776885,
			"settings":
			{
				"buffer_size": 1274,
				"encoding": "Western (Windows 1252)",
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"contents": "#ifndef  __EX_DEVICE_H\n#define  __EX_DEVICE_H\n\n#include \"main.h\"\n  \n \n#define   LIGHT_ENABLE_OUT()\t\t\t\tdo { \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t TIM3->CCER &= ~(TIM_CCER_CC1E << TIM_CHANNEL_1);\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t TIM3->CCER |=  (uint32_t)(TIM_CCx_ENABLE << TIM_CHANNEL_1);\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} while(0)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n#define   LIGHT_DISABLE_OUT()\t\t\t\tdo { \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t TIM3->CCER &= ~(TIM_CCER_CC1E << TIM_CHANNEL_1);\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTIM3->CCER |=  (uint32_t)(TIM_CCx_DISABLE << TIM_CHANNEL_1);\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} while(0)\n\n#define  LIGHT_SET_PWM(value)\t\t\t\t\t(TIM3->CCR1 = value)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\n\n#define  MOTOR_ENABLE_OUT()\t\t\t\t\t\tdo{GPIOB->BSRR = GPIO_PIN_3;}while(0)\n#define  MOTOR_DISABLE_OUT()\t\t\t\t\tdo{GPIOB->BSRR = (uint32_t)GPIO_PIN_3 << 16u;}while(0)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n#define   SERVO_ENABLE_OUT()\t\t\t\tdo { \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t TIM2->CCER &= ~(TIM_CCER_CC1E << TIM_CHANNEL_3);\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t TIM2->CCER |=  (uint32_t)(TIM_CCx_ENABLE << TIM_CHANNEL_3);\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} while(0)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n#define   SERVO_DISABLE_OUT()\t\t\t\tdo { \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t TIM2->CCER &= ~(TIM_CCER_CC1E << TIM_CHANNEL_3);\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTIM2->CCER |=  (uint32_t)(TIM_CCx_DISABLE << TIM_CHANNEL_3);\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} while(0)\n\n#define  SERVO_SET_PWM(value)\t\t\t\t(TIM2->CCR3 = value)\n \n#define READ_HALL_STATUE()\t\t\t\t\tHAL_GPIO_ReadPin(HALL_GPIO_Port, HALL_Pin)\t\t//1:CLOSE  0:OPEN\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ntypedef enum\n{\n\tBright_to_Dark=0,\t\t//从亮到灭\n\tDark_to_Bright,\t\t//从灭到亮\n\t\n}_Light_Type;\n\n\nuint16_t get_temperature(void); //获取温度值\nuint8_t get_door_state(void);\t//获取门状态\nvoid door_open(void);\t\nvoid door_close(void);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n#endif\n",
			"file": "hardware/inc/ex_device.h",
			"file_size": 1715,
			"file_write_time": 132478979209857644,
			"settings":
			{
				"buffer_size": 1697,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"contents": "Searching 1276 files for \"ex_device_test\" (regex, case sensitive, whole word)\n\n/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/hardware/src/ex_device.c:\n  102  \n  103   \n  104: void ex_device_test()\n  105  {\n  106  \tset_light_mode(0,  1000);\n\n/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/MDK-ARM/CAN_BOX/CAN_BOX.map:\n  646      ex_device.o(i.door_close) refers to stm32f1xx_hal.o(i.HAL_Delay) for HAL_Delay\n  647      ex_device.o(i.door_open) refers to stm32f1xx_hal.o(i.HAL_Delay) for HAL_Delay\n  648:     ex_device.o(i.ex_device_test) refers to ex_device.o(i.door_open) for door_open\n  649:     ex_device.o(i.ex_device_test) refers to stm32f1xx_hal.o(i.HAL_Delay) for HAL_Delay\n  650:     ex_device.o(i.ex_device_test) refers to ex_device.o(i.door_close) for door_close\n  651      ex_device.o(i.get_door_state) refers to stm32f1xx_hal_gpio.o(i.HAL_GPIO_ReadPin) for HAL_GPIO_ReadPin\n  652      ex_device.o(i.set_light_mode) refers to stm32f1xx_hal.o(i.HAL_Delay) for HAL_Delay\n  ...\n 1692      Removing ex_device.o(.revsh_text), (4 bytes).\n 1693      Removing ex_device.o(.rrx_text), (6 bytes).\n 1694:     Removing ex_device.o(i.ex_device_test), (22 bytes).\n 1695      Removing ex_device.o(i.set_light_mode), (84 bytes).\n 1696      Removing rfid_class.o(.rev16_text), (4 bytes).\n\n/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/MDK-ARM/CAN_BOX/cc_box.axf:\n    <binary>\n\n/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/MDK-ARM/CAN_BOX/cc_box.htm:\n  811  <LI><a href=\"#[ed]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main_oled_test\n  812  <LI><a href=\"#[47]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main\n  813: <LI><a href=\"#[df]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ex_device_test\n  814  <LI><a href=\"#[de]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;door_open\n  815  <LI><a href=\"#[dd]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;door_close\n  ...\n 1368  <BR>[Calls]<UL><LI><a href=\"#[a2]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HAL_Delay\n 1369  </UL>\n 1370: <BR>[Called By]<UL><LI><a href=\"#[df]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ex_device_test\n 1371  </UL>\n 1372  \n ....\n 1376  <BR>[Calls]<UL><LI><a href=\"#[a2]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HAL_Delay\n 1377  </UL>\n 1378: <BR>[Called By]<UL><LI><a href=\"#[df]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ex_device_test\n 1379  </UL>\n 1380  \n 1381: <P><STRONG><a name=\"[df]\"></a>ex_device_test</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, ex_device.o(.text.ex_device_test))\n 1382: <BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = ex_device_test &rArr; door_open &rArr; HAL_Delay\n 1383  </UL>\n 1384  <BR>[Calls]<UL><LI><a href=\"#[a2]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HAL_Delay\n ....\n 1459  <LI><a href=\"#[ea]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rfalAnalogConfigInitialize\n 1460  <LI><a href=\"#[ed]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main_oled_test\n 1461: <LI><a href=\"#[df]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ex_device_test\n 1462  <LI><a href=\"#[ec]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HAL_GPIO_TogglePin\n 1463  <LI><a href=\"#[a2]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HAL_Delay\n ....\n 2094  <BR>[Calls]<UL><LI><a href=\"#[a2]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HAL_Delay\n 2095  </UL>\n 2096: <BR>[Called By]<UL><LI><a href=\"#[df]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ex_device_test\n 2097  </UL>\n 2098  \n\n/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/MDK-ARM/CAN_BOX/cc_box.map:\n   50      main.o(.text.main) refers to rfal_rfst25r3916.o(.text.rfalInitialize) for rfalInitialize\n   51      main.o(.text.main) refers to stm32f1xx_hal_gpio.o(.text.HAL_GPIO_TogglePin) for HAL_GPIO_TogglePin\n   52:     main.o(.text.main) refers to ex_device.o(.text.ex_device_test) for ex_device_test\n   53      main.o(.text.main) refers to oled_drv.o(.text.main_oled_test) for main_oled_test\n   54      main.o(.text.main) refers to st25r3916_com.o(.text.st25r3916SetRegisterBits) for st25r3916SetRegisterBits\n   ..\n 1427      ex_device.o(.ARM.exidx.text.get_door_state) refers to ex_device.o(.text.get_door_state) for [Anonymous Symbol]\n 1428      ex_device.o(.ARM.exidx.text.debug_led_control) refers to ex_device.o(.text.debug_led_control) for [Anonymous Symbol]\n 1429:     ex_device.o(.text.ex_device_test) refers to ex_device.o(.text.set_light_mode) for set_light_mode\n 1430:     ex_device.o(.text.ex_device_test) refers to ex_device.o(.text.door_open) for door_open\n 1431:     ex_device.o(.text.ex_device_test) refers to stm32f1xx_hal.o(.text.HAL_Delay) for HAL_Delay\n 1432:     ex_device.o(.text.ex_device_test) refers to ex_device.o(.text.door_close) for door_close\n 1433:     ex_device.o(.ARM.exidx.text.ex_device_test) refers to ex_device.o(.text.ex_device_test) for [Anonymous Symbol]\n 1434      rfid_class.o(.ARM.exidx.text.antennaAmplitudeCalibrate) refers to rfid_class.o(.text.antennaAmplitudeCalibrate) for [Anonymous Symbol]\n 1435      rfid_class.o(.text.rfid_context_init) refers to rfid_class.o(.bss.mTag_Context) for mTag_Context\n ....\n 3542      Removing ex_device.o(.text.debug_led_control), (20 bytes).\n 3543      Removing ex_device.o(.ARM.exidx.text.debug_led_control), (8 bytes).\n 3544:     Removing ex_device.o(.ARM.exidx.text.ex_device_test), (8 bytes).\n 3545      Removing rfid_class.o(.text), (0 bytes).\n 3546      Removing rfid_class.o(.text.antennaAmplitudeCalibrate), (2 bytes).\n ....\n 5009      __arm_cp.0_0                             0x08003a28   Number         4  ex_device.o(.text.door_open)\n 5010      __arm_cp.0_1                             0x08003a2c   Number         4  ex_device.o(.text.door_open)\n 5011:     [Anonymous Symbol]                       0x08003a30   Section        0  ex_device.o(.text.ex_device_test)\n 5012      [Anonymous Symbol]                       0x08003a56   Section        0  uart_debug.o(.text.fputc)\n 5013      gt_sed_rev_byte                          0x08003a65   Thumb Code    28  gt32l_drv.o(.text.gt_sed_rev_byte)\n ....\n 5606      door_close                               0x080039e9   Thumb Code    32  ex_device.o(.text.door_close)\n 5607      door_open                                0x08003a09   Thumb Code    40  ex_device.o(.text.door_open)\n 5608:     ex_device_test                           0x08003a31   Thumb Code    38  ex_device.o(.text.ex_device_test)\n 5609      fputc                                    0x08003a57   Thumb Code    14  uart_debug.o(.text.fputc)\n 5610      inter_init                               0x08003a81   Thumb Code     2  interface.o(.text.inter_init)\n ....\n 5989      0x080039e8   0x080039e8   0x00000020   Code   RO         1146    .text.door_close    ex_device.o\n 5990      0x08003a08   0x08003a08   0x00000028   Code   RO         1144    .text.door_open     ex_device.o\n 5991:     0x08003a30   0x08003a30   0x00000026   Code   RO         1154    .text.ex_device_test  ex_device.o\n 5992      0x08003a56   0x08003a56   0x0000000e   Code   RO          235    .text.fputc         uart_debug.o\n 5993      0x08003a64   0x08003a64   0x0000001c   Code   RO         1239    .text.gt_sed_rev_byte  gt32l_drv.o\n\n/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/MDK-ARM/CAN_BOX/ex_device.crf:\n    <binary>\n\n/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/Src/main.c:\n  323  \t\t} \n  324  \n  325: \t\tex_device_test();\n  326  \twhile(1)\n  327  \t{\n\n30 matches across 7 files\n\n\nSearching 1276 files for \"set_light_mode\" (regex, case sensitive, whole word)\n\n/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/hardware/src/ex_device.c:\n   37  \n   38  /*==================================================================================\n   39: * 函 数 名： set_light_mode\n   40  * 参    数： None\n   41  * 功能描述:  设置照明灯状态和亮度\n   ..\n   45  * 创建时间： 2019-09-19 164031\n   46  ==================================================================================*/\n   47: void set_light_mode(uint8_t type, int level)\n   48  {\n   49  \t//LIGHT_ENABLE_OUT();\n   ..\n  104  void ex_device_test()\n  105  {\n  106: \tset_light_mode(0,  1000);\n  107  \tdoor_open();\n  108  \t//BEEP_ON();\n  109  \tHAL_Delay(10000);\n  110  \tdoor_close();\n  111: \tset_light_mode(0,  0);\n  112  \t//BEEP_OFF();\n  113  }\n\n/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/MDK-ARM/CAN_BOX/CAN_BOX.map:\n  650      ex_device.o(i.ex_device_test) refers to ex_device.o(i.door_close) for door_close\n  651      ex_device.o(i.get_door_state) refers to stm32f1xx_hal_gpio.o(i.HAL_GPIO_ReadPin) for HAL_GPIO_ReadPin\n  652:     ex_device.o(i.set_light_mode) refers to stm32f1xx_hal.o(i.HAL_Delay) for HAL_Delay\n  653      rfid_class.o(i.add_new_item) refers to rfid_class.o(i.find_avalib_node) for find_avalib_node\n  654      rfid_class.o(i.add_new_item) refers to interface.o(i.sed_rfid_tag) for sed_rfid_tag\n  ...\n 1693      Removing ex_device.o(.rrx_text), (6 bytes).\n 1694      Removing ex_device.o(i.ex_device_test), (22 bytes).\n 1695:     Removing ex_device.o(i.set_light_mode), (84 bytes).\n 1696      Removing rfid_class.o(.rev16_text), (4 bytes).\n 1697      Removing rfid_class.o(.revsh_text), (4 bytes).\n\n/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/MDK-ARM/CAN_BOX/cc_box.axf:\n    <binary>\n\n/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/MDK-ARM/CAN_BOX/cc_box.build_log.htm:\n   50  compiling ex_device.c...\n   51  ../hardware/src/ex_device.c(106): warning: implicit conversion from 'int' to 'uint8_t' (aka 'unsigned char') changes value from 1000 to 232 [-Wconstant-conversion]\n   52:         set_light_mode(0,  1000);\n   53          ~~~~~~~~~~~~~~     ^~~~\n   54  1 warning generated.\n\n/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/MDK-ARM/CAN_BOX/cc_box.htm:\n  818  <LI><a href=\"#[143]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rfalWorker\n  819  <LI><a href=\"#[126]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rfalISO15693TransceiveAnticollisionFrame\n  820: <LI><a href=\"#[e0]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_light_mode\n  821  <LI><a href=\"#[14b]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;scanRfidTag\n  822  </UL>\n  ...\n 1385  <LI><a href=\"#[de]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;door_open\n 1386  <LI><a href=\"#[dd]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;door_close\n 1387: <LI><a href=\"#[e0]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_light_mode\n 1388  </UL>\n 1389  <BR>[Called By]<UL><LI><a href=\"#[47]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main\n ....\n 2089  </UL>\n 2090  \n 2091: <P><STRONG><a name=\"[e0]\"></a>set_light_mode</STRONG> (Thumb, 44 bytes, Stack size 0 bytes, ex_device.o(.text.set_light_mode))\n 2092: <BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = set_light_mode &rArr; HAL_Delay\n 2093  </UL>\n 2094  <BR>[Calls]<UL><LI><a href=\"#[a2]\">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HAL_Delay\n\n/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/MDK-ARM/CAN_BOX/cc_box.map:\n 1422      ex_device.o(.text.door_close) refers to stm32f1xx_hal.o(.text.HAL_Delay) for HAL_Delay\n 1423      ex_device.o(.ARM.exidx.text.door_close) refers to ex_device.o(.text.door_close) for [Anonymous Symbol]\n 1424:     ex_device.o(.text.set_light_mode) refers to stm32f1xx_hal.o(.text.HAL_Delay) for HAL_Delay\n 1425:     ex_device.o(.ARM.exidx.text.set_light_mode) refers to ex_device.o(.text.set_light_mode) for [Anonymous Symbol]\n 1426      ex_device.o(.text.get_door_state) refers to stm32f1xx_hal_gpio.o(.text.HAL_GPIO_ReadPin) for HAL_GPIO_ReadPin\n 1427      ex_device.o(.ARM.exidx.text.get_door_state) refers to ex_device.o(.text.get_door_state) for [Anonymous Symbol]\n 1428      ex_device.o(.ARM.exidx.text.debug_led_control) refers to ex_device.o(.text.debug_led_control) for [Anonymous Symbol]\n 1429:     ex_device.o(.text.ex_device_test) refers to ex_device.o(.text.set_light_mode) for set_light_mode\n 1430      ex_device.o(.text.ex_device_test) refers to ex_device.o(.text.door_open) for door_open\n 1431      ex_device.o(.text.ex_device_test) refers to stm32f1xx_hal.o(.text.HAL_Delay) for HAL_Delay\n ....\n 3537      Removing ex_device.o(.ARM.exidx.text.door_open), (8 bytes).\n 3538      Removing ex_device.o(.ARM.exidx.text.door_close), (8 bytes).\n 3539:     Removing ex_device.o(.ARM.exidx.text.set_light_mode), (8 bytes).\n 3540      Removing ex_device.o(.text.get_door_state), (24 bytes).\n 3541      Removing ex_device.o(.ARM.exidx.text.get_door_state), (8 bytes).\n ....\n 5173      [Anonymous Symbol]                       0x08006a2a   Section        0  spi_class.o(.text.sed_rev_byte)\n 5174      [Anonymous Symbol]                       0x08006a46   Section        0  rfid_class.o(.text.sed_rfid_tag)\n 5175:     [Anonymous Symbol]                       0x08006ad4   Section        0  ex_device.o(.text.set_light_mode)\n 5176:     __arm_cp.2_0                             0x08006afc   Number         4  ex_device.o(.text.set_light_mode)\n 5177      [Anonymous Symbol]                       0x08006b00   Section        0  oled_drv.o(.text.show_read_tag)\n 5178      __arm_cp.17_2                            0x08006c14   Number         4  oled_drv.o(.text.show_read_tag)\n ....\n 5672      screen_show_string                       0x08006941   Thumb Code   176  oled_drv.o(.text.screen_show_string)\n 5673      sed_rfid_tag                             0x08006a47   Thumb Code   142  rfid_class.o(.text.sed_rfid_tag)\n 5674:     set_light_mode                           0x08006ad5   Thumb Code    44  ex_device.o(.text.set_light_mode)\n 5675      show_read_tag                            0x08006b01   Thumb Code   292  oled_drv.o(.text.show_read_tag)\n 5676      st25r3916AdjustRegulators                0x08006c25   Thumb Code    98  st25r3916.o(.text.st25r3916AdjustRegulators)\n ....\n 6080      0x08006a2a   0x08006a2a   0x0000001c   Code   RO         1071    .text.sed_rev_byte  spi_class.o\n 6081      0x08006a46   0x08006a46   0x0000008e   Code   RO         1199    .text.sed_rfid_tag  rfid_class.o\n 6082:     0x08006ad4   0x08006ad4   0x0000002c   Code   RO         1148    .text.set_light_mode  ex_device.o\n 6083      0x08006b00   0x08006b00   0x00000124   Code   RO         1128    .text.show_read_tag  oled_drv.o\n 6084      0x08006c24   0x08006c24   0x00000062   Code   RO          578    .text.st25r3916AdjustRegulators  st25r3916.o\n\n/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/MDK-ARM/CAN_BOX/ex_device.crf:\n    <binary>\n\n26 matches across 7 files\n",
			"settings":
			{
				"buffer_size": 13759,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "Inc/main.h",
			"settings":
			{
				"buffer_size": 3175,
				"line_ending": "Unix"
			}
		},
		{
			"file": "hardware/inc/led_beep.h",
			"settings":
			{
				"buffer_size": 268,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"led_beep.h\"\n\n \nvoid led_beep(void)\n{\n//\tBEEP_ON();\n//\tHAL_Delay(500);\n//\tBEEP_OFF();\n//\t\n//\tLIGHT_ENABLE_OUT()\t;\n//\tfor(int i=0; i<=1000; i++)\n//\t{\n////\t\tLIGHT_DISABLE_OUT()\t;\n//\t\t\tLIGHT_SET_PWM(i)\t;\n//\t\t\n////\t\t\tLIGHT_ENABLE_OUT();\n//\t\tHAL_Delay(10);\n//\t}\n//\t\n//\tSERVO_ENABLE_OUT();\n\n//\t\t\tMOTOR_ENABLE_OUT(); \t//开\n//\t\t\tSERVO_SET_PWM(10);\n//\t\t\tHAL_Delay(500);\n//\t\t\tMOTOR_DISABLE_OUT()\t;\n\t \n//\t\tSERVO_SET_PWM(600); \t\t//等待关\n//\t\tMOTOR_ENABLE_OUT();\n//\t\tHAL_Delay(200);\n//\t\tMOTOR_DISABLE_OUT()\t;\n\t \n//\tif(!READ_HALL_STATUE())\n//\t{\n//\t\tLIGHT_ENABLE_OUT()\t;\n//\t}\n//\telse\n//\t{\n//\t\tLIGHT_DISABLE_OUT()\t;\n//\t}\n\tHAL_Delay(100);\n}\n",
			"file": "hardware/src/led_beep.c",
			"file_size": 633,
			"file_write_time": 132478979135841352,
			"settings":
			{
				"buffer_size": 629,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"contents": "#include \"command.h\"\n#include \"includes.h\"\n\nextern _App_Param mApp_Param;\n\n\nstatic uint8_t check_can_frame(void *ret_msg);\nstatic void can_read_parse(void* ret_msg);\nstatic void can_write_parse(void* ret_msg);\nstatic void can_update_tag_info(void* ret_msg);\nstatic uint8_t can_simply_ack(uint8_t cmd, uint8_t state);\nstatic void cfg_can_addr(void* ret_msg);\n\n#define SIMPLY_ACK(state) \t\t\tcan_simply_ack(pmsg->ex_id._bit.png_cmd, state)\n\n/*==================================================================================\n* 函 数 名： can_frame_parse\n* 参    数： None\n* 功能描述:  can协议解析\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-09-24 162950\n==================================================================================*/\nvoid can_frame_parse(void* ret_msg)\n{\n\t_pRet_Msg pmsg = ret_msg;\n\t//判断数据合法性\n\tif((pmsg->ex_id._bit.d_addr != mApp_Param.can_addr)&&(pmsg->ex_id._bit.d_addr != CAN_GLOBAL_ADDR)&&(mApp_Param.can_addr != CAN_ADDR_NULL))\t//判断是否为自己的地址\n\t{\n\t\treturn ;\n\t}\n\t\n\t//判断数据合法性\n\tif(pmsg->ex_id._bit.is_sigle != 0)\t\t//如果不为单帧数据\n\t{\n\t\t//进行CRC校验\n\t\tif(check_can_frame(ret_msg) != 0)\t//检验成功\n\t\t{\n\t\t\treturn ;\n\t\t}\n\t}\n\t\n\tdebug_print(\"can_rev,\");\n\tdebug_print(\"ex_id:%4x, \", pmsg->ex_id.EX_ID);\n\tdebug_print(\"lens=0x%02x, \", pmsg->byte_count);\n\tdebug_print(\"rev_data:\");\n\tdebug_print_hex(pmsg->data, pmsg->byte_count);\n\tdebug_print(\"\\n\");\n\t \n\t//进行协议解析\n\tswitch(pmsg->ex_id._bit.png_cmd)\n\t{\n\t\tcase get_hb_cmd:\t//查询心跳\n\t\t{\n\t\t\tcan_sed_heartbeat();\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase read_cmd:\t//状态读取\n\t\t{\n\t\t\tcan_read_parse(pmsg);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase write_cmd:\t//写\n\t\t{\n\t\t\tcan_write_parse(pmsg);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase update_tag_info:\n\t\t{\n\t\t\tcan_update_tag_info(pmsg);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t/*============================地址分配==========================*/\n\t\tcase config_can_addr:\t//配置CAN总线地址\n\t\t{\n\t\t\tcfg_can_addr(ret_msg);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdefault:\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n  \n/*==================================================================================\n* 函 数 名： check_can_frame\n* 参    数： None\n* 功能描述:  校验CAN数据数据是否完整\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-29 145723\n==================================================================================*/ \nstatic uint8_t check_can_frame(void *ret_msg)\n{\n\t_pRet_Msg pmsg = ret_msg;\n\tuint16_t crc_16 = 0; \n\t\t\n\t//判断是否是自己的数据\n\t\t//进行数据校验\n\tif((crc_16 = crc16_ccitt(pmsg->data, pmsg->byte_count-2)) == *(uint16_t *)(pmsg->data+pmsg->byte_count-2))\t//判断CRC校验\n\t{\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\t\t\n\t\tprintf(\"crc is error, crc = %04x, data[crc]=%2X\\n\",crc_16, *(uint16_t *)(pmsg->data+pmsg->byte_count-2));\n\t\treturn 0x82;\n\t}\n}\n\n/*==================================================================================\n* 函 数 名： can_sed_heartbeat\n* 参    数： None\n* 功能描述:  发送心跳包\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-24 121722\n==================================================================================*/\nvoid can_sed_heartbeat(void)\n{\n\tuint8_t sed_buff[8] = {0}; \n\tuint16_t temp = 0;\n\t \n\tsed_buff[0] = (get_door_state() & 0x03);\t//门状态\n\t\n\ttemp = get_adc_temp();\n\tsed_buff[1] = (uint8_t)((temp>>8)&0x00FF);\t//温度\n\tsed_buff[2] = (uint8_t)((temp)&0x00FF);\t\t\t//温度\n\t\n\ttemp = get_adc_ev();\n\tsed_buff[3] = (uint8_t)((temp>>8)&0x00FF);\t//电流\n\tsed_buff[4] = (uint8_t)((temp)&0x00FF);\t\t\t//电流 \n\tsed_buff[5] = SOFT_VERSION;\t//软件版本\n\tsed_buff[6] = mApp_Param.hard_ver;\t//硬件版本\n\tsed_buff[7] = get_total_tag_num();\t//标签总个数\n\t \n\tcan_sed_link_pkg(get_hb_cmd, CAN_MASTER_ADDR, sed_buff, 8);\n}\n\n/*==================================================================================\n* 函 数 名： can_simply_ack\n* 参    数： None\n* 功能描述:  can命令简单响应\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-08 122358\n==================================================================================*/\nstatic uint8_t can_simply_ack(uint8_t cmd, uint8_t state)\n{\n\tuint8_t sed_buff[1] = {0};  \n\n\tsed_buff[0] = state;\t//门状态\n\n\tcan_sed_link_pkg(cmd, CAN_MASTER_ADDR, sed_buff, 1);\n\n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： can_read_parse\n* 参    数： None\n* 功能描述:  can协议解析\n* 返 回 值： None\n* 备    注： 默认间隔10ms进行接收数据解析\n* 作    者： xiaozh\n* 创建时间： 2019-09-23 180348\n==================================================================================*/\nstatic void can_read_parse(void* ret_msg)\n{\n\t\n}\n\n/*==================================================================================\n* 函 数 名： can_update_tag_info\n* 参    数： None\n* 功能描述:  can更新标签信息\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-30 151308\n==================================================================================*/\nstatic void can_update_tag_info(void* ret_msg)\n{\n\t_pRet_Msg pmsg = ret_msg;\n\n\t//判断数据帧中协议带的标签信息\n\ttag_info_param_ack(pmsg->data, pmsg->byte_count);\n\t\n}\n\n\n/*==================================================================================\n* 函 数 名： cfg_can_addr\n* 参    数： None\n* 功能描述:  配置总线地址\n* 返 回 值： None\n* 备    注： 配置地址\n* 作    者： xiaozh\n* 创建时间： 2019-11-08 114953\n==================================================================================*/\nstatic void cfg_can_addr(void* ret_msg)\n{ \n\t_pRet_Msg pmsg = ret_msg;\n\t\n\tprintf(\"entry cfg_can_addr\\n\");\n\t//校验数据帧是否合法\n\tif(pmsg->data[0] == 0xAA)\t//判读固定字\n\t{\n\t\tif((crc8(pmsg->data, 3) == pmsg->data[3])&&(pmsg->data[1]+pmsg->data[2] == 0xFF))\t\t//校验是否合法\n\t\t{\n\t\t\t//配置地址参数\n\t\t\tconfig_mcan_addr(pmsg->data[1]);\n\t\t\t\n\t\t\tprintf(\"addr check is ok! addr=%d \\n\", pmsg->data[1]);\n\t\t\t//回复主机点配置成功\n\t\t\tSIMPLY_ACK(0x01);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//回复主机点配置失败\n\t\t\tSIMPLY_ACK(0x81);\n\t\t}\n\t}\n}\n\n/*==================================================================================\n* 函 数 名： can_write_parse\n* 参    数： None\n* 功能描述:  can协议解析\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-09-23 180348\n==================================================================================*/\nstatic void can_write_parse(void* ret_msg)\n{\n\t_pRet_Msg pmsg = ret_msg;\n\tswitch(pmsg->data[0])\t\t//查询索引操作\n\t{\n\t\tcase box_control_cmd:\t\t//box电源控制控制\n\t\t{ \n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase led_control_cmd:\t//LED灯控制\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase heat_control_cmd:\t//加热控制\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase screen_control_cmd:\t//屏幕操作\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase reader_control_cmd:\t//读写器\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase door_control_cmd:\t\t//门控制\n\t\t{\n\t\t\tif(pmsg->data[1] & 0x01)\t\t//1开\n\t\t\t{\n\t\t\t\tdoor_open();\n\t\t\t}\n\t\t\telse if(pmsg->data[1] & 0x02)\t//等待关关\n\t\t\t{\n\t\t\t\tdoor_close();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase beep_control_cmd:\t//蜂鸣器控制\n\t\t{\n\t\t\tif(pmsg->data[1] & 0x01)\t\t//1开\n\t\t\t{\n\t\t\t\tBEEP_ON();\n\t\t\t}\n\t\t\telse\t//关\n\t\t\t{\n\t\t\t\tBEEP_OFF();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase display_cmd:\t//显示命令\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdefault:\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n",
			"file": "application/src/command.c",
			"file_size": 7074,
			"file_write_time": 132479103325013499,
			"settings":
			{
				"buffer_size": 6590,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"contents": "#include \"comm_can.h\" \n#include \"crc.h\"\n#include \"can_def_fifo.h\"\n#include \"includes.h\"\n\n\nstatic _Mutil_Ring \t mMutil_Ring[MAX_MUTIL_ITEM_NUM];\t\t//多包接收 \nstatic _Can_Instance mCan_Instance;\n \nstatic _Can_Msg can_sed_fifo[CAN_MAX_CACHE_LEN];\t//can发送缓存\nstatic _Can_Msg can_rev_fifo[CAN_MAX_CACHE_LEN];\t//can接收缓存（单帧）\nstatic uint64_t mutil_mark_table[64] = {0};\n\n#define ID_MASK\t\t\t0xFCFFFFFF\n#define COMPARE_ID(ID1, ID2) (((ID1&ID_MASK) == (ID2&ID_MASK))?(1):(0))\t\t//对比两个ID是否相同，长包\n\n/*==================================================================================\n* 函 数 名： can_instance_init\n* 参    数： None\n* 功能描述:  can初始化\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-28 170617\n==================================================================================*/\nvoid can_instance_init(void)\n{\n\t//初始化函数接口\n\tmCan_Instance.p_ffunc\t= pCan_Fifo_Func,\n\t\n\t//发送接收缓存初始化（单帧） \n\t mCan_Instance.Sed_Fifo = mCan_Instance.p_ffunc->init_m(can_sed_fifo, CAN_MAX_CACHE_LEN);\n\t mCan_Instance.Rcv_Fifo = mCan_Instance.p_ffunc->init_m(can_rev_fifo, CAN_MAX_CACHE_LEN); \n\t\n\t//长帧接收初始化\n\tmCan_Instance.pMutil_Fifo = mMutil_Ring;\n\t\n\tfor(int i=0; i<MAX_MUTIL_ITEM_NUM; i++)\n\t{\n\t\tmMutil_Ring[i].ex_id.EX_ID = 0;\n\t\tmMutil_Ring[i].in_use = 0;\n\t\tmMutil_Ring[i].is_complete = 0;\n\t\tmMutil_Ring[i].real_mark = 0;\n\t\tmemset(mMutil_Ring[i].r_data, 0, sizeof(mMutil_Ring[i].r_data));\n\t}\n\t \n\tfor(int i=0; i<64; i++)\n\t{\n\t\tfor(int j=0; j<i+1; j++)\n\t\t{\n\t\t\tmutil_mark_table[i] |= (0x0000000000000001<<j);\t\t//空间换时间\n\t\t}\n\t} \n}\n \n/*==================================================================================\n* 函 数 名： find_avalib_node\n* 参    数： None\n* 功能描述:  查找可以节点\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-28 161141\n==================================================================================*/\nstatic uint8_t find_null_node(void)\n{\n\t//查询可用空节点索引\n\tfor(int i=0; i<MAX_MUTIL_ITEM_NUM; i++)\t//从后往前查找可用的ID号\n\t{\n\tif(mMutil_Ring[i].in_use  == 0)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\t  \n\treturn 0xFF;\t//空，没有可用\n}\n\n/*==================================================================================\n* 函 数 名： delete_item_node\n* 参    数： None\n* 功能描述:  清空节点\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-28 161141\n==================================================================================*/\nstatic uint8_t delete_item_node(uint8_t index)\n{  \n\t  //清空缓存\n\tmMutil_Ring[index].in_use = 0;\t//删除不合法帧 \n\tmMutil_Ring[index].is_complete = 0;\n\tmMutil_Ring[index].ex_id.EX_ID = 0;\n\tmMutil_Ring[index].real_mark = 0;\n\tmMutil_Ring[index].r_len = 0;\n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： item_is_exist\n* 参    数： None\n* 功能描述:  查看是否已经存在\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-28 161141\n==================================================================================*/\nstatic uint8_t item_is_exist(uint32_t ex_id)\n{\n\tuint8_t ret_index = 0xFF;\t//返回的节点索引\n\t_pEx_id pmsg = (_pEx_id)&ex_id; \n\t\n\t//查询当前地址是否已经有缓存帧\n\tfor(int j=0; j<MAX_MUTIL_ITEM_NUM; j++)\t//从后往前查找可用的ID号\n\t{ \n\t\tif(COMPARE_ID(mMutil_Ring[j].ex_id.EX_ID , ex_id))\t//判断ID是否相同\n\t\t{\n\t\t\tret_index = j;\n\t\t}\n\t}\n\t\n\t//没有接收完成的包，丢了结尾帧情况\n\tif(ret_index == 0xFF)\n\t{\n\t\tfor(int i=0; i<MAX_MUTIL_ITEM_NUM; i++)\t//从后往前查找可用的ID号\n\t\t{\n\t\t\tif(mMutil_Ring[i].ex_id._bit.s_addr == pmsg->_bit.s_addr)\t//如果存在相同地址\n\t\t\t{\n\t\t\t\tif((mMutil_Ring[i].is_complete == 0)&&(mMutil_Ring[i].in_use != 0))\t//没有接收完成\n\t\t\t\t{\n\t\t\t\t\t//直接覆盖没有接收完整节点\n\t\t\t\t\tmMutil_Ring[i].ex_id.EX_ID = ex_id;\n\t\t\t\t\tmMutil_Ring[i].real_mark = 0;\n\t\t\t\t\tmMutil_Ring[i].r_len = 0;\n\t\t\t\t\tret_index = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t \n\treturn ret_index;\t//空，没有可用\n}\n\n/*==================================================================================\n* 函 数 名： can_recv_frame\n* 参    数： _pCan_Msg\n* 功能描述:  can总线数据接收\n* 返 回 值： None\n* 备    注： 在中断\n* 作    者： xiaozh\n* 创建时间： 2019-10-28 154449\n==================================================================================*/\nuint8_t can_recv_mutil_frame(void *can_msg)\n{\n\tuint8_t new_index = 0;\t//申请索引\n\t_pCan_Msg pmsg = can_msg;\n\n\tif(pmsg->ex_id._bit.is_sigle == 0)\t//帧错误\n\t{\n\t\treturn 0x81;\n\t}\n\telse\n\t{\n\t\t//判断当前id是否存在\n\t\tif((new_index = item_is_exist(pmsg->ex_id.EX_ID)) == 0xFF)\n\t\t{\n\t\t\t//不存在，则申请新表\n\t\t\tnew_index = find_null_node();\n\n\t\t\t//保存到缓存\n\t\t\tmMutil_Ring[new_index].in_use = 0x01;\t//使用中\n\t\t\tmMutil_Ring[new_index].ex_id.EX_ID = pmsg->ex_id.EX_ID;\n\t\t\tmMutil_Ring[new_index].r_len = (pmsg->byte_count-1);\n\t\t\tmemcpy(mMutil_Ring[new_index].r_data, pmsg->data+1, pmsg->byte_count-1);\t\n\t\t\t//标记接收\n\t\t\tmMutil_Ring[new_index].real_mark = (0x0000000000000001<<pmsg->data[0]);\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//已经存在\n\n\t\t\t//保存到缓存\n\t\t\tmMutil_Ring[new_index].in_use = 0x01;\t//使用中\n\t\t\tmMutil_Ring[new_index].r_len += (pmsg->byte_count-1);\n\t\t\tmemcpy(mMutil_Ring[new_index].r_data+pmsg->data[0]*7, pmsg->data+1, pmsg->byte_count-1);\t\n\t\t\t//标记接收\n\t\t\tmMutil_Ring[new_index].real_mark |= (0x0000000000000001<<pmsg->data[0]);\n\n\t\t\t//判断是否为末尾帧\n\t\t\tif(pmsg->ex_id._bit.is_sigle == 0x02)\t//末尾帧\n\t\t\t{\n\t\t\t\tif(mMutil_Ring[new_index].real_mark == mutil_mark_table[pmsg->data[0]])\n\t\t\t\t{\n\t\t\t\t\tmMutil_Ring[new_index].is_complete = 0x01;\t//接收完成\n\t\t\t\t\tmMutil_Ring[new_index].ex_id._bit.is_sigle = 0x03;\t//接收完成\n\t\t\t\t\t//CRC校验留在协议解析，防止过多占用中断\n\t\t\t\t\tprintf(\"rev complete\\n\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//清空节点\n\t\t\t\t\tdelete_item_node(new_index);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： can_recv_frame\n* 参    数： _pCan_Msg\n* 功能描述:  can总线数据接收\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-28 154449\n==================================================================================*/\nuint8_t can_recv_signal_frame(void *can_msg)\n{\n\tmCan_Instance.p_ffunc->push(mCan_Instance.Rcv_Fifo, can_msg);\n\t\n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： can_pop_one_frame\n* 参    数： _pRet_Msg\n* 功能描述:  can总线数据接收\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-28 154449\n==================================================================================*/\nuint8_t can_pop_one_frame(void *ret_msg)\n{\n\t_pRet_Msg pmsg = ret_msg;\n\t\n\t//先查询长帧\n\tfor(int i=0; i<MAX_MUTIL_ITEM_NUM; i++)\t//从后往前查找可用的ID号\n\t{\n\t\tif(mMutil_Ring[i].is_complete == 0x01)\n\t\t{\n\t\t\tpmsg->ex_id.EX_ID = mMutil_Ring[i].ex_id.EX_ID;\n\t\t\tpmsg->byte_count = mMutil_Ring[i].r_len;\n\t\t\tmemcpy(pmsg->data, mMutil_Ring[i].r_data,  mMutil_Ring[i].r_len);\n\n\t\t\t//清空节点\n\t\t\tdelete_item_node(i);\n\t\t\treturn pmsg->byte_count;\n\t\t}\n\t}\n\t\n\t//查询短帧 \n\tif(\tmCan_Instance.p_ffunc->pop(mCan_Instance.Rcv_Fifo, ret_msg) != 0) \n\t{\n\t\t//查找成功\n\t\treturn pmsg->byte_count;\n\t}\n\t\n\treturn 0xFF;\n}\n\n/*==================================================================================\n* 函 数 名： can_sed_loop_check\n* 参    数： None\n* 功能描述:  CAN循环检测是否有发送的数据\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-28 171529\n==================================================================================*/\nvoid can_sed_loop_check(void)\n{\n\t_Can_Msg can_msg;\n\n\t//检查是否为空\n\tif(\tmCan_Instance.p_ffunc->pop(mCan_Instance.Sed_Fifo, &can_msg))\t//如果不为空\n\t{\n\t\t//屏蔽全局中断\n\t\t\n\t\t//获取数据\n//\t\tmCan_Instance.p_ffunc->pop(mCan_Instance.Sed_Fifo, &can_msg);\n\t\t//开启全局中断\n\n\t\t//发送数据\n\t\t can_sed_pkg_without_cache(&can_msg);\n\t}\n}\nextern _App_Param mApp_Param;\n/*==================================================================================\n* 函 数 名： can_sed_link_pkg\n* 参    数： None\n* 功能描述:  发送连包\n* 返 回 值： None\n* 备    注： \n* 作    者：  xiaozh\n* 创建时间： 2019-09-25 162917\n==================================================================================*/\nuint8_t can_sed_link_pkg(uint8_t host_cmd, uint8_t d_addr, uint8_t* buff, uint16_t len)\n{\n\t_Can_Msg c_msg;\n\tuint8_t count = 1;\n\tuint8_t pkg_step = 0;\n\tuint16_t s_len = len;\n\tuint16_t crc16_result = 0;\n\tuint8_t sed_buff[256] = {0};\n\t\n\tprintf(\"can_sed_link_pkg\\n\");\n\tif(s_len > 254*7)\n\t{\n//\t\tdebug_print(\"超过can总线最大发包能力\\n\");\n\t\treturn 0x81;\n\t}\n\t\n\t//当本节点没有分配CAN总线地址时候，只允许发送心跳命令\n\tif((mApp_Param.can_addr == CAN_ADDR_NULL)&&(host_cmd != get_hb_cmd))\t\t//空地址\n\t{\n\t\treturn 0x82;\t//当前节点地址为空\n\t}\n\t\n\tc_msg.ex_id.EX_ID = 0;\n\tc_msg.ex_id._bit.d_addr = d_addr;\t//目的地址\n\tc_msg.ex_id._bit.s_addr = MSELF_CAN_ADDR;\t//自己地址\n\tc_msg.ex_id._bit.png_cmd = host_cmd;\t\n\t\n\t//判断是否连包\n\tif(s_len <= 8)\n\t{\n\t\tc_msg.byte_count = s_len;\n\t\tmemset(c_msg.data, 0, 8);\n\t\tfor(int j=0; j<s_len; j++)\n\t\t{\n\t\t\tc_msg.data[j] = buff[j]; \n\t\t}\n\t\t\n\t\tmCan_Instance.p_ffunc->push(mCan_Instance.Sed_Fifo, &c_msg); \n\t}\n\telse\n\t{\n\t\tc_msg.ex_id._bit.is_sigle = 0x01;\t\t//连包数据\n\t\ts_len = len+2;\t//增加CRC16\n\t\t\n\t\tmemcpy(sed_buff, buff, len);\n\t\t\n\t\t//计算CRC16\n\t\tcrc16_result = crc16_ccitt(buff, len);\n\t\t\n\t\tsed_buff[len] = (uint8_t)((crc16_result>>0)&0x00FF); \n\t\tsed_buff[len+1] = (uint8_t)((crc16_result>>8)&0x00FF);\n\t  \n\t\twhile(s_len > 0)\n\t\t{\n\t\t\tcount = 0x01;\n\t\t\tc_msg.data[0] = pkg_step++;\n\n\t\t\t//判断是否为最后一帧数据\n\t\t\tif(s_len  <= 7)\n\t\t\t{\n\t\t\t\tc_msg.byte_count = s_len+1;\n\t\t\t\tc_msg.ex_id._bit.is_sigle = 0x02;\t\t//连包结尾数据\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc_msg.byte_count = 8; \n\t\t\t}\n\n\t\t\tfor(int j=0; j<c_msg.byte_count; j++)\n\t\t\t{\n\t\t\t\tc_msg.data[count++] = sed_buff[(pkg_step-1)*7+j];\n\t\t\t}\n\t\t\t\n\t\t\ts_len -= (c_msg.byte_count-1);\n\n\t\t\t//填充数据 \n\t\t\tmCan_Instance.p_ffunc->push(mCan_Instance.Sed_Fifo, &c_msg);\n\t\t}\n\t}\n\t \n\treturn 0;\n}\n\n\n",
			"file": "application/src/comm_can.c",
			"file_size": 9902,
			"file_write_time": 132478979152873468,
			"settings":
			{
				"buffer_size": 9183,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"contents": "#include \"adc_drv.h\"\n#include \"main.h\"\n\nextern ADC_HandleTypeDef hadc1;\n\n\ntypedef struct\n{\n\tuint8_t is_complete;\t\t//是否扫描完成  0：未完成   1：完成一次扫描\n\tuint32_t temp_adc_value;\t\t//温度adc值\n\tuint32_t ev_adc_value;\t\t\t//电流值\n\t\n\tuint32_t adc_buff[MAX_ACD_NUM];\t\t//最大采集缓存，两个通道，每个通道采集10次，求平均\n}_Adc_Info, *_pAdc_Info;\n\n \n_Adc_Info mAdc_Info = \n{\n\t.is_complete\t\t\t= 0,\n};\n\n \nvoid  HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//4\n{ \n\t//关闭中断\n\t HAL_ADC_Stop_DMA(hadc);\n\t\n\t mAdc_Info.is_complete = 0x01;\t//完成一次扫描\n}\n\n/*==================================================================================\n* 函 数 名： start_once_conv\n* 参    数： None\n* 功能描述:  使能数据采集\n* 返 回 值： None\n* 备    注： 100ms采集一次\n* 作    者： xiaozh\n* 创建时间： 2019-09-23 185058\n==================================================================================*/\nvoid start_once_conv(void)\n{ \n  HAL_ADC_Start_DMA(&hadc1, mAdc_Info.adc_buff, MAX_CONV_NUM);\n}\n\n/*==================================================================================\n* 函 数 名： adc_filter_conver\n* 参    数： None\n* 功能描述:  ADC滤波算法\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2017-2-20 \n==================================================================================*/\nuint16_t adc_filter_conver(uint16_t* AdcBuff,uint8_t Len)\n{\n\tuint8_t count,i,j;\n\tuint64_t  sum=0;\n\tuint16_t temp  = 0;\n\t\n   for (j=0;j<Len-1;j++)\n   {\n      for (i=0;i<Len-j;i++)\n      {\n         if (AdcBuff[i] < AdcBuff[i+1])\n         {\n            temp = AdcBuff[i];\n            AdcBuff[i] = AdcBuff[i+1]; \n             AdcBuff[i+1] = temp;\n         }\n      }\n   }\n\t \n   for(count=1;count<Len-1;count++)\n      sum += AdcBuff[count];\n\t \n   return (uint16_t)(sum/(Len-2));\n}\n\n/*==================================================================================\n* 函 数 名： adc_conver_refresh\n* 参    数： None\n* 功能描述:  ADC转换值更新\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-24 105740\n==================================================================================*/\nvoid adc_conver_refresh(void)\n{\n\tuint16_t temp_adc_buff[16] = {0};\n\tuint16_t ev_adc_buff[16] = {0};\n\t\n\tfor(int i=0,j=0; i<MAX_CONV_NUM/2; i++)\n\t{  \n\t\ttemp_adc_buff[i] = mAdc_Info.adc_buff[j++];\n\t\tev_adc_buff[i] = mAdc_Info.adc_buff[j++];\n\t}\n\t\n\t//软件滤波\n\tmAdc_Info.temp_adc_value = adc_filter_conver(temp_adc_buff, MAX_CONV_NUM/2);\n\tmAdc_Info.ev_adc_value = adc_filter_conver(ev_adc_buff, MAX_CONV_NUM/2);\n}\n \n/*==================================================================================\n* 函 数 名： adc_scan_loop_task\n* 参    数： None\n* 功能描述:  ADC采集更新\n* 返 回 值： None\n* 备    注： 间隔200ms扫描一次\n* 作    者： xiaozh\n* 创建时间： 2019-09-24 105740\n==================================================================================*/\nvoid adc_scan_loop_task(void* argv)\n{\n\t//如果完成一次扫描，则进行数据解析\n\tif(mAdc_Info.is_complete)\n\t{\n\t\tmAdc_Info.is_complete = 0;\n\t\t\n\t\t//进行数据转换\n\t\tadc_conver_refresh();\n\t}\n\telse\n\t{\n\t\t//开启一次ADC转换\n\t\tstart_once_conv();\n\t}\n}\n\n/*==================================================================================\n* 函 数 名： get_adc_temp\n* 参    数： None\n* 功能描述:  获取温度的ADC值\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-09-24 105740\n==================================================================================*/\nuint16_t get_adc_temp(void)\n{\n\treturn mAdc_Info.temp_adc_value;\n}\n\n/*==================================================================================\n* 函 数 名： get_adc_ev\n* 参    数： None\n* 功能描述:  获取电流的ADC值\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-09-24 105740\n==================================================================================*/\nuint16_t get_adc_ev(void)\n{\n\treturn mAdc_Info.ev_adc_value;\n}\n\n",
			"file": "hardware/src/adc_drv.c",
			"file_size": 3911,
			"file_write_time": 132478979135857129,
			"settings":
			{
				"buffer_size": 3626,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"contents": "#include \"gt32l_drv.h\"\n\n\n#define SPI_CS_HIGH()\t\t\tdo{HAL_GPIO_WritePin(GPIOB, CS_FLASH_Pin, GPIO_PIN_SET);}while(0)\n#define SPI_CS_LOW()\t\t\tdo{ HAL_GPIO_WritePin(GPIOB, CS_FLASH_Pin, GPIO_PIN_RESET);}while(0)\n\n\n/*==================================================================================\n* 函 数 名： spi1_sed_rev\n* 参    数： None\n* 功能描述:  SPI1接口发送数据\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-05 143321\n==================================================================================*/\nstatic uint8_t gt_sed_rev_byte( uint8_t value)\n{\n//\tSPI_TypeDef\t* pthis = SPI2;\n\tuint8_t ret = 0; \n\twhile((SPI2->SR & SPI_FLAG_TXE) == RESET);\t//等待发送缓冲区空\n\n\tSPI2->DR = value; \t//发送一个字节  \n\n\twhile((SPI2->SR & SPI_FLAG_RXNE) == RESET);\t //等待是否接收到一个字节  \n\t\n\tret = SPI2->DR; \t\t\t\t\t\t\t\t\t\t\t\t\t//获得该字节\n\t\n\treturn ret; //返回收到的字节\n}\n\n//---------私有函数\nunsigned char r_dat_bat(unsigned long address,unsigned long byte_long,unsigned char *p_arr)\n{\n\tunsigned long  i = 0;\n\tSPI_CS_LOW();\n\t\n\tgt_sed_rev_byte(READ_DATA_CMD);\t\n\t//发送地址\n//\tgt_sed_rev_byte(address>>24);\t\t\t\t//发送地址高8位\n\tgt_sed_rev_byte(address>>16);\t\t\t\t//发送地址\n\tgt_sed_rev_byte(address>>8);\t\t\t\t//发送地址\n\tgt_sed_rev_byte(address);\t\t\t\t\t\t//发送地址\n\t\n\t//发送数据\n\tfor(i=0; i<byte_long; i++)\n\t{\n\t\tp_arr[i] = gt_sed_rev_byte(0xFF);\n\t}\n\t\n\tSPI_CS_HIGH();\n\treturn p_arr[0]; \n}\n\n/*==================================================================================\n* 函 数 名： gt32l_execute_cmd\n* 参    数： None\n* 功能描述:  执行单条命令\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-12 121940\n==================================================================================*/\nuint8_t gt32l_execute_cmd(uint8_t cmd)\n{\n\tSPI_CS_LOW();\n\tgt_sed_rev_byte(cmd);\t\t\t//发送页写入指令\n\tSPI_CS_HIGH(); \n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： write_enable\n* 参    数： None\n* 功能描述:  写使能\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-12 121940\n==================================================================================*/\nuint8_t write_enable(void)\n{\n\tSPI_CS_LOW();\n\tgt_sed_rev_byte(0x06);\t\t\t//发送页写入指令\n\tSPI_CS_HIGH(); \n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： write_disable\n* 参    数： None\n* 功能描述:  写失能\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-12 121940\n==================================================================================*/\nuint8_t write_disable(void)\n{ \n\tSPI_CS_LOW();\n\tgt_sed_rev_byte(0x06);\t\t\t//发送页写入指令\n\tSPI_CS_HIGH(); \n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： gt32_read_status\n* 参    数： None\n* 功能描述:  读取芯片状态\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-12 122209\n==================================================================================*/\nuint8_t gt32_read_status(void)\n{\n\tuint8_t chip_status = 0;\n\t\n\tSPI_CS_LOW();\n\t\n\tgt_sed_rev_byte(READ_STATUS_CMD);\t\t\t//发送页写入指令\n\t\n\t//发送地址 \n\tchip_status = gt_sed_rev_byte(0xFF);\t\t\t\t//发送地址 \n\t\n\tSPI_CS_HIGH();\n\t\n\treturn chip_status;\n}\n  \n/*==================================================================================\n* 函 数 名： check_chip_status\n* 参    数： None\n* 功能描述:  检查芯片的状态\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-12 145307\n==================================================================================*/\nvoid check_chip_status(void)\n{\n\tuint8_t chip_status = 0;\n\tdo{\n\t\tchip_status = gt32_read_status();\n\t}while(chip_status&0x01);\n}\n\n/*==================================================================================\n* 函 数 名： page_program\n* 参    数： None\n* 功能描述:  写操作\n* 返 回 值： None\n* 备    注： 一次最大只能写入256个字节，不能执行跨页写操作\n* 作    者： xiaozh\n* 创建时间： 2019-11-12 122209\n==================================================================================*/\nuint8_t page_program(uint32_t address, uint8_t *buff, uint8_t length)\n{\n\tuint16_t i = 0;\n\n\t//使能写操作\n\twrite_enable();\n\t\n\tSPI_CS_LOW();\n\tgt_sed_rev_byte(0x02);\t\t\t//发送页写入指令\n\t\n\t//发送地址 \n\tgt_sed_rev_byte((uint8_t)((address>>16)&0x000000FF));\t\t\t\t//发送地址\n\tgt_sed_rev_byte((uint8_t)((address>>8)&0x000000FF));\t\t\t\t//发送地址\n\tgt_sed_rev_byte((uint8_t)((address>>0)&0x000000FF));\t\t\t\t\t\t//发送地址\n\t\n\t//发送数据\n\tfor(i=0; i<length; i++)\n\t{\n\t\tgt_sed_rev_byte(buff[i]);\n\t}\n\t\n\tSPI_CS_HIGH();\n\t\n\t//检查是否执行完成\n\tcheck_chip_status();\n\t\n\treturn 0x00; \n}\n\n/*==================================================================================\n* 函 数 名： sector_erase\n* 参    数： None\n* 功能描述:  芯片擦除\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-12 122209\n==================================================================================*/\nuint8_t gt32_sector_erase(uint32_t address)\n{\n\t//使能写操作\n\twrite_enable();\n\t\n\tSPI_CS_LOW(); \n\tgt_sed_rev_byte(0x20);\t\t\t//发送页写入指令\n\n\t//发送地址 \n\tgt_sed_rev_byte((uint8_t)((address>>16)&0x000000FF));\t\t\t\t//发送地址\n\tgt_sed_rev_byte((uint8_t)((address>>8)&0x000000FF));\t\t\t\t//发送地址\n\tgt_sed_rev_byte((uint8_t)((address>>0)&0x000000FF));\t\t\t\t\t\t//发送地址\n\t\n\tSPI_CS_HIGH();\n\t\n\t//检查是否执行完成\n\tcheck_chip_status();\n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： gt32_chip_read\n* 参    数： None\n* 功能描述:  芯片读取操作\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-12 122209\n==================================================================================*/\nuint8_t gt32_chip_read(uint32_t address, uint8_t* buff, uint32_t length)\n{\n\tr_dat_bat(address,  length, buff);\n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： gt32_chip_write\n* 参    数： None\n* 功能描述:  芯片写操作\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-12 122209\n==================================================================================*/\nuint8_t gt32_chip_write(uint32_t address, uint8_t* buff, uint32_t length)\n{\n\t\n//\twrite_enable();\n\tpage_program(address, buff, length);\n//\twrite_disable();\n\t\n\treturn 0;\n}\n \n\n\n#define  HZ_MODE00 0//竖置横排(Y)\n#define  HZ_MODE01 1//竖置竖排(Z)\n#define  HZ_MODE10 2//横置横排(W)\n#define  HZ_MODE11 3//横置竖排(X)\n\n#define  HZ_MODE4  4//Y-->W \n//条件putdata的数据写入X，Y的LCD显示缓冲RAM中\n\nvoid lcdram_map( uint8_t *getdate,uint8_t *putdata, uint8_t width, uint8_t high, uint8_t style )\n{\n  uint16_t i,j,hbyte,wbyte;\n  unsigned char i_8,j_8;\n  wbyte = (width+7)/8;\n  hbyte = (high+7)/8;\n   //--------------------------------------------------------------------------\n   // Y--> W; Y-->X; Y-->Z;\n   //--------------------------------------------------------------------------\n  if( style == HZ_MODE4 )\t//竖置横排 转 横置横排 ( Y-->W )\n  {\n\tfor( i = 0; i < high; i++ )\n\t\tfor( j = 0; j < width; j++ )\n\t\t{\n\t\t\ti_8 = i/8;\n\t\t\tif((*(putdata+i_8*width+j)&(0x01<<(i%8))) > 0)\n\t\t\t\tgetdate[wbyte*i+j/8] |= (0x80>>(j%8));\n\t\t\telse\n\t\t\t\tgetdate[wbyte*i+j/8] &= (~(0x80>>(j%8)));\n\t\t}\n  }\t\n   //--------------------------------------------------------------------------\n   // W--> Y;  W-->Z;W-->X;\n   //--------------------------------------------------------------------------\n  \n  if( style == HZ_MODE00 )\t//竖置横排 (W--> Y)\n  {\n\t  for( i = 0; i < high; i++ )\n\t\t  for( j = 0; j < width; j++ )\n\t\t  {\n\t\t\ti_8 = i/8;\n\t\t\tif((*(putdata+wbyte*i+j/8)&(0x80>>(j%8))) > 0)\n\t\t\t\tgetdate[i_8*width+j] |= (0x01<<(i%8));\n\t\t\telse\n\t\t\t\tgetdate[i_8*width+j] &= (~(0x01<<(i%8)));\n\t\t  }\n  }\n  else if(style == HZ_MODE01)\t//竖置竖排 (W-->Z)\n  {\n    for( i = 0; i < high; i++ )\n      for( j = 0; j < width; j++ )\n      {\n        if((*(putdata+wbyte*i+j/8)&(0x80>>(j%8))) > 0)\n\t\t\t\t\tgetdate[j*hbyte+i/8] |= (0x01<<(i%8));\n        else\n\t\t\t\t\tgetdate[j*hbyte+i/8]  &= (~(0x01<<(i%8)));\n      }\n  }\n  else if(style == HZ_MODE11)//横置竖排 (W-->X)\n  {\n    for( i = 0; i < high; i++ )\n      for( j = 0; j < width; j++ )\n      {\n        j_8 = j/8;\n        if((*(putdata+wbyte*i+j/8)&(0x80>>(j%8))) > 0)\n\t\t\t\t\tgetdate[j_8*high+i] |= (0x80>>(j%8));\n        else\n\t\t\t\t\tgetdate[j_8*high+i] &= (~(0x80>>(j%8)));\n      }\n  }\n  else if(style == HZ_MODE10)//横置横排 做镜像(W-->W')\n  {\n    for( i = 0; i < high; i++)\n      for( j = 0; j < width; j++)\n      {\n        if((*(putdata+wbyte*i+j/8)&(0x80>>(j%8)))>0 )\n\t\t\t\t\t*(getdate+wbyte*i+(width-j)/8) |=(0x80>>((width-j)%8));\n        else\n\t\t\t\t\t*(getdate+wbyte*i+(width-j)/8) &=~(0x80>>((width-j)%8));\n      }\n  }\n}\n\n//竖直竖排转横置横排 Z转W\nvoid Z2W(unsigned char* getData, unsigned char* putData, unsigned char width, unsigned char height) {\n\t\n\tunsigned char line, lie;\n\tunsigned int i=0, count=0, mark = 0;\t//i控制putData的下标, count控制getData的下标\n\t\n\tfor(line=0; line<height; line++) {\t//控制行\n\t\tfor(lie=0; lie<width; lie++) {\t//控制列\n\t\t\tgetData[count] = (unsigned char)(getData[count]<<0x01);\t//准备接收下一下\n\t\t\tif(putData[i]&(0x01<<(line%8))) \n\t\t\t\tgetData[count] += 1;\t//先取低位, 存新数组内\n\t\t\telse\n\t\t\t\tgetData[count] += 0;\n\t\t\ti += height>>3;\t//下一列\n\t\t\tif(lie%8 == 7) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(line%8 == 7) {\n\t\t\ti = ++mark;\n\t\t}else\n\t\t\ti = mark;\n\t}\n}\n\n//竖直竖排转竖置横排(Z->Y)\nvoid Z2Y(unsigned char* getData, unsigned char* putData, unsigned char width, unsigned char height) {\n\tunsigned char line=height>>3;\n\tunsigned int i=0, count=0, mark_count=0, sum = width*height>>3;\n\n\tfor(i=0;i<sum;i++) {\n\t\tgetData[count] = putData[i];\n\t\tcount += width;\n\t\tif( ((i+1)%line) == 0)\n\t\t\tcount = ++mark_count;\n\t}\n}\n\n//竖置横排转竖直竖排  Y转Z\nvoid Y2Z(unsigned char* getData, unsigned char* putData, unsigned char width, unsigned char height) {\n\tunsigned char line=height>>3;\n\tunsigned int i=0, count=0, mark_count=0, sum=width*height>>3;\n\t\n\tfor(i=0; i<sum; i++) {\n\t\tgetData[count] = putData[i];\n\t\tcount += line;\n\t\tif( ((i+1)%width) == 0 ) {\n\t\t\tcount = ++mark_count;\n\t\t}\n\t}\n}\n\n",
			"file": "hardware/src/gt32l_drv.c",
			"file_size": 10078,
			"file_write_time": 132478979135837379,
			"settings":
			{
				"buffer_size": 9447,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"contents": "#include \"oled_drv.h\"\n#include \"includes.h\"\n\nstatic _Screen_Info mScreen_Info[MAX_SCREEN_NUM];\n\nstatic _pSpi_Class pScreen_R =  &mSpi_Class[oled_1];\nstatic _pSpi_Class pScreen_L =  &mSpi_Class[oled_2];\n\n/*==================================================================================\n* 函 数 名： oled_write_byte\n* 参    数： screen: 0左屏， 1右屏\n*\t\t\t\t\t\tdat:要写入的数据/命令 \n*            cmd:数据/命令标志 0,表示命令;1,表示数据;\n* 功能描述:  向SSD1315写入一个字节\t\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2015.10\n==================================================================================*/\nvoid oled_write_byte(uint8_t screen,uint8_t value,uint8_t cmd_type)\n{\n\t_pSpi_Class pthis = NULL; \n\t\n  if(cmd_type)\n\t{ \n    OLED_DC_HIGH();\n\t}\n  else \n\t{\n\t\tOLED_DC_LOW();\n\t}\n  \n\tif(screen == SCREEN_LEFT)\n\t{ \n\t\tpthis = pScreen_L;\n\t\t\n\t}\n\telse if(screen == SCREEN_RIGHT)\n\t{ \n\t\tpthis = pScreen_R; \n\t}\n\telse\n\t{\n\t\treturn ;\n\t}\n\t\n\tpthis->cs_set(pthis->pContext, 0);\t//cs 0\n\tpthis->sed_rev_byte(pthis->pContext, value);\n\tpthis->cs_set(pthis->pContext, 1); //cs 1\n\t \n\tOLED_DC_HIGH();   \t  \n}\n \n /*==================================================================================\n* 函 数 名： screen_refresh\n* 参    数： 0\n* 功能描述:  屏幕刷新\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-19 171313\n==================================================================================*/\nvoid screen_refresh(uint8_t screen)\n{\n  uint16_t i,n;\t\t \n \t_pScreen_Info pthis = NULL;\n \n\tpthis = &mScreen_Info[screen]; \n\t  \n\t//刷新屏幕显示\n\tfor(i=0;i<DISP_HEIGHT;i++)  \n\t{  \n\t\toled_write_byte(screen, 0xb0+i, OLED_CMD);    //设置页地址（0~7）\n\t\toled_write_byte(screen, 0x00, OLED_CMD);      //设置显示位置―列低地址\n\t\toled_write_byte(screen, 0x10, OLED_CMD);      //设置显示位置―列高地址   \n\t\tfor(n=0;n<DISP_WIDTH;n++)\n\t\t{\n\t\t\toled_write_byte(screen,pthis->frame_buffer[n][i],OLED_DATA);\n\t\t} \n\t}\n}\n\n/*==================================================================================\n* 函 数 名： screen_clear\n* 参    数： None\n* 功能描述:  清屏\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-23 115439\n==================================================================================*/ \nvoid screen_clear(uint8_t screen, uint8_t color)\n{\n  uint16_t i,n;\n\t\n \t_pScreen_Info pthis = NULL;\n \n\tpthis = &mScreen_Info[screen]; \n\n\t//刷新屏幕显示\n\tfor(i=0;i<DISP_HEIGHT;i++)  \n\t{\n\t\tfor(n=0;n<DISP_WIDTH;n++)\n\t\t{\n\t\t\tpthis->frame_buffer[n][i] = ((color == BLACK)?(0x00):(0xFF));\n\t\t} \n\t}\n\t\n\tscreen_refresh(screen);\t\t//刷新屏幕\n}\n\n/*==================================================================================\n* 函 数 名： screen_refresh_all\n* 参    数： 0\n* 功能描述:  刷新所有屏幕显示\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-20 115958\n==================================================================================*/\nvoid screen_refresh_all(void)\n{\n\tscreen_refresh(SCREEN_LEFT);\n\tscreen_refresh(SCREEN_RIGHT);\n}\n\n /*==================================================================================\n* 函 数 名： screen_display_on\n* 参    数： 0\n* 功能描述:  开显示\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-20 121045\n==================================================================================*/\nvoid screen_display_on(uint8_t screen)\n{\n\toled_write_byte(screen,0X8D,OLED_CMD);  //SET DCDC命令\n\toled_write_byte(screen,0X14,OLED_CMD);  //DCDC ON\n\toled_write_byte(screen,0XAF,OLED_CMD);  //DISPLAY ON \n}\n\n /*==================================================================================\n* 函 数 名： screen_display_off\n* 参    数： 0\n* 功能描述:  关显示\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-20 121045\n==================================================================================*/\nvoid screen_display_off(uint8_t screen)\n{\n\t oled_write_byte(screen,0X8D,OLED_CMD);  //SET DCDC命令\n\t oled_write_byte(screen,0X10,OLED_CMD);  //DCDC OFF\n\t oled_write_byte(screen,0XAE,OLED_CMD);  //DISPLAY OFF\n}\n\n /*==================================================================================\n* 函 数 名： screen_set_pos\n* 参    数： 0\n* 功能描述:  设置屏幕显示位置\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-20 121045\n==================================================================================*/\nvoid screen_set_pos(uint8_t screen, uint8_t x, uint8_t y)\n{\n\t oled_write_byte(screen,0xb0+y,OLED_CMD);\n\t oled_write_byte(screen,((x&0xf0)>>4)|0x10,OLED_CMD);\n\t oled_write_byte(screen,(x&0x0f)|0x01,OLED_CMD); \n}\n\n /*==================================================================================\n* 函 数 名： screen_draw_point\n* 参    数： None\n* 功能描述:  打点函数\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-20 121045\n==================================================================================*/\nvoid screen_draw_point(uint8_t screen, uint8_t x, uint8_t y, uint8_t color)\n{\n\tuint8_t pos, bx, temp = 0;\n\t\n  if((x > (X_MAX_PIXEL-1)) || (y > (Y_MAX_PIXEL-1)))\n\t{\n\t\treturn ;\n\t}\n\t\n\tbx = y%8;\n\tpos\t = y/8;\n\ttemp = 1<<(bx);\n\t \n\tif(color)\n\t{\n\t\tmScreen_Info[screen].frame_buffer[x][pos] |= temp;\n\t}\n\telse\n\t{\n\t\tmScreen_Info[screen].frame_buffer[x][pos] &= ~temp;\n\t}\n\t \n//\tscreen_refresh_all(); //刷新显示\n}\n\n/*==================================================================================\n* 函 数 名： screen_show_char\n* 参    数： font_size:字体大小：14、 24、 32\n* 功能描述:  显示一个字符\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-20 121045\n==================================================================================*/\nvoid screen_show_char(uint8_t screen, uint8_t x, uint8_t y, uint8_t *c_buff, uint8_t c_size, uint8_t color)\n{\n\tc_size = 16;\n\tuint8_t temp = 0;\n\tuint8_t y0 = y;\n\tfor(int i=0; i<c_size; i++)\n\t{\n\t\ttemp = c_buff[i];\n\t\tfor(int j=0; j<8; j++)\n\t\t{\n\t\t\tif(temp & 0x80)\n\t\t\t{\n\t\t\t\tscreen_draw_point(screen, x, y, color);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tscreen_draw_point(screen, x, y, !color);\n\t\t\t}\n\t\t\t\n\t\t\ttemp <<= 1;\n\t\t\ty++;\n\t\t\tif((y-y0) == c_size)\n\t\t\t{\n\t\t\t\ty=y0;\n\t\t\t\tx++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*==================================================================================\n* 函 数 名： screen_show_char\n* 参    数： font_size:字体大小：14、 24、 32\n* 功能描述:  显示一个字符\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-20 121045\n==================================================================================*/\nvoid screen_show_bmp(uint8_t screen, uint8_t x_s, uint8_t y_s, uint8_t x_e, uint8_t y_e, uint8_t *c_buff, uint8_t color)\n{\n\tuint8_t x, y;\n\tuint16_t j = 0;\n \t_pScreen_Info pthis = NULL;\n\tpthis = &mScreen_Info[screen]; \n\t  \n\tfor(y=y_s; y<y_e; y++)\n\t{\n\t\tfor(x=x_s; x<x_e; x++)\n\t\t{\n\t\t\tpthis->frame_buffer[x][y] = c_buff[j++];\n\t\t}\n\t}\n\t\n\tscreen_refresh(screen);\t\t//刷新屏幕\n}\n \n\n/*横置横排打点函数 -----------------------------------------------------------------*/\nvoid WriteData(uint8_t screen, uint16_t Xpos, uint16_t Ypos, uint8_t data, uint16_t charColor, uint16_t bkColor,uint8_t sizeType)\n{\n\t\tuint16_t j,i;\n\t\tunsigned char count=0;\n\t\tfor( j=0; j<8; j++ )\n\t\t{\n\t\t\t\tif( ((data >> (7-j))&0x01)== 0x01 ){\n\t\t\t\t\t\tfor(count=0;count<sizeType;count++){\n\t\t\t\t\t\t\tfor(i=0;i<sizeType;i++){\n\t\t\t\t\t\t\t\tscreen_draw_point(screen, Xpos + sizeType*j+count, Ypos+i, charColor );\t//修改此函数\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\tfor(count=0;count<sizeType;count++){\n\t\t\t\t\t\t\tfor(i=0;i<sizeType;i++){\n\t\t\t\t\t\t\t\tscreen_draw_point(screen, Xpos + sizeType*j+count, Ypos+i, bkColor );\t//修改此函数\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}    \n\t\t\t\t}\n\t\t}\n}\n \n\n/********o横置横排显示函数************/\nvoid DisZK_DZ_W(uint8_t screen, uint16_t Xpos, uint16_t Ypos, uint16_t W,uint16_t H, uint16_t charColor, uint16_t bkColor,uint8_t*DZ_Data,uint8_t sizeType)\n{\n\tuint16_t Vertical,Horizontal;\n\tuint16_t n_Vertical = Vertical;\n\tuint32_t bit=0;\n\tVertical=Ypos;\n  Horizontal=Xpos; \n\tfor(bit=0;bit<((W+7)/8*H);bit++) //data sizeof (byte)\n\t{\n\t\t\tif((bit%((W+7)/8)==0)&&(bit>0))//W/8 sizeof\n\t\t\t{\n\t\t\t\tVertical+=sizeType;\n\t\t\t\tHorizontal+=sizeType*8; \n\t\t\t\tn_Vertical=Vertical;\t\t\t\n\t\t\t}\n\t\t\telse if(bit>0)\n\t\t\t{\n\t\t\t\tHorizontal=Xpos;\n\t\t\t\tn_Vertical=Vertical+sizeType;\n\t\t\t}\n\t\t\t\t\n\t\t\tWriteData(screen, Horizontal,n_Vertical,DZ_Data[bit],charColor,bkColor,sizeType);\n\t}\n}\n\n/*==================================================================================\n* 函 数 名： screen_show_string\n* 参    数： font_size:字体大小：14、 24、 32\n* 功能描述:  显示一个字符串\n* 返 回 值： None\n* 备    注： \n* 作    者：  \n* 创建时间： 2019-09-23 120610\n==================================================================================*/\nvoid screen_show_string(_pFont_Info pmsg)\n{\n\tgt_get_func p_func;\n\t\n\tuint8_t p_bits[512] = {0};\n\tuint8_t x = 0, y=0;\n\tuint8_t *p_str = pmsg->p_text;\n\tuint8_t ascii_size = 0, ascii_type = 0;\n\tuint8_t hz_size = 0;\n\t\n\tif(pmsg->p_text == NULL)\t\t//判读数据合法性\n\t{\n\t\treturn ;\n\t}\n\t\n\t//字体选择\n\tif(pmsg->font_size == FONT_16)\t\t//16号\n\t{ \n\t\thz_size = 16;\n\t\tascii_size = 16;\n\t\tascii_type = ASCII_16_A;\n\t\t\n\t\tp_func = gt_16_GetData;\t//汉字获取接口\n\t}\n\telse if(pmsg->font_size == FONT_24)\t\t//24号\n\t{\n\t\tascii_size = 24;\n\t\thz_size = 24;\n\t\tascii_type = ASCII_24_A;\n\t\t\n\t\tp_func = gt_24_GetData;\t//汉字获取接口\n\t}\n\telse if(pmsg->font_size == FONT_32)\t\t//32号\n\t{\n\t\tascii_size = 32;\n\t\thz_size = 32;\n\t\tascii_type = ASCII_32_A;\n\t\t\n\t\tp_func = gt_32_GetData;\t//汉字获取接口\n\t}\n\telse\n\t{\n\t\tascii_size = 16;\n\t\thz_size = 16;\n\t\tascii_type = ASCII_16_A;\n\t\tp_func = gt_16_GetData;\t//汉字获取接口\n\t}\n\t\n\tx = pmsg->x;\n\ty = pmsg->y;\n\t\n\t//显示\n\twhile(*p_str != '\\0')\t//判断结尾\n\t{\n\t\tif(*p_str < 0x80)\t//ASCII码\n\t\t{\n\t\t\tASCII_GetData(*p_str, ascii_type, p_bits);\t//示例, 按实际函数名进行修改, 每次读取第一个字节为0xFF\n\t\t\tDisZK_DZ_W(pmsg->screen, x, y,ascii_size,ascii_size,pmsg->font_color ,!pmsg->font_color ,p_bits,pmsg->font_scale);  //显示8X16点ASCII函数\n\t\t\tx=x+ascii_size*pmsg->font_scale;\n\t\t}\n\t\telse\n\t\t{//汉字编码*text是汉字编码的高位，*(text+1)是汉字编码的低位\n\t\t\tp_func(*p_str, *(p_str+1),0, 0, p_bits);\t//示例, 按实际函数名进行修改\n\t\t\tDisZK_DZ_W(pmsg->screen, x,y,hz_size,hz_size,pmsg->font_color, !pmsg->font_color ,p_bits,pmsg->font_scale);  //显示汉字\n\t\t\tx=x+hz_size*pmsg->font_scale;\n\t\t\tp_str++; \n\t\t}\n\t\t\n\t\tp_str++;\n\t}\n}\n   \n/*==================================================================================\n* 函 数 名： oled_init\n* 参    数： None\n* 功能描述:  OLED屏初始化\n* 返 回 值： None\n* 备    注： SSD1315\n* 作    者：  xiaozh\n* 创建时间： 2019-09-23 132006\n==================================================================================*/\nvoid oled_init(uint8_t screen)\n{\n\toled_write_byte(screen,0xAE,OLED_CMD);//--turn off oled panel\n\toled_write_byte(screen,0x00,OLED_CMD);//---set low column address\n\toled_write_byte(screen,0x10,OLED_CMD);//---set high column address\n\toled_write_byte(screen,0x40,OLED_CMD);//--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)\n\toled_write_byte(screen,0x81,OLED_CMD);//--set contrast control register\n\toled_write_byte(screen,0xCF,OLED_CMD); // Set SEG Output Current Brightness\n\toled_write_byte(screen,0xA1,OLED_CMD);//--Set SEG/Column Mapping     0xa0左右反置 0xa1正常\n\toled_write_byte(screen,0xC8,OLED_CMD);//Set COM/Row Scan Direction   0xc0上下反置 0xc8正常\n\toled_write_byte(screen,0xA6,OLED_CMD);//--set normal display\n\toled_write_byte(screen,0xA8,OLED_CMD);//--set multiplex ratio(1 to 64)\n\toled_write_byte(screen,0x3f,OLED_CMD);//--1/64 duty\n\toled_write_byte(screen,0xD3,OLED_CMD);//-set display offset\tShift Mapping RAM Counter (0x00~0x3F)\n\toled_write_byte(screen,0x00,OLED_CMD);//-not offset\n\toled_write_byte(screen,0xd5,OLED_CMD);//--set display clock divide ratio/oscillator frequency\n\toled_write_byte(screen,0x80,OLED_CMD);//--set divide ratio, Set Clock as 100 Frames/Sec\n\toled_write_byte(screen,0xD9,OLED_CMD);//--set pre-charge period\n\toled_write_byte(screen,0xF1,OLED_CMD);//Set Pre-Charge as 15 Clocks & Discharge as 1 Clock\n\toled_write_byte(screen,0xDA,OLED_CMD);//--set com pins hardware configuration\n\toled_write_byte(screen,0x12,OLED_CMD);\n\toled_write_byte(screen,0xDB,OLED_CMD);//--set vcomh\n\toled_write_byte(screen,0x40,OLED_CMD);//Set VCOM Deselect Level\n\toled_write_byte(screen,0x20,OLED_CMD);//-Set Page Addressing Mode (0x00/0x01/0x02)\n\toled_write_byte(screen,0x02,OLED_CMD);//\n\toled_write_byte(screen,0x8D,OLED_CMD);//--set Charge Pump enable/disable\n\toled_write_byte(screen,0x14,OLED_CMD);//--set(0x10) disable\n\toled_write_byte(screen,0xA4,OLED_CMD);// Disable Entire Display On (0xa4/0xa5)\n\toled_write_byte(screen,0xA6,OLED_CMD);// Disable Inverse Display On (0xa6/a7) \n\toled_write_byte(screen,0xAF,OLED_CMD);//--turn on oled panel\n\t\n\n\t//清屏\n\tscreen_clear(screen,BLACK); \t\n\tscreen_clear(screen,BLACK); \t\n}\n\n/*==================================================================================\n* 函 数 名： gt32l_init\n* 参    数： None\n* 功能描述:  字库芯片初始化\n* 返 回 值： None\n* 备    注： 默认上电读取一个，不然第一个自己会为0xFF\n* 作    者：  xiaozh\n* 创建时间： 2019-09-23 132006\n==================================================================================*/\nvoid gt32l_init(void)\n{\n\tuint8_t zk_buff[64] = {0};\n\tASCII_GetData('A',ASCII_16_A,zk_buff);\n}\n\n/*==================================================================================\n* 函 数 名： oled_init\n* 参    数： None\n* 功能描述:  OLED屏初始化\n* 返 回 值： None\n* 备    注： SSD1315\n* 作    者：  xiaozh\n* 创建时间： 2019-09-23 132006\n==================================================================================*/\nvoid oled_gt_init(void)\n{\n\t//GPIO初始化\n\tHAL_GPIO_WritePin(GPIOB, OLED_CS2_Pin|OLED_CS1_Pin|CS_FLASH_Pin, GPIO_PIN_SET);\t//失能片选\n\n\t//OLED使能\n//\tALL_RES_HIGH();\n\t\tHAL_GPIO_WritePin(GPIOB, OLED_RES1_Pin|OELD_RES2_Pin, GPIO_PIN_SET);\n\tHAL_Delay(100);\n\tHAL_GPIO_WritePin(GPIOB, OLED_RES1_Pin|OELD_RES2_Pin, GPIO_PIN_RESET);\n//\tALL_RES_LOW();\n\tHAL_Delay(200);\n//\tALL_RES_HIGH();\nHAL_GPIO_WritePin(GPIOB, OLED_RES1_Pin|OELD_RES2_Pin, GPIO_PIN_SET);\n\t\n\t//OLED初始化\n\toled_init(SCREEN_LEFT);\n\toled_init(SCREEN_RIGHT);\n\n\tHAL_GPIO_WritePin(GPIOB, OLED_DC_Pin|OLED_RES1_Pin|OELD_RES2_Pin|OLED_CS2_Pin \n\t\t\t\t\t\t\t\t\t\t\t\t|CS_FLASH_Pin|OLED_CS1_Pin, GPIO_PIN_SET);\n\t//字库芯片初始化\n//\tgt32l_init();\n}\n\n \nunsigned char BMP1[] =\n{\n\t0x00,0x03,0x05,0x09,0x11,0xFF,0x11,0x89,0x05,0xC3,0x00,0xE0,0x00,0xF0,0x00,0xF8,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x28,0xFF,0x11,0xAA,0x44,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x83,0x01,0x38,0x44,0x82,0x92,\n\t0x92,0x74,0x01,0x83,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x44,0xFF,0x01,0x7D,\n\t0x7D,0x7D,0x01,0x7D,0x7D,0x7D,0x7D,0x01,0x7D,0x7D,0x7D,0x7D,0x7D,0x01,0xFF,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,\n\t0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x3F,0x03,0x03,\n\t0xF3,0x13,0x11,0x11,0x11,0x11,0x11,0x11,0x01,0xF1,0x11,0x61,0x81,0x01,0x01,0x01,\n\t0x81,0x61,0x11,0xF1,0x01,0x01,0x01,0x01,0x41,0x41,0xF1,0x01,0x01,0x01,0x01,0x01,\n\t0xC1,0x21,0x11,0x11,0x11,0x11,0x21,0xC1,0x01,0x01,0x01,0x01,0x41,0x41,0xF1,0x01,\n\t0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x11,0x11,0x11,0x11,0x11,0xD3,0x33,\n\t0x03,0x03,0x3F,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xE0,0x00,0x00,\n\t0x7F,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x7F,0x00,0x00,0x01,0x06,0x18,0x06,\n\t0x01,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x40,0x40,0x7F,0x40,0x40,0x00,0x00,0x00,\n\t0x1F,0x20,0x40,0x40,0x40,0x40,0x20,0x1F,0x00,0x00,0x00,0x00,0x40,0x40,0x7F,0x40,\n\t0x40,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x40,0x30,0x0C,0x03,0x00,0x00,\n\t0x00,0x00,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x07,0x06,0x06,\n\t0x06,0x06,0x04,0x04,0x04,0x84,0x44,0x44,0x44,0x84,0x04,0x04,0x84,0x44,0x44,0x44,\n\t0x84,0x04,0x04,0x04,0x84,0xC4,0x04,0x04,0x04,0x04,0x84,0x44,0x44,0x44,0x84,0x04,\n\t0x04,0x04,0x04,0x04,0x84,0x44,0x44,0x44,0x84,0x04,0x04,0x04,0x04,0x04,0x84,0x44,\n\t0x44,0x44,0x84,0x04,0x04,0x84,0x44,0x44,0x44,0x84,0x04,0x04,0x04,0x04,0x06,0x06,\n\t0x06,0x06,0x07,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x10,0x18,0x14,0x12,0x11,0x00,0x00,0x0F,0x10,0x10,0x10,\n\t0x0F,0x00,0x00,0x00,0x10,0x1F,0x10,0x00,0x00,0x00,0x08,0x10,0x12,0x12,0x0D,0x00,\n\t0x00,0x18,0x00,0x00,0x0D,0x12,0x12,0x12,0x0D,0x00,0x00,0x18,0x00,0x00,0x10,0x18,\n\t0x14,0x12,0x11,0x00,0x00,0x10,0x18,0x14,0x12,0x11,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,\n\t0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x7F,0x03,0x0C,0x30,0x0C,0x03,0x7F,0x00,0x00,0x38,0x54,0x54,0x58,0x00,0x00,\n\t0x7C,0x04,0x04,0x78,0x00,0x00,0x3C,0x40,0x40,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xAA,0xAA,0xAA,\n\t0x28,0x08,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x03,0x0C,0x30,0x0C,0x03,0x7F,\n\t0x00,0x00,0x26,0x49,0x49,0x49,0x32,0x00,0x00,0x7F,0x02,0x04,0x08,0x10,0x7F,0x00,/********************************/\n};\n\n\nunsigned char BMP2[] =\n{\n\t0x00,0x03,0x05,0x09,0x11,0xFF,0x11,0x89,0x05,0xC3,0x00,0xE0,0x00,0xF0,0x00,0xF8,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x28,0xFF,0x11,0xAA,0x44,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x83,0x01,0x38,0x44,0x82,0x92,\n\t0x92,0x74,0x01,0x83,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x44,0xFF,0x01,0x7D,\n\t0x7D,0x7D,0x7D,0x01,0x7D,0x7D,0x7D,0x7D,0x01,0x7D,0x7D,0x7D,0x7D,0x01,0xFF,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,\n\t0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,\n\t0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0xF8,0x18,0x60,0x80,0x00,0x00,0x00,0x80,\n\t0x60,0x18,0xF8,0x00,0x00,0x00,0x20,0x20,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,\n\t0x10,0x08,0x08,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x20,0x20,0xF8,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x88,0x68,\n\t0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,\n\t0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x7F,0x00,0x00,0x01,0x06,0x18,0x06,0x01,\n\t0x00,0x00,0x7F,0x00,0x00,0x00,0x40,0x40,0x7F,0x40,0x40,0x00,0x00,0x00,0x00,0x1F,\n\t0x20,0x40,0x40,0x40,0x40,0x20,0x1F,0x00,0x00,0x00,0x40,0x40,0x7F,0x40,0x40,0x00,\n\t0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x18,0x06,0x01,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x40,0x20,0x20,0x20,0xC0,0x00,0x00,0xE0,0x20,0x20,0x20,\n\t0xE0,0x00,0x00,0x00,0x40,0xE0,0x00,0x00,0x00,0x00,0x60,0x20,0x20,0x20,0xE0,0x00,\n\t0x00,0x00,0x00,0x00,0xE0,0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00,0x00,0x40,0x20,\n\t0x20,0x20,0xC0,0x00,0x00,0x40,0x20,0x20,0x20,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x0C,0x0A,0x0A,0x09,0x0C,0x00,0x00,0x0F,0x08,0x08,0x08,\n\t0x0F,0x00,0x00,0x00,0x08,0x0F,0x08,0x00,0x00,0x00,0x0C,0x08,0x09,0x09,0x0E,0x00,\n\t0x00,0x0C,0x00,0x00,0x0F,0x09,0x09,0x09,0x0F,0x00,0x00,0x0C,0x00,0x00,0x0C,0x0A,\n\t0x0A,0x09,0x0C,0x00,0x00,0x0C,0x0A,0x0A,0x09,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,\n\t0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x7F,0x03,0x0C,0x30,0x0C,0x03,0x7F,0x00,0x00,0x38,0x54,0x54,0x58,0x00,0x00,\n\t0x7C,0x04,0x04,0x78,0x00,0x00,0x3C,0x40,0x40,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xAA,0xAA,0xAA,\n\t0x28,0x08,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x03,0x0C,0x30,0x0C,0x03,0x7F,\n\t0x00,0x00,0x26,0x49,0x49,0x49,0x32,0x00,0x00,0x7F,0x02,0x04,0x08,0x10,0x7F,0x00,/***************************************/\n\t\n};\n\n/*==================================================================================\n* 函 数 名： main_oled_test\n* 参    数： None\n* 功能描述:  OLED和字库测试函数\n* 返 回 值： None\n* 备    注： SSD1315\n* 作    者：  xiaozh\n* 创建时间： 2019-09-23 132006\n==================================================================================*/\nvoid main_oled_test()\n{\n\tunsigned char jtwb[128]=\"ABC寻缺另\";\t//每个中文字符实际由两个字节组成, 对应GBK等编码\n \n\toled_gt_init();\n\t\n\t_Font_Info mFont_Info = _FONT_INIT();\n\n\t//汉字显示测试\n\tmFont_Info.p_text = jtwb;\n\tscreen_show_string(&mFont_Info);\n\tmFont_Info.screen = SCREEN_RIGHT;\n\tscreen_show_string(&mFont_Info);\n\tscreen_refresh_all(); //刷新显示 \n\t\n\tHAL_Delay(1000);\n\t\n\t//图片显示测试\n\tscreen_show_bmp(SCREEN_RIGHT,0,0,128,8,BMP1,1);\n\tscreen_show_bmp(SCREEN_LEFT,0,0,128,8,BMP2,1);\n\t//\tscreen_show_bmp(0, )\n}\n\n\nextern _App_Param mApp_Param;\nvoid show_read_tag(uint8_t read_num, uint8_t real_num)\n{ \n\tuint8_t count_step = 0; \n\tunsigned char show_str[]=\"read:000\";\t//每个中文字符实际由两个字节组成, 对应GBK等编码\n\tunsigned char show_str_real[]=\"real:000\";\t//每个中文字符实际由两个字节组成, 对应GBK等编码\n  unsigned char show_can_addr[]=\"can:00\";\t// \n\t\n\t_Font_Info mFont_Info = _FONT_INIT();\n\t\n\tcount_step = sizeof(\"read:\")-1;\n\tshow_str[count_step++] = read_num/100+'0'; \n\tshow_str[count_step++] = read_num/10%10+'0';\n\tshow_str[count_step++] = read_num%10+'0';\n\t\n\tcount_step = sizeof(\"real:\")-1;\n\tshow_str_real[count_step++] = real_num/100+'0';\n\tshow_str_real[count_step++] = real_num/10%10+'0';\n\tshow_str_real[count_step++] = real_num%10+'0';\n\t \n\tcount_step = sizeof(\"can:\")-1; \n\tshow_can_addr[count_step++] = mApp_Param.can_addr/10%10+'0';\n\tshow_can_addr[count_step++] = mApp_Param.can_addr%10+'0';\n\t\n\t//汉字显示测试\n\tmFont_Info.p_text = show_str;\n\tscreen_show_string(&mFont_Info);\n\n\tmFont_Info.p_text = show_str_real;\n\tmFont_Info.screen = SCREEN_RIGHT;\n\tscreen_show_string(&mFont_Info);\n\t\n\tmFont_Info.y = 16;\n\tmFont_Info.p_text = show_can_addr;\n\tmFont_Info.screen = SCREEN_RIGHT;\n\tscreen_show_string(&mFont_Info);\n\t\n\tscreen_refresh_all(); //刷新显示 \n}\n",
			"file": "hardware/src/oled_drv.c",
			"file_size": 26956,
			"file_write_time": 132478979135896872,
			"settings":
			{
				"buffer_size": 26106,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"contents": "#include \"st_crc.h\"\n#include \"main.h\"\n\nCRC_HandleTypeDef hcrc;\n\n/*==================================================================================\n* 函 数 名： st_crc_init\n* 参    数： None\n* 功能描述:  st crc初始化\n* 返 回 值： none\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-10 182605\n==================================================================================*/ \nvoid st_crc_init(void)\n{\n\thcrc.Instance = CRC;\n  HAL_CRC_Init(&hcrc);\n}\n\n/*==================================================================================\n* 函 数 名： st_crc32\n* 参    数： None\n* 功能描述:  st crc校验\n* 返 回 值： none\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-10-16 162442\n==================================================================================*/ \nuint32_t st_crc32(uint8_t *buff, uint16_t len)\n{ \n\t//复位\n\tCRC->CR = CRC_CR_RESET;\n\t\n\tfor(int i=0; i<len; i++)\n\t{\n\t\tCRC->DR = buff[i];\n\t} \n\t\n\treturn (CRC->DR);\n}\n\n",
			"file": "hardware/src/st_crc.c",
			"file_size": 941,
			"file_write_time": 132478979135850296,
			"settings":
			{
				"buffer_size": 882,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"contents": "#ifndef  __OLED_DRV_H\n#define  __OLED_DRV_H\n#include \"spi_class.h\"\n\n#define MAX_SCREEN_NUM\t\t\t2\t\t\t//最大屏幕数量\n\n#define X_MAX_PIXEL\t\t\t\t\t128\t\t//最大像素点个数\n#define Y_MAX_PIXEL\t\t\t\t\t64\t\t//最大像素点个数\n\n#define DISP_WIDTH        128\n#define DISP_HEIGHT        8\n\ntypedef  enum\n{\n\tFONT_16 = 16,\t\t//16*16  16号字\n\tFONT_24 = 24,\t\t//24*24\t 24号字\n\tFONT_32 = 32,\t\t//32*32\t 32号字\n}_Font_Size;\n\ntypedef enum\n{\n\tSCREEN_LEFT = 0,\t\t//左屏\n\tSCREEN_RIGHT,\t\t\t\t//右屏\n}_Screen_Type;\n\ntypedef enum\n{\n\tBLACK = 0,\t\t//黑\n\tWHITE,\t\t\t\t//白\n}_Font_Color;\n\ntypedef struct\n{\n\tuint8_t type;\n\tuint8_t mode;\n\tuint8_t frame_buffer[DISP_WIDTH][DISP_HEIGHT];\n}_Screen_Info,*_pScreen_Info;\n\ntypedef struct\n{\n\tuint8_t x;\n\tuint8_t y;\n\t_Screen_Type screen;\t\t\t\t//屏幕\n\t_Font_Color  font_color;\t\t//字体颜色\n\t_Font_Size \t font_size;\t\t\t//字体大小 （16 24 32）\n\tuint8_t      font_scale; \t\t//字体转换比例系数，默认为1，不进行缩放\n\tuint8_t      *p_text;\t\t\t\t//要显示的字符串编码\n}_Font_Info, *_pFont_Info;\n\n#define  _FONT_INIT()  {0, 0, SCREEN_LEFT, WHITE, FONT_16, 1, NULL}\n\ntypedef  unsigned long  (*gt_get_func)(uint8_t , uint8_t, uint8_t, uint8_t, uint8_t*);\t//获取字库芯片数据\n\n\n#define OLED_CMD  \t\t\t\t0\t//写命令\n#define OLED_DATA \t\t\t\t1\t//写数据\n \n#define OLED_DC_LOW()\t \t\t\tdo{HAL_GPIO_WritePin(GPIOB, OLED_DC_Pin, GPIO_PIN_RESET);}while(0)\n#define OLED_DC_HIGH()  \t\tdo{HAL_GPIO_WritePin(GPIOB, OLED_DC_Pin, GPIO_PIN_SET);}while(0)\n\n#define ALL_RES_HIGH()\t\t\tdo{GPIOB->BSRR = OLED_RES1_Pin; GPIOB->BSRR = OELD_RES2_Pin;}while(0)\n#define ALL_RES_LOW()\t\t\t\tdo{GPIOB->BSRR = (uint32_t)OLED_RES1_Pin << 16u; GPIOB->BSRR = (uint32_t)OELD_RES2_Pin << 16u;}while(0)\n\t\nvoid oled_gt_init(void);\n\n#endif\n",
			"file": "hardware/inc/oled_drv.h",
			"file_size": 1657,
			"file_write_time": 132478979209812180,
			"settings":
			{
				"buffer_size": 1572,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"contents": "#include \"application.h\"\n#include \"includes.h\"\n\n\n_App_Param mApp_Param= \n{\n\t.sys_init_complete = 0,\t//系统初始化标志，没有初始化完成，不允许执行中断\n\t.can_addr \t\t= 2,\t\t\t//空地址\n};\n\n/*==================================================================================\n* 函 数 名： systerm_init\n* 参    数： None\n* 功能描述:  系统初始化\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-24 111301\n==================================================================================*/\nvoid systerm_init(void)\n{\n//中断向量表初始化\n#if  EN_DEBUG\n\tSCB->VTOR = FLASH_BASE | 0X10000; /* Vector Table Relocation in Internal FLASH. */\n#else\n\n#endif\n\t\n\tHAL_Init();\n\n\t__disable_irq();   // 关闭总中断\n\n\t//读取配置参数\n\tread_config_param(&mApp_Param);\n\t\n\t//系统板级初始化\n\tbsp_init(mApp_Param.can_addr);\n\tst_crc_init(); \n\t\n\t//can协议初始化\n\tcan_instance_init();\n\t\n\t//外设初始化\n\tinter_init();\n\t\n\t//使能外部中断\n\t__enable_irq();    // 开启总中断\n\t\n\t//初始化OLED, 字库\n\toled_gt_init();\n\n\t//读卡器初始化\n//\trfid_st25_init();\n\t\n\t//开启任务\n\tEnableTask(TASK_RFID_READ);\n\n\t//系统初始化完成\n\tmApp_Param.sys_init_complete = 0x01;\n\tprintf(\"slave box init complete\\n\");\n\t\n\t//运行系统中断\n\tHAL_Delay(100+((mApp_Param.can_addr<10)?(mApp_Param.can_addr*10):(100)));\n\t\n\t//使能中断\n\tsysterm_init_complete();\n\n\tprintf(\"can addr = %d\\n\", mApp_Param.can_addr);\n}\n\n/*==================================================================================\n* 函 数 名： HAL_SysTick_Callback\n* 参    数： None\n* 功能描述:  系统滴答回调\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-06 115746\n==================================================================================*/\nvoid HAL_SysTick_Callback(void)\n{\n\t//标记任务\n\tTaskRemarks();\n}\n\n/*==================================================================================\n* 函 数 名： app_dispatch\n* 参    数： None\n* 功能描述:  系统任务调度\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-06 115746\n==================================================================================*/\nvoid app_dispatch(void)\n{\n\t//定时任务查询\n\tTaskProcess(0);\n\t\n\t//协议解析\n\tcan_rev_decode();\n}\n \n/*==================================================================================\n* 函 数 名： test_loop_task\n* 参    数： None\n* 功能描述:  测试任务\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-29 170658\n==================================================================================*/\nvoid test_loop_task(void* argv)\n{\n\tstatic uint32_t frame_step = 0;\n\tstatic uint8_t count_step = 0;\n\tuint8_t s_count = 0;\n//  test_send();\n\tuint8_t sed_buff[255] = {0};\n\tfor(int i=0;i<sizeof(sed_buff); i++)\n\t{\n\t\tsed_buff[i] = i;\n\t}\n\t\n\tframe_step++;\n\tsed_buff[s_count++] = frame_step>>24;\n\tsed_buff[s_count++] = frame_step>>16;\n\tsed_buff[s_count++] = frame_step>>8;\n\tsed_buff[s_count++] = frame_step>>0;\n\n\tcan_sed_link_pkg(0x03, 0xAE,  sed_buff,  count_step++);\n}\n\n\n",
			"file": "application/src/application.c",
			"file_size": 2954,
			"file_write_time": 132478979152888150,
			"settings":
			{
				"buffer_size": 2710,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"contents": "#include \"mini_dispatch.h\"\n \n\nextern void can_sed_loop_task(void* argv); \nextern void can_rev_loop_task(void* argv); \nextern void adc_scan_loop_task(void* argv);\t\t//低优先级任务\nextern void  rfid_loop_read_task(void *argv); \t//读卡\nextern void test_loop_task(void* argv);\nextern void loop_sed_new_tag_info(void* argv);\n\n/*==================================================================================\n* 函 数 名： TaskComps\n* 参    数： None\n* 功能描述:  任务表\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2017-7-28 15:12:42\n==================================================================================*/\nTASK_COMPONENTS TaskComps[] = \n{\n\t{0, TASK_ENABLE, 10, 10, can_sed_loop_task},            \t//优先级 1\n\t{0, TASK_ENABLE, 30, 30, loop_sed_new_tag_info},            \t//优先级 2\n\t{0, TASK_DISABLE, 100, 100, rfid_loop_read_task},            \t//优先级 3\n\t{0, TASK_ENABLE, 1000, 1000, adc_scan_loop_task},            \t//优先级 4\n\t{0, TASK_DISABLE, 300, 300, test_loop_task},            \t//循环测试任务\n};\n\n/*==================================================================================\n* 函 数 名： EnableTask\n* 参    数： None\n* 功能描述:  使能任务\n* 返 回 值： None\n* 备    注： 0:没有使能  1：使能   0xff:未知通道\n* 作    者： xiaozh\n* 创建时间： 2017-7-28 15:12:42\n==================================================================================*/\nuint8_t IsTaskEnable(TASK_LIST Task)\n{\n\tif(Task > TASKS_MAX)\n\t\treturn 0xff;\n\t\n\tif(TaskComps[Task].RunState == TASK_ENABLE)\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n}\n\n/*==================================================================================\n* 函 数 名： TaskRefresh\n* 参    数： None\n* 功能描述:  刷新更新时间\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2017-7-28 15:12:42\n==================================================================================*/\nvoid TaskRefresh(TASK_LIST Task)\n{\n \tif(Task > TASKS_MAX)\n\t\treturn;\n\t\n\tTaskComps[Task].Timer = TaskComps[Task].ItvTime; \n}\n\n/*==================================================================================\n* 函 数 名： EnableTask\n* 参    数： None\n* 功能描述:  使能任务\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2017-7-28 15:12:42\n==================================================================================*/\nvoid EnableTask(TASK_LIST Task)\n{\n\tif(Task > TASKS_MAX)\n\t\treturn;\n\t\n//\tTaskComps[Task].Timer = TaskComps[Task].ItvTime;\n\tTaskComps[Task].RunState = TASK_ENABLE;\n}\n\n/*==================================================================================\n* 函 数 名： DisableTask\n* 参    数： None\n* 功能描述:  失能任务\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2017-7-28 15:12:42\n==================================================================================*/\nvoid DisableTask(TASK_LIST Task)\n{\n\tif(Task > TASKS_MAX)\n\t\treturn;\n\n\tTaskComps[Task].Timer = TaskComps[Task].ItvTime;\n\tTaskComps[Task].RunState = TASK_DISABLE;\n}\n\n/*==================================================================================\n* 函 数 名： TaskSetTimes\n* 参    数： None\n* 功能描述:  任务标志标记函数\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2017-7-28 15:12:42\n==================================================================================*/\nvoid TaskSetTimes(TASK_LIST Task , uint32_t Times)\n{\n\tif(Task > TASKS_MAX)\n\t\treturn;\n\t\n\tTaskComps[Task].Timer = Times;\n\tTaskComps[Task].RunState = TASK_ENABLE;\n}\n\n/*==================================================================================\n* 函 数 名： TaskRemarks\n* 参    数： None\n* 功能描述:  任务标志标记函数\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2017-7-28 15:12:42\n==================================================================================*/\nvoid TaskRemarks(void)\n{\n\tuint8_t i = 0;\n\tfor (i=0; i<TASKS_MAX; i++)          // 逐个任务时间处理\n\t{\n\t\tif(TaskComps[i].RunState == TASK_ENABLE)\t\t//如果使能了当前任务检测，则进行检测操作\n\t\t{\n\t\t\tif (TaskComps[i].Timer)          // 时间不为0\n\t\t\t{\n\t\t\t\tTaskComps[i].Timer--;         // 减去一个节拍\n\t\t\t\tif (TaskComps[i].Timer == 0)       // 时间减完了\n\t\t\t\t{\n\t\t\t\t\t TaskComps[i].Timer = TaskComps[i].ItvTime;       // 恢复计时器值，从新下一次\n\t\t\t\t\t TaskComps[i].Run = 1;           // 任务可以运行\n\t\t\t\t}\n\t\t\t}\n\t\t}\n  }\n}\n \n/*==================================================================================\n* 函 数 名： TaskRemarks\n* 参    数： None\n* 功能描述:  任务处理\n* 返 回 值： None\n* 备    注： 建议在中循环中调用，在定时中断中调用注意操作时间\n* 作    者： xiaozh\n* 创建时间： 2017-7-28 15:12:42\n==================================================================================*/\nvoid TaskProcess(void *who)\n{\n\tuint8_t i;\n\tfor (i=0; i<TASKS_MAX; i++)           // 逐个任务时间处理\n\t{\n\t\tif (TaskComps[i].Run)           // 时间不为0\n\t\t{\n\t\t\t TaskComps[i].TaskHook(who);         // 运行任务\n\t\t\t TaskComps[i].Run = 0;          // 标志清0\n\t\t\t //return ;  //每次循环只执行一个任务\n\t\t}\n\t}\n}\n\n",
			"file": "event_manage/src/mini_dispatch.c",
			"file_size": 4970,
			"file_write_time": 132479099273009606,
			"settings":
			{
				"buffer_size": 4570,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"contents": "#include \"can_def_fifo.h\"\n\n\n#define func_name   can_xjy\n\n//申请结构 \nDEF_SAFE_FIFO(can_xjy, _Can_Item, uint16_t, uint8_t)     \nDEF_SAFE_FIFO_END\n\n\nstatic _Can_Fifo_Func mCan_Fifo_Func = \n{\n\t.init_s\t\t\t\t\t\t=  \tFIFO_INIT_S_X(can_xjy),\n\t.init_m\t\t\t\t\t\t=  \tFIFO_INIT_M_X(can_xjy),\n\t.is_empty \t\t\t\t= \tFIFO_IS_EMPTY_X(can_xjy),\n\t.push\t \t\t\t\t\t\t= \tFIFO_PUSH_X(can_xjy),\n\t.pop \t\t\t\t\t\t\t= \tFIFO_POP_X(can_xjy),\n};\n\nconst _pCan_Fifo_Func pCan_Fifo_Func = &mCan_Fifo_Func;\n\n\n",
			"file": "event_manage/src/can_def_fifo.c",
			"file_size": 455,
			"file_write_time": 132478979152833858,
			"settings":
			{
				"buffer_size": 451,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"contents": "#include \"debug_task.h\"\n#include \"main.h\"\n#include \"def_fifo.h\"\n\n\nDEF_SAFE_FIFO_U8(cmd_fifo, uint16_t, uint8_t)\n\n\n \nstatic _cmd_cache mCmd_Cache = \n{\n\t.is_value\t\t\t\t= 0,\t//是否接收有效命令\n\t.rev_count\t\t\t= 0,\n\t.r_point\t\t\t\t= 0,\n};\n\n//命令格式  [命令字符串]空格[参数1]空格[参数2]空格[...]\\r\\n \n\nstatic void DEF_NAME_FUNC(help)(void *argv);\nstatic void DEF_NAME_FUNC(shell)(void *argv);\n\n_cmd_list  mCmd_List_Table[] = \n{\n\tCMD_FUNC_DEF(help),\n\tCMD_FUNC_DEF(shell),\n};\n\n//help\nstatic void DEF_NAME_FUNC(help)(void *argv)\n{\n\tprintf(\"cmd frame: [命令字符串] [参数1] [参数2] ...\\n\");\n}\n//entyr shell\nstatic void DEF_NAME_FUNC(shell)(void *argv)\n{\n\tprintf(\"cmd frame: [命令字符串] [参数1] [参数2] ...\\n\");\n}\n\n/*==================================================================================\n* 函 数 名： push_cmd_cache\n* 参    数： None\n* 功能描述:  把接收到的命令字符放到缓存\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-11-12 172859\n==================================================================================*/\nvoid push_cmd_cache(uint8_t ch)\n{\n\tif(ch == '\\r')\n\t{\n\t\tmCmd_Cache.is_value  = 0x01;\t\t//接到的完整命令\n\t}\n\t\n\tmCmd_Cache.rev_buff[mCmd_Cache.r_point++] = ch;\n\tmCmd_Cache.rev_count++;\n\tmCmd_Cache.is_value++;\n}\n\n/*==================================================================================\n* 函 数 名： execute_cmd\n* 参    数： None\n* 功能描述:  命令处理\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-11-12 172859\n==================================================================================*/\nstatic void execute_cmd(const char *cmd_buf, uint16_t len)\n{\n\n}\n\n/*==================================================================================\n* 函 数 名： cmd_string_handle\n* 参    数： None\n* 功能描述:  字符串命令处理\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-11-12 172859\n==================================================================================*/ \np_func find_func(char *cmd_str)\n{ \n\tfor(int i=0; i<  MAX_NUM(mCmd_List_Table); i++)\n\t{ \n\t\tprintf(\"cmd = %s\\n\", mCmd_List_Table[i].cmd_name);\n\t}\n\t\n\treturn 0;\n}\n\n\n/*==================================================================================\n* 函 数 名： cmd_handle_func_task\n* 参    数： None\n* 功能描述:  字符串命令处理\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-11-12 172859\n==================================================================================*/ \nvoid cmd_handle_func_task(void)\n{\n\tp_func pfunc = 0;\n\tchar cmd_str[16] = {0};\n\tuint8_t param_tab[8] = {0};\n\tuint8_t *p = 0;\n\tuint8_t point = 0;\n\t\n\tif(!mCmd_Cache.is_value)\n\t{\n\t\treturn ;\n\t}\n\t\n\t//进行命令解析\n\tdo{\n\t\t\n\t\t//获取命令\n\t\tdo{cmd_str[point++] =  mCmd_Cache.rev_buff[mCmd_Cache.r_point++]; mCmd_Cache.rev_count--;}while(cmd_str[point-1] != '\\r');\n\t\t\n\t\t//查找函数\n\t\tpfunc = find_func(cmd_str);\n\t\t\n\t\t//执行命令\n\t\tpfunc(param_tab);\n\t\t\n\t\t//修正参数\n\t\t(mCmd_Cache.is_value>0)?(mCmd_Cache.is_value--):(mCmd_Cache.is_value=0);\n\t}while(mCmd_Cache.is_value);\n\t\n\t//清空缓存\n\tmCmd_Cache.rev_count = 0;\n\tmCmd_Cache.r_point = 0;\n\t \n}\n\n",
			"file": "event_manage/src/debug_task.c",
			"file_size": 3099,
			"file_write_time": 132478979152822563,
			"settings":
			{
				"buffer_size": 2886,
				"line_ending": "Unix",
				"scratch": true
			}
		},
		{
			"contents": "#ifndef  __MINI_DISPATCH_H\n#define  __MINI_DISPATCH_H\n#include <stdint.h>\n\n\ntypedef enum \n{\n\tTASK_ENABLE=1,\n\tTASK_DISABLE\n}TASK_STA;\n\n// 任务结构\ntypedef struct _TASK_COMPONENTS\n{\n\tuint8_t \t\tRun;                 \t\t//程序运行标记：0-不运行，1运行\n\tTASK_STA\t\tRunState;\t\t\t\t\t\t\t\t//运行状态，TASK_ENABLE：使能检测    TASK_DISABLE：不进行检测\n\t//\t\tuint16_t    Priority;\t\t\t\t\t\t\t\t//优先级\n\tuint32_t \t\tTimer;              \t\t//计时器\n\tuint32_t \t\tItvTime;              \t//任务运行间隔时间，下一次填充时间\n\tvoid (*TaskHook)(void*);    \t\t// 要运行的任务函数\n} TASK_COMPONENTS;       \t\t\t\t\t// 任务定义\n\n\n// 任务清单\ntypedef enum _TASK_LIST\n{ \n\tTASK_CAN_SED = 0,\t\t\t\t\t\t\t\t//CAN发送数据\n\tTASK_SED_TAG_INFO,\t\t\t\t\t\t\t//发送卡片信息\n\tTASK_RFID_READ,\t\t\t\t\t\t\t//rfid读卡\n\tTASK_ADC_CONV,\t\t\t\t\t\t\t//ADC转换\n\t\n\tTASK_TEST_LOOP,\t\t\t\t\t\t\t//循环测试任务\n\tTASKS_MAX                     // 总的可供分配的定时任务数目\n} TASK_LIST;\n\nvoid TaskSetTimes(TASK_LIST Task , uint32_t Times);\nvoid TaskRefresh(TASK_LIST Task);\nuint8_t IsTaskEnable(TASK_LIST Task);\nvoid EnableTask(TASK_LIST Task);\nvoid DisableTask(TASK_LIST Task);\nvoid TaskRemarks(void);\nvoid TaskProcess(void*);\n#endif\n",
			"file": "event_manage/inc/mini_dispatch.h",
			"file_size": 1135,
			"file_write_time": 132478979226621078,
			"settings":
			{
				"buffer_size": 1031,
				"line_ending": "Unix",
				"scratch": true
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"co",
				"ConvertToUTF8: Reload with Encoding"
			],
			[
				"raw",
				"Raw Line Edit: View Line Endings"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"RawL",
				"Package Control: Upgrade/Overwrite All Packages"
			],
			[
				"Packages Control",
				"Package Control: Satisfy Dependencies"
			],
			[
				"wor",
				"WordHighlight: Toggle Enabled"
			],
			[
				"i",
				"Package Control: Install Package"
			],
			[
				"word",
				"Word Wrap: Toggle"
			],
			[
				"",
				"About"
			],
			[
				"INSTA",
				"Package Control: Install Package"
			],
			[
				"CO",
				"ConvertToUTF8: Reload with Encoding"
			],
			[
				"INSTALL PACKAGE",
				"Package Control: Install Package"
			],
			[
				"COV",
				"ConvertToUTF8: Reload with Encoding"
			],
			[
				"CONVER",
				"ConvertToUTF8: Reload with Encoding"
			],
			[
				"inst",
				"Package Control: Install Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 178.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '7183a2d3e96f11eeadd761d777e62404' + 'e330c659d4bb41d3bdf022e94cab3cd0'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)",
			"import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())",
			"import urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) "
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/application",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/application/src",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/device_lib",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/event_manage",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/hardware",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/hardware/inc",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/hardware/src",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/iap_boot",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/Inc",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/MDK-ARM",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/Src"
	],
	"file_history":
	[
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/device_lib/ST_RFID/common/utils/Src/stream_dispatcher.c",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/hardware/src/can_drv.c",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_can.c",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/Src/stm32f1xx_hal_msp.c",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim.c",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_tim.h",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/hardware/inc/ex_device.h",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio.c",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/Inc/main.h",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/hardware/src/adc_drv.c",
		"/Users/jack/Desktop/meican/W2项目资料/CAN_BOX/event_manage/src/mini_dispatch.c",
		"/Users/jack/Library/Application Support/Sublime Text 3/Packages/ConvertToUTF8/ConvertToUTF8.sublime-settings",
		"/Users/jack/Desktop/meican/W2_CC_BOARD/Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_rcc.h",
		"/Users/jack/Desktop/meican/W2_CC_BOARD/Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal.c",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN_V2/Application/inc/application.h",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN_V2/Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_can.c",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN_V2/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f105xc.h",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN_V2/Application/src/application.c",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN_V2/Application/src/comm_can.c",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN_V2/event_manage/src/serial_def_fifo.c",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN_V2/event_manage/inc/def_fifo.h",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN_V2/Hardware/src/bsp_init.c",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN/Hardware/src/load_gpio.c",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN/Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_can.h",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN/Drivers/STM32F1xx_HAL_Driver/Inc/Legacy/stm32f1xx_hal_can_legacy.h",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN/Hardware/inc/can_drv.h",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN/event_manage/src/serial_def_fifo.c",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN/Hardware/src/bsp_init.c",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN/Hardware/src/bsb_init.c",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103x6.h",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f105xc.h",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN/Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_can.c",
		"/Users/jack/Desktop/meican/smartTableAFE_APP/HARDWARE/ISO15693_rec.c",
		"/Users/jack/Desktop/meican/smartTableAFE_APP/HARDWARE/ISO15693_cmd.h",
		"/Users/jack/Desktop/meican/smartTableAFE_APP/HARDWARE/bsp_data.c",
		"/Users/jack/Desktop/meican/smartTableAFE_APP/USER/main.c",
		"/Users/jack/Desktop/meican/smartTableAFE_APP/HARDWARE/bsp_spi.c",
		"/Users/jack/Desktop/meican/smartTableAFE_APP/HARDWARE/bsp_timer.c",
		"/Users/jack/Desktop/meican/smartTableAFE_APP/OBJ/main.crf",
		"/Users/jack/Desktop/meican/smartTableAFE_APP/USER/samrtTableAFE_APP.uvprojx",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN/Application/inc/comm_can.h",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN/event_manage/src/uart_debug.c",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN/event_manage/src/si_fifo.c",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN/event_manage/src/si_def_fifo.c",
		"/Users/jack/Desktop/meican/W2项目资料/RADIO_CAN/event_manage/src/mini_dispatch.c",
		"/Users/jack/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/0f0049b9a43e45e6cdfd390cba50c73b/Message/MessageTemp/9e20f478899dc29eb19741386f9343c8/File/can/can_receive.c",
		"/Users/jack/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/0f0049b9a43e45e6cdfd390cba50c73b/Message/MessageTemp/9a779848f5caeb4e49b6db7f44fc065a/File/CanSocket.cpp",
		"/Users/jack/Desktop/meican/Writer/Writer/APP/Test/Test.c",
		"/Users/jack/Downloads/灰太狼暂定升级协议初级版20200720-V6.0 - APP -测试总线成功升级成功升级成功报警关掉AD总线中断最高升级更改goto/灰太狼/W2E/Lock_Control/app/STM32F10x_FWLib/inc/stm32f10x_flash.h",
		"/Users/jack/Desktop/meican/W2E/Lock_Control/common/IAP_Utility/IAP_Core.h",
		"/Users/jack/Desktop/meican/W2E/Lock_Control/app/USER/main.c",
		"/Users/jack/Desktop/meican/W2E/Lock_Control/app/HARDWARE/bsp_uart.h",
		"/Users/jack/Desktop/meican/W2E/Lock_Control/app/CORE/core_cm0.h",
		"/Users/jack/Desktop/meican/Writer/Writer/HARDWARE/ST7789V/ST7789V.h",
		"/Users/jack/Desktop/meican/Writer/Writer/SYSTEM/UserData/UserData.h",
		"/Users/jack/Desktop/meican/Writer/Writer/SYSTEM/UserData/UserData.c",
		"/Users/jack/Desktop/meican/Writer/Writer/HARDWARE/IFLASH/IFLASH.c",
		"/Users/jack/Desktop/meican/Writer/Writer/SYSTEM/QRCode/QRCode.c",
		"/Users/jack/Desktop/meican/Writer/Writer/APP/UI/UI.h",
		"/Users/jack/Desktop/meican/Writer/Writer/HARDWARE/CY8CMBR3XXX/API/CY8CMBR3xxx.c",
		"/Users/jack/Desktop/meican/Writer/Writer/HARDWARE/GT32L32/GT32L32.c",
		"/Users/jack/Desktop/meican/Writer/Writer/HARDWARE/GT32L32/GT32L32S0140.h",
		"/Users/jack/Desktop/meican/Writer/Writer/OBJ/SPI.map",
		"/Users/jack/Desktop/meican/Writer/Writer/APP/UI/UIResource.h",
		"/Users/jack/Desktop/meican/Writer/Writer/HARDWARE/IFLASH/IFLASH.h",
		"/Users/jack/Desktop/meican/Writer/Writer/APP/UI/untitled.cpp",
		"/Users/jack/Desktop/meican/Writer/Writer/APP/Menu/Menu.h",
		"/Users/jack/Desktop/meican/Writer/Writer/SYSTEM/Touch/Touch.h",
		"/Users/jack/Desktop/meican/Writer/Writer/HARDWARE/GT32L32/GT32L32.h",
		"/Users/jack/Desktop/meican/Writer/Writer/APP/Menu/Menu.c",
		"/Users/jack/Desktop/meican/Writer/Writer/SYSTEM/Protocol/Protocol.c",
		"/Users/jack/Desktop/meican/Writer/Writer/HARDWARE/CY8CMBR3XXX/API/CY8CMBR3xxx.h",
		"/Users/jack/Desktop/meican/Writer/Writer/common/STM32/Src/timer.c",
		"/Users/jack/Desktop/meican/Writer/Writer/SYSTEM/Touch/Touch.c",
		"/Users/jack/Desktop/meican/Writer/Writer/USER/main.c",
		"/Users/jack/Desktop/meican/Writer/Writer/HARDWARE/ST25R3911/Inc/platform.h",
		"/Users/jack/Desktop/meican/Writer/Writer/APP/UI/UI.c",
		"/Users/jack/Desktop/meican/Writer/Writer/HARDWARE/CY8CMBR3XXX/API/CY8CMBR3xxx_HostFunctions.c",
		"/Users/jack/Desktop/meican/Writer/Writer/HARDWARE/GT32L32/GT32L32M1080.h",
		"/Users/jack/Desktop/meican/Writer/Writer/FWLIB/src/stm32f4xx_spi.c",
		"/Users/jack/Desktop/meican/Writer/Writer/common/STM32/Src/spi.c",
		"/Users/jack/Desktop/meican/Writer/Writer/FWLIB/inc/stm32f4xx_spi.h",
		"/Users/jack/Desktop/meican/Writer/Writer/SYSTEM/QRCode/QRCode.h",
		"/Users/jack/Desktop/meican/Writer/Writer/SYSTEM/uart/bsp_uart3.c",
		"/Users/jack/Desktop/meican/Writer/Writer/FWLIB/inc/stm32f4xx_rcc.h",
		"/Users/jack/Desktop/meican/Writer/Writer/HARDWARE/ST7789V/ST7789V.c",
		"/Users/jack/Desktop/meican/Writer/Writer/SYSTEM/uart/bsp_uart3.h",
		"/Users/jack/Desktop/meican/Writer/Writer/USER/stm32f4xx.h",
		"/Users/jack/Desktop/meican/Writer/Writer/FWLIB/src/stm32f4xx_usart.c",
		"/Users/jack/Desktop/meican/Writer/Writer/SYSTEM/uart/usart.h",
		"/Users/jack/Desktop/meican/Writer/Writer/SYSTEM/uart/my_usart.c",
		"/Users/jack/Desktop/meican/Writer/Writer/SYSTEM/uart/my_usart.h",
		"/Users/jack/Desktop/meican/Writer/Writer/SYSTEM/uart/usart.c",
		"/Users/jack/Library/Application Support/Sublime Text 3/Packages/WordHighlight/Default (OSX).sublime-keymap",
		"/Users/jack/Desktop/meican/Writer/Writer/SYSTEM/MyUtils/MyUtils.c",
		"/Users/jack/Library/Application Support/Sublime Text 3/Packages/User/Word Highlight.sublime-settings",
		"/Users/jack/Desktop/meican/Writer/Writer/USER/SPI.uvoptx",
		"/Users/jack/Desktop/meican/Writer/Writer/HARDWARE/CY8CMBR3XXX/API/CY8CMBR3xxx_APIs.c",
		"/Users/jack/Desktop/美餐/写卡器/Writer/SYSTEM/RFID/RFID.c",
		"/Users/jack/Desktop/美餐/写卡器/Writer/APP/UI/UI.c",
		"/Users/jack/Desktop/美餐/写卡器/Writer/SYSTEM/Protocol/Protocol.c",
		"/Users/jack/Desktop/美餐/写卡器/Writer/SYSTEM/UserData/UserData.c",
		"/Users/jack/Desktop/美餐/写卡器/Writer/SYSTEM/Touch/Touch.c",
		"/Users/jack/Desktop/美餐/写卡器/Writer/HARDWARE/LED/LED.c",
		"/Users/jack/Desktop/美餐/写卡器/Writer/USER/main.c",
		"/Users/jack/Desktop/美餐/写卡器/Writer/FWLIB/src/stm32f4xx_rcc.c",
		"/Users/jack/Library/Application Support/Sublime Text 3/Packages/User/Preferences.sublime-settings",
		"/Users/jack/Library/Application Support/Sublime Text 3/Packages/Default/Preferences.sublime-settings"
	],
	"find":
	{
		"height": 44.0
	},
	"find_in_files":
	{
		"height": 116.0,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"set_light_mode",
			"OCPolarity",
			"ex_device_test",
			"debug_led_control",
			"LED_PWM_CTRL_Pin",
			"htim3",
			"htim2",
			"sConfigOC",
			"TIM_OCMODE_PWM1",
			"LED_PWM_CTRL_GPIO_Port",
			"LED_PWM_CTRL_Pin",
			"4242",
			"LED_PWM_CTRL_Pin",
			"led_pwm_ctl",
			"debug_led_control",
			"LED_B",
			"\t\nlcdram_map",
			"TASKS_MAX",
			"TASK_ADC_CONV",
			"open",
			"TaskComps"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": true,
		"wrap": false
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "Src/main.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16660,
						"regions":
						{
						},
						"selection":
						[
							[
								13119,
								13119
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#include \"includes.h\" \n\n\n#include \"utils.h\"\n#include \"rfal_nfc.h\"\n#include \"st25r3916.h\"\n\n//int main(void)\n//{\n//\tsysterm_init();\n// \n//\t\n//\twhile(1)\n//\t{\n//\t  HAL_GPIO_TogglePin(MAIN_LED_GPIO_Port, MAIN_LED_Pin);\n//\t\tapp_dispatch(); \n//\t}\n//}\n\n\n///15693 读写卡测试\n\n//#define EXAMPLE_RFAL_POLLER_DEVICES      10 \n//static uint8_t gDevCnt;  \n// rfalNfcvListenDevice nfcvDevList[EXAMPLE_RFAL_POLLER_DEVICES];      \n\n//\trfalNfcvInventoryRes invRes;\n//\tReturnCode           err;\n//\tuint8_t    i;    \n//\tuint8_t    devCnt;\n//\t\n//\t\n//\tuint8_t block_buff[16];  /* Flags + Block Data + CRC */\n//\tuint16_t read_block_len = 0;\n//\t\n//\t\n//\tuint8_t txData[64] = {0};\n//int main(void)\n//{\n//\t\n\n//\t\n//\tsysterm_init();\n//  \n//\trfalAnalogConfigInitialize();\n//\t if(rfalInitialize() != ERR_NONE)                                                  /* Initialize RFAL */\n//    {\n//\t\t\t HAL_GPIO_TogglePin(MAIN_LED_GPIO_Port, MAIN_LED_Pin);\n//\t\t}\n//\t\t\n\n////\trfalChipMeasureAmplitude(txData);\n////\trfalChipMeasurePhase(txData + 1);\n\n//\t\t\n//\twhile(1)\n//\t{\n//\t  HAL_GPIO_TogglePin(MAIN_LED_GPIO_Port, MAIN_LED_Pin);\n//\t \n////\t\trfalWorker();    \n////\t\t\n////\t\t   /*******************************************************************************/\n////    /* NFC-V Technology Detection                                                  */\n////    /*******************************************************************************/\n////    \n////    rfalNfcvPollerInitialize();                                                       /* Initialize RFAL for NFC-V */\n////    rfalFieldOnAndStartGT();                                                          /* As field is already On only starts GT timer */\n////    \n////    err = rfalNfcvPollerCheckPresence( &invRes );                                     /* Poll for NFC-V devices */\n////    if( err == ERR_NONE )\n////    {\n////      //  gTechsFound |= EXAMPLE_RFAL_POLLER_FOUND_V;\n////    }\n//\t\t\n////\t\tst25r3916TxRxOn();\n////\t\tplatformDelay(10);//可减少延时？？\t\n//\t\t\n//\t\t          \n//\t\trfalNfcvPollerInitialize();        \n//\t\trfalFieldOnAndStartGT();                                                      /* Ensure GT again as other technologies have also been polled */       \n//\t\terr = rfalNfcvPollerCollisionResolution(RFAL_COMPLIANCE_MODE_ISO , (EXAMPLE_RFAL_POLLER_DEVICES - gDevCnt), nfcvDevList, &devCnt );        \n//\t//err = rfalNfcvPollerSleepCollisionResolution((EXAMPLE_RFAL_POLLER_DEVICES - gDevCnt), invResList, &devCnt );   \n\n//\t\tif( (err == ERR_NONE) && (devCnt != 0) )        \n//\t\t{           \n//\t\t\tprintf(\"read tag num %d\\n\", devCnt);\n//\t\t\tfor(int i=0; i<devCnt; i++)\n//\t\t\t{\n//\t\t\t\tprintf(\"uid:\");\n//\t\t\t\tprint_hex(nfcvDevList[i].InvRes.UID, 8);\n//\t\t\t\tprintf(\"\\n\");\n//\t\t\t\t\n//\t\t\t\t\n//\t\t\terr =\t rfalNfcvPollerSelect( RFAL_NFCV_REQ_FLAG_DEFAULT , nfcvDevList[i].InvRes.UID );\n//\t\t\t\tif(ERR_NONE == ERR_NONE)\n//\t\t\t\t{\n//\t\t\t\t\t\tfor(int j=0; j<sizeof(block_buff); j++)\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tblock_buff[j] = j+0x11;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\t\n//\t\t\t\t\t\trfalNfcvPollerWriteSingleBlock(RFAL_NFCV_REQ_FLAG_DEFAULT, nfcvDevList[i].InvRes.UID, 3, block_buff, 4);\n//\t\t\t\t\t\n//\t\t\t\t\t//读取块\n//\t\t\t\t\t\terr = rfalNfcvPollerReadSingleBlock(RFAL_NFCV_REQ_FLAG_DEFAULT, nfcvDevList[i].InvRes.UID, 3, block_buff, 8, &read_block_len);\n//\t\t\t\t\t\tif(ERR_NONE == ERR_NONE)\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tprintf(\"block:\");\n//\t\t\t\t\t\t\tprint_hex(block_buff+1, read_block_len);\n//\t\t\t\t\t\t\tprintf(\"\\n\");\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\t\tprintf(\"rfalNfcvPollerReadSingleBlock() ==> error\\n\");\n//\t\t\t\t\t\t} \n//\t\t\t\t}\n//\t\t\t\telse\n//\t\t\t\t{\n//\t\t\t\t\t\tprintf(\"rfalNfcvPollerSelect() ==> error\\n\");\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n////\t\t\tst25r3916TxRxOff();\n//\t\t// printf(\" NFC-V device UID: %s \\r\\n\", hex2str(gDevList[i].dev.nfcv.InvRes.UID, RFAL_NFCV_UID_LEN));\n//\t}\n//}\n\n\n\n/*!\n *****************************************************************************\n * \\brief Demo Blocking Transceive \n *\n * Helper function to send data in a blocking manner via the rfalNfc module \n *  \n * \\warning A protocol transceive handles long timeouts (several seconds), \n * transmission errors and retransmissions which may lead to a long period of \n * time where the MCU/CPU is blocked in this method.\n * This is a demo implementation, for a non-blocking usage example please \n * refer to the Examples available with RFAL\n *\n * \\param[in]  txBuf      : data to be transmitted\n * \\param[in]  txBufSize  : size of the data to be transmited\n * \\param[out] rxData     : location where the received data has been placed\n * \\param[out] rcvLen     : number of data bytes received\n * \\param[in]  fwt        : FWT to be used (only for RF frame interface, \n *                                          otherwise use RFAL_FWT_NONE)\n *\n * \n *  \\return ERR_PARAM     : Invalid parameters\n *  \\return ERR_TIMEOUT   : Timeout error\n *  \\return ERR_FRAMING   : Framing error detected\n *  \\return ERR_PROTO     : Protocol error detected\n *  \\return ERR_NONE      : No error, activation successful\n * \n *****************************************************************************\n */\nReturnCode demoTransceiveBlocking( uint8_t *txBuf, uint16_t txBufSize, uint8_t **rxData, uint16_t **rcvLen, uint32_t fwt )\n{\n    ReturnCode err;\n    \n    err = rfalNfcDataExchangeStart( txBuf, txBufSize, rxData, rcvLen, fwt );\n    if( err == ERR_NONE )\n    {\n        do{\n            rfalNfcWorker();\n            err = rfalNfcDataExchangeGetStatus();\n        }\n        while( err == ERR_BUSY );\n    }\n    return err;\n}\n\n\n #define DEMO_ENABLE_POLL_MODE                     true\n#define DEMO_ENABLE_LISTEN_MODE                   false\n#define DEMO_ENABLE_P2P_MODE                      false\n#define DEMO_ENABLE_POLL_WRITE_TAG                false\n\n/* APDUs communication data */    \nstatic uint8_t ndefSelectApp[] = { 0x00, 0xA4, 0x04, 0x00, 0x07, 0xD2, 0x76, 0x00, 0x00, 0x85, 0x01, 0x01, 0x00 };\nstatic uint8_t ccSelectFile[] = { 0x00, 0xA4, 0x00, 0x0C, 0x02, 0xE1, 0x03};\nstatic uint8_t readBynary[] = { 0x00, 0xB0, 0x00, 0x00, 0x0F };\n/*static uint8_t ppseSelectApp[] = { 0x00, 0xA4, 0x04, 0x00, 0x0E, 0x32, 0x50, 0x41, 0x59, 0x2E, 0x53, 0x59, 0x53, 0x2E, 0x44, 0x44, 0x46, 0x30, 0x31, 0x00 };*/\n\n\n/*!\n *****************************************************************************\n * \\brief Demo APDUs Exchange\n *\n * Example how to exchange a set of predefined APDUs with PICC. The NDEF\n * application will be selected and then CC will be selected and read.\n * \n *****************************************************************************\n */\n//void demoAPDU( void )\n//{\n//    ReturnCode err;\n//    uint16_t   *rxLen;\n//    uint8_t    *rxData;\n\n\n//    /* Exchange APDU: NDEF Tag Application Select command */\n//    err = demoTransceiveBlocking( ndefSelectApp, sizeof(ndefSelectApp), &rxData, &rxLen, RFAL_FWT_NONE );\n//    printf(\" Select NDEF Application: %s Data: %s\\r\\n\", (err != ERR_NONE) ? \"FAIL\": \"OK\", hex2Str( rxData, *rxLen) );\n\n//    if( (err == ERR_NONE) && rxData[0] == 0x90 && rxData[1] == 0x00)\n//    {\n//        /* Exchange APDU: Select Capability Container File */\n//        err = demoTransceiveBlocking( ccSelectFile, sizeof(ccSelectFile), &rxData, &rxLen, RFAL_FWT_NONE );\n//        printf(\" Select CC: %s Data: %s\\r\\n\", (err != ERR_NONE) ? \"FAIL\": \"OK\", hex2Str( rxData, *rxLen) );\n\n//        /* Exchange APDU: Read Capability Container File  */\n//        err = demoTransceiveBlocking( readBynary, sizeof(readBynary), &rxData, &rxLen, RFAL_FWT_NONE );\n//        printf(\" Read CC: %s Data: %s\\r\\n\", (err != ERR_NONE) ? \"FAIL\": \"OK\", hex2Str( rxData, *rxLen) );\n//    }\n//}\n\n\n#define EXAMPLE_NFCA_DEVICES 10\n/*\n******************************************************************************* \n * GLOBAL FUNCTIONS\n******************************************************************************\n */\n\nvoid exampleNFCARun(void)\n{\n    ReturnCode err;\n    rfalNfcaSensRes sensRes;\n    rfalNfcaSelRes selRes;\n    rfalNfcaListenDevice nfcaDevList[EXAMPLE_NFCA_DEVICES];\n    uint8_t devCnt;\n    uint8_t devIt;\n    rfalInitialize();\n    for (;;)\n    {\n        rfalFieldOff(); /* Turn the Field Off */\n        platformDelay(500);\n        rfalNfcaPollerInitialize(); /* Initialize RFAL for NFC-A */\n        rfalFieldOnAndStartGT();    /* Turns the Field On and starts GT timer */\n        /*******************************************************************************/\n        /* Perform NFC-A Technology detection                                          */\n        err = rfalNfcaPollerTechnologyDetection(RFAL_COMPLIANCE_MODE_NFC, &sensRes);                                           /* Poll for nearby NFC-A devices */\n        if (err == ERR_NONE)                                                                                                   /* NFC-A type card found */\n        { /*******************************************************************************/                                    /* Perform NFC-A Collision Resolution */\n            err = rfalNfcaPollerFullCollisionResolution(RFAL_COMPLIANCE_MODE_NFC, EXAMPLE_NFCA_DEVICES, nfcaDevList, &devCnt); /* Perform collision avoidance */\n            if ((err == ERR_NONE) && (devCnt > 0))\n            {\n                printf(\"NFC-A device(s) found %d\\r\\n\", devCnt);\n                devIt = 0; /* Use the first device on the list */\n                /*******************************************************************************/\n                /* Check if desired device is in Sleep                                         */\n//                if (nfcaDevList[devIt].isSleep)\n                {\n                    err = rfalNfcaPollerCheckPresence(RFAL_14443A_SHORTFRAME_CMD_WUPA, &sensRes); /* Wake up all cards  */\n                    if (err != ERR_NONE)\n                    {\n                        continue;\n                    }\n                    err = rfalNfcaPollerSelect(nfcaDevList[devIt].nfcId1, nfcaDevList[devIt].nfcId1Len, &selRes); /* Select specific device  */\n                    if (err != ERR_NONE)\n                    {\n                        continue;\n                    }\n                }\n                /*******************************************************************************/\n                /* Perform protocol specific activation                                        */\n                switch (nfcaDevList[devIt].type)\n                {\n                case RFAL_NFCA_T1T:                             /* No further activation needed for a T1T (RID already performed)*/\n                    printf(\"NFC-A T1T device found \\r\\n\"); /* NFC-A T1T device found, NFCID/UID is contained in: t1tRidRes.uid */\n                    /* Following communications shall be performed using:                         \n                    *   - Non blocking: rfalStartTransceive() + rfalGetTransceiveState()                         \n                    *   -     Blocking: rfalTransceiveBlockingTx() + rfalTransceiveBlockingRx() or rfalTransceiveBlockingTxRx()    */\n                    break;\n                case RFAL_NFCA_T2T:                             /* No specific activation needed for a T2T */\n                    printf(\"NFC-A T2T device found \\r\\n\"); /* NFC-A T2T device found, NFCID/UID is contained in: nfcaDev.nfcid */\n                    /* Following communications shall be performed using:                         \n                    *   - Non blocking: rfalStartTransceive() + rfalGetTransceiveState()                         \n                    *   -     Blocking: rfalTransceiveBlockingTx() + rfalTransceiveBlockingRx() or rfalTransceiveBlockingTxRx()    */\n                    break;\n                case RFAL_NFCA_T4T:\n                    printf(\"NFC-A T4T (ISO-DEP) device found \\r\\n\"); /* NFC-A T4T device found, NFCID/UID is contained in: nfcaDev.nfcid */\n                    /* Activation should continue using rfalIsoDepPollAHandleActivation(), see exampleRfalPoller.c */\n                    break;\n                case RFAL_NFCA_T4T_NFCDEP:                                /* Device supports T4T and NFC-DEP */\n                case RFAL_NFCA_NFCDEP:                                    /* Device supports NFC-DEP */\n                    printf(\"NFC-A P2P (NFC-DEP) device found \\r\\n\"); /* NFC-A P2P device found, NFCID/UID is contained in: nfcaDev.nfcid */\n                    /* Activation should continue using rfalNfcDepInitiatorHandleActivation(), see exampleRfalPoller.c */\n                    break;\n                }\n//                rfalNfcaPollerSleep(); /* Put device to sleep / HLTA (useless as the field will be turned off anyhow) */\n            }\n        }\n    }\n}\n\n\n\n#define EXAMPLE_RFAL_POLLER_DEVICES      5U  \n rfalNfcaListenDevice nfcvDevList[EXAMPLE_RFAL_POLLER_DEVICES];      \n \nrfalNfcvListenDevice iso_nfcvDevList[EXAMPLE_RFAL_POLLER_DEVICES]; \n\n\tReturnCode           err; \n\tuint8_t    devCnt;\n\t\n\tstatic uint8_t gDevCnt; \n\n\n\tuint8_t block_buff[16];  /* Flags + Block Data + CRC */\n\tuint16_t read_block_len = 0;\n\t rfalNfcaSelRes select_res;\nint main(void)\n{ \n\tsysterm_init();\n  \n\trfalAnalogConfigInitialize();\n\t if(rfalInitialize() != ERR_NONE)                                                  /* Initialize RFAL */\n    {\n\t\t\t HAL_GPIO_TogglePin(MAIN_LED_GPIO_Port, MAIN_LED_Pin);\n\t\t} \n\n\t\t\n\twhile(1)\n\t{\n        //ex_device_test();\n        app_dispatch();\n\tHAL_GPIO_TogglePin(MAIN_LED_GPIO_Port, MAIN_LED_Pin);\n\t\t\n\t\t//读取15693\n\t   st25r3916TxRxOn();    \n\t\tHAL_Delay(10);\n\trfalNfcvPollerInitialize();        \n\trfalFieldOnAndStartGT();   \n\terr = rfalNfcvPollerCollisionResolution(RFAL_COMPLIANCE_MODE_NFC , (EXAMPLE_RFAL_POLLER_DEVICES - gDevCnt), iso_nfcvDevList, &devCnt );  \n\tif( (err == ERR_NONE) && (devCnt != 0) )        \n\t\t{      \n\t\tprintf(\"tag type: iso15693\\r\\n\");\t\t\t\n\t\t\tprintf(\"tag num %d\\n\", devCnt);\n\t\t\tfor(int i=0; i<devCnt; i++)\n\t\t\t{\n\t\t\t\tprintf(\"uid:\");\n\t\t\t\tprint_hex(iso_nfcvDevList[i].InvRes.UID, 8);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\t\t \n\t\tst25r3916TxRxOff();\n\t\t\n\t\t\n\t\tHAL_Delay(50);\n\t\t\n\t\t\n\t\t\n\t\t//读取1443A\n\t\t st25r3916TxRxOn();                                                                   /* Turn the Field Off */\n\t\t\n\t\tHAL_Delay(10);\n\t\t//14443A标签读取\n\t\trfalNfcaPollerInitialize();        \n\t\trfalFieldOnAndStartGT();   \n\t\t\n\t\t \n//\trfalWorker();\n//\t\t rfalNfcWorker();\n                                                   /* Ensure GT again as other technologies have also been polled */       \n\t\terr = rfalNfcaPollerFullCollisionResolution( RFAL_COMPLIANCE_MODE_NFC,  EXAMPLE_RFAL_POLLER_DEVICES - devCnt, nfcvDevList, &devCnt );\n\t\t\n\t\t\tst25r3916TxRxOff();\n\t\t//14443B标签\n//\t\trfalNfcaPollerInitialize();        \n//\t\trfalFieldOnAndStartGT();                                                      /* Ensure GT again as other technologies have also been polled */       \n//\t\terr = rfalNfcaPollerFullCollisionResolution( RFAL_COMPLIANCE_MODE_NFC,  EXAMPLE_RFAL_POLLER_DEVICES - gDevCnt, nfcvDevList, &devCnt );\n\t\t\n\t\n\t\t\n\t\tif( (err == ERR_NONE) && (devCnt != 0) )        \n\t\t{           \n\t\t\tprintf(\"\\r\\ntag type: 14443a\\r\\n\");\t\n\t\t\tprintf(\"tag num %d\\n\", devCnt);\n\t\t\tfor(int i=0; i<devCnt; i++)\n\t\t\t{ \n\t\t\t\tprintf(\"uid length = %d\\n\", nfcvDevList[i].nfcId1Len);\n\t\t\t\tprintf(\"uid:\");\n\t\t\t\tprint_hex(nfcvDevList[i].nfcId1, 10);\n\t\t\t\tprintf(\"\\n\");\n//\t\t\t\t \n//\t\t\terr =\t rfalNfcaPollerSelect(nfcvDevList[i].nfcId1, nfcvDevList[i].nfcId1Len,  &select_res);\n//\t\t\t\tif(ERR_NONE == ERR_NONE)\n//\t\t\t\t{\n//\t\t\t\t\t\tfor(int j=0; j<sizeof(block_buff); j++)\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tblock_buff[j] = j+0x11;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\t\n//\t\t\t\t\t\t err = rfalT2TPollerSectorSelect(0x02);\n// \n//\t\t\t\t if( err != ERR_NONE )\n//\t\t\t\t {\n//\t\t\t\t\t printf(\"  error: %d  Exit...\\r\\n\", err);\n//\t\t\t\t\t// return false;\n//\t\t\t\t }\n//\t\t\t\t \n//\t\t\t\t\t\terr = rfalT2TPollerWrite(0x02, block_buff);\n//\t\t\t\t\t\tif(err != ERR_NONE)\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tprintf(\"write error\\n\");\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\t\n//\t\t\t\t\t\terr = rfalT2TPollerRead(0x02, block_buff, 8, &read_block_len);\n////\t\t\t\t\t\trfalNfcvPollerWriteSingleBlock(RFAL_NFCV_REQ_FLAG_DEFAULT, nfcvDevList[i].InvRes.UID, 3, block_buff, 4);\n////\t\t\t\t\t\n////\t\t\t\t\t//读取块\n////\t\t\t\t\t\terr = rfalNfcvPollerReadSingleBlock(RFAL_NFCV_REQ_FLAG_DEFAULT, nfcvDevList[i].InvRes.UID, 3, block_buff, 8, &read_block_len);\n//\t\t\t\t\t\tif(err == ERR_NONE)\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tprintf(\"block:\");\n//\t\t\t\t\t\t\tprint_hex(block_buff+1, read_block_len);\n//\t\t\t\t\t\t\tprintf(\"\\n\");\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\t\tprintf(\"rfalNfcvPollerReadSingleBlock() ==> error\\n\");\n//\t\t\t\t\t\t} \n//\t\t\t\t}\n//\t\t\t\telse\n//\t\t\t\t{\n//\t\t\t\t\t\tprintf(\"rfalNfcvPollerSelect() ==> error\\n\");\n//\t\t\t\t}\n\t\t\t}\n\t\t}\n\t \n\t\t\n//\t\t\tst25r3916TxRxOff();\n\t\t// printf(\" NFC-V device UID: %s \\r\\n\", hex2str(gDevList[i].dev.nfcv.InvRes.UID, RFAL_NFCV_UID_LEN));\n\t}\n}\n\n\n\n\n//int main(void)\n//{ \n//\tsysterm_init();\n//  \n// exampleNFCARun();\n//\twhile(1)\n//\t{\n//\t  HAL_GPIO_TogglePin(MAIN_LED_GPIO_Port, MAIN_LED_Pin);\n//\t\t \n//\t}\n//}\n\n\n",
							"origin_encoding": "GB2312",
							"revert_to_scratch": true,
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 8199.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "device_lib/st25r3916/ST25R3916/st25r3916.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 26642,
						"regions":
						{
						},
						"selection":
						[
							[
								15579,
								15579
							]
						],
						"settings":
						{
							"origin_encoding": "ASCII",
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "hardware/inc/GT32L32M0180.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8151,
						"regions":
						{
						},
						"selection":
						[
							[
								75,
								75
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "\n#ifndef _GT32L32M0180_H_\n#define _GT32L32M0180_H_\n \nextern unsigned char r_dat_bat(unsigned long address,unsigned long byte_long,unsigned char *p_arr);\n\n#define ASCII_5X7              1      //ASCII编码5X7点阵\n#define ASCII_7X8              2      //ASCII编码7X8点阵\n#define ASCII_7X8_F            3      //ASCII编码7X8点阵Fat风格字符（具体字形看规格书）\n#define ASCII_6X12             4      //ASCII编码6X12点阵\n#define ASCII_8X16             5      //ASCII编码8X16点阵\n#define ASCII_8X16_F           6      //ASCII编码8X16点阵Fat风格字符（具体字形看规格书）\n#define ASCII_12X24            7      //ASCII编码12X24点阵\n//#define ASCII_12X24_P          8      //ASCII编码12X24点阵打印体\n#define ASCII_16X32            9      //ASCII编码16X32点阵\n#define ASCII_16X32_F         10      //ASCII编码16X32点阵Fat风格字符（具体字形看规格书）\n#define ASCII_12_A            11      //ASCII编码12x12点阵不等宽Arial风格字符（具体字形看规格书）\t\t\n#define ASCII_12_T            12\t\t  //ASCII编码12X12点阵不等宽Time news Roman风格字符（具体字形看规格书）\n#define ASCII_16_A            13      //ASCII编码16X16点阵不等宽Arial风格字符（具体字形看规格书）\t\t\n#define ASCII_16_T            14\t\t  //ASCII编码16X16点阵不等宽Time news Roman风格字符（具体字形看规格书）\n#define ASCII_24_A            15      //ASCII编码24X24点阵不等宽Arial风格字符（具体字形看规格书）\t\t\n#define ASCII_24_T            16\t\t  //ASCII编码24X24点阵不等宽Time news Roman风格字符（具体字形看规格书）\n#define ASCII_32_A            17      //ASCII编码32X32点阵不等宽Arial风格字符（具体字形看规格书）\t\t\n#define ASCII_32_T            18\t\t  //ASCII编码32X32点阵不等宽Time news Roman风格字符（具体字形看规格书）\n\n#define NUB_14X28\t\t\t\t\t\t\t 0\n#define NUB_20X40\t\t\t\t\t\t\t 1\n#define NUB_28X28\t\t\t\t\t\t\t 2\n#define NUB_40X40\t\t\t\t\t\t\t 3\n\n\n/*************************************************************\n函数用法：\n    unsigned char DZ_Data[数组长度客户自定义];\n    ASCII_GetData(0x41,ASCII_5X7,DZ_Data);      //读取5X7点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为8 BYTE\n\t  ASCII_GetData(0x41,ASCII_7X8,DZ_Data);      //读取7X8点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为8 BYTE\n\t\tASCII_GetData(0x41,ASCII_7X8_F,DZ_Data);\t\t//读取7X8点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为8 BYTE\n\t  ASCII_GetData(0x41,ASCII_6X12,DZ_Data);     //读取6X12点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为12 BYTE\n\t  ASCII_GetData(0x41,ASCII_8X16,DZ_Data);   \t//读取8X16点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为16 BYTE\n\t  ASCII_GetData(0x41,ASCII_8X16_F,DZ_Data);   //读取8X16点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为16 BYTE\n\t  ASCII_GetData(0x41,ASCII_12X24,DZ_Data);\t\t//读取12X24点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为48 BYTE\n\t\tASCII_GetData(0x41,ASCII_16X32,DZ_Data);\t\t//读取16X32点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为64 BYTE\n\t\tASCII_GetData(0x41,ASCII_16X32_F,DZ_Data);\t//读取16X32点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为64 BYTE\n\t\tASCII_GetData(0x41,ASCII_12_A,DZ_Data);     //读取12X12点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为26 BYTE\n\t\tASCII_GetData(0x41,ASCII_12_T,DZ_Data);     //读取12X12点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为26 BYTE\n\t  ASCII_GetData(0x41,ASCII_16_A,DZ_Data);     //读取16X16点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为34 BYTE\n\t\tASCII_GetData(0x41,ASCII_16_T,DZ_Data);     //读取16X16点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为34 BYTE\n\t\tASCII_GetData(0x41,ASCII_24_A,DZ_Data);     //读取24X24点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为74 BYTE\n\t\tASCII_GetData(0x41,ASCII_24_T,DZ_Data);     //读取24X24点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为74 BYTE\n\t\tASCII_GetData(0x41,ASCII_32_A,DZ_Data);     //读取32X32点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为128 BYTE\n\t\tASCII_GetData(0x41,ASCII_32_T,DZ_Data);     //读取32X32点阵 ASCII 编码A的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为128 BYTE\n\t\t\t\t\n*************************************************************/ \nunsigned char  ASCII_GetData(unsigned char  ASCIICode,unsigned long  ascii_kind,unsigned char *DZ_Data);\n\n/*************************************************************\n函数用法：\n    unsigned char DZ_Data[数组长度客户自定义];\n    Dig_Ch_GetData(1,NUB_14X28,DZ_Data);\t//读取14X28点阵数字符号字符点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为56 BYTE\n\t  Dig_Ch_GetData(1,NUB_20X40,DZ_Data);\t//读取20X40点阵数字符号字符点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为120 BYTE\n\t\tDig_Ch_GetData(1,NUB_28X28,DZ_Data);\t//读取28X28点阵数字符号字符点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为112 BYTE\n\t  Dig_Ch_GetData(1,NUB_40X40,DZ_Data);\t//读取40X40点阵数字符号字符点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为200 BYTE\n*************************************************************/ \nunsigned char\t Dig_Ch_GetData(unsigned char  Sequence,unsigned long  NUB_kind,unsigned char *DZ_Data);\n \n/*************************************************************\n函数用法：\n    unsigned char DZ_Data[数组长度客户自定义];\n    gt_12_GetData(0xb0,0xa1,0x00,0x00,DZ_Data); //读取12X12点阵 汉字\"啊\"的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为24 BYTE\n*************************************************************/\nunsigned long  gt_12_GetData(unsigned char c1,unsigned char c2,unsigned char c3,unsigned char c4,unsigned char *DZ_Data);\n\n/*************************************************************\n函数用法：\n    unsigned char DZ_Data[数组长度客户自定义];\n    gt_16_GetData(0xb0,0xa1,0x00,0x00,DZ_Data); //读取16X16点阵 汉字\"啊\"的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为24 BYTE\n*************************************************************/ \nunsigned long  gt_16_GetData(unsigned char  c1, unsigned char  c2, unsigned char  c3, unsigned char  c4,unsigned char *DZ_Data);\n\n/*************************************************************\n函数用法：\n    unsigned char DZ_Data[数组长度客户自定义];\n    gt_24_GetData(0xb0,0xa1,0x00,0x00,DZ_Data); //读取24X24点阵 汉字\"啊\"的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为72 BYTE\n*************************************************************/ \nunsigned long  gt_24_GetData(unsigned char  c1, unsigned char  c2, unsigned char  c3, unsigned char  c4,unsigned char *DZ_Data);\n\n/*************************************************************\n函数用法：\n    unsigned char DZ_Data[数组长度客户自定义];\n    gt_32_GetData(0xb0,0xa1,0x00,0x00,DZ_Data); //读取32X32点阵 汉字\"啊\"的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为128 BYTE\n*************************************************************/ \nunsigned long  gt_32_GetData(unsigned char  c1,unsigned char  c2,unsigned char  c3,unsigned char  c4,unsigned char *DZ_Data);\n\n/*************************************************************\n函数用法：\n    unsigned long BAR_NUM[13]={0,1,2,3,4,5,6,7,8,9,1,2,3};\n    unsigned long BAR_ADDR[13];\n\t\tBAR_CODE13(BAR_NUM,BAR_ADDR); //获取条形码的地址，并将地址存于数组BAR_ADDR中\n*************************************************************/\nunsigned long  BAR_CODE13(unsigned char  * BAR_NUM,unsigned char *BAR_PIC_ADDR);\n/*************************************************************\n函数用法：\n    unsigned long BAR_NUM[13]={0,1,2,3,4,5,6,7,8,9,1,2,3};\n    unsigned long BAR_ADDR[7];\n\t\tBAR_CODE128(BAR_NUM,1,BAR_ADDR); //获取条形码的地址，并将地址存于数组BAR_ADDR中\n起始符有3种模式\n当flag=1时为Code-128-A;\n当flag=2时为Code-128-B;\n当flag=3时为Code-128-C;\t\t\n*************************************************************/\nunsigned long  BAR_CODE128(unsigned char  *BAR_NUM,unsigned char  flag,unsigned char *BAR_PIC_ADDR);\n\n/*************************************************************\n函数用法：\n    unsigned char DZ_Data[数组长度客户自定义];\n    Antenna_CODE_12X12_GetData(0,DZ_Data); //读取12X12点阵天线字符的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为24 BYTE\n*************************************************************/ \nunsigned long  Antenna_CODE_12X12_GetData(unsigned char  NUM,unsigned char *DZ_Data);\n\n/*************************************************************\n函数用法：\n    unsigned char DZ_Data[数组长度客户自定义];\n    Battery_CODE_12X12_GetData(0,DZ_Data); //读取12X12点阵电池字符的点阵数据，并将点阵数据存在DZ_Data数组中；数据长度为24 BYTE\n*************************************************************/ \nunsigned long  Battery_CODE_12X12_GetData(unsigned char   NUM,unsigned char *DZ_Data);\n\n/*************************************************************\n函数用法：\n    unsigned char GBCode;\n    GBCode = U2G(0x554A); //将unicode编码数据转换GBK编码\n*************************************************************/ \nunsigned long\tU2G(unsigned int  unicode);\n\n/*************************************************************\n函数用法：\n    unsigned char GBCode;\n    GBCode = U2G_13(0x554A); //将unicode编码数据转换GBK编码（字符区）\n*************************************************************/ \nunsigned int  U2G_13(unsigned int  Unicode);\n\n/*************************************************************\n函数用法：\n    unsigned char GBCode;\n    GBCode = BIG5_G(0xB0DA); //将Big5编码数据转换GBK编码 \n*************************************************************/ \nunsigned long  BIG5_G(unsigned int  B5code);\n \n\n\n#endif\n\n\n\n\n",
							"origin_encoding": "GB2312",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "event_manage/src/uart_debug.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1772,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#include \"includes.h\"\n#include \"uart_debug.h\"\n#include \"debug_task.h\"\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n\n#define DEBUG_UART\t\t\t\t\t\t\t\tUSART1 \n#define DEBUG_IRQ_HANDLE(NAME)    NAME##_IRQHandler\n#define DEBUG_REV_COMPLETE_IRQ_HANDLE(NAME)    NAME##_IRQHandler\n\n\nvoid debug_send(uint8_t value)\n{\n\tDEBUG_UART->DR = value;\n\twhile((DEBUG_UART->SR & UART_IT_TXE) == RESET);\n}\n\nuint8_t debug_read(void)\n{\n\tuint8_t value = 0;\n\twhile((DEBUG_UART->SR & UART_IT_RXNE) == RESET);\n\tvalue = DEBUG_UART->DR;\n\treturn value;\n}\n\n/**\n  * 函数功能: 重定向c库函数printf到DEBUG_USARTx\n  * 输入参数: 无\n  * 返 回 值: 无\n  * 说    明：无\n  */\nint fputc(int ch, FILE *f)\n{\n\tdebug_send(ch); \n  return ch;\n}\n\n/**\n  * 函数功能: 重定向c库函数getchar,scanf到DEBUG_USARTx\n  * 输入参数: 无\n  * 返 回 值: 无\n  * 说    明：无\n  */\nint fgetc(FILE * f)\n{\n  uint8_t ch = 0;\n  ch = debug_read();\n  return ch;\n}\n\n\n//接收中断\nvoid DEBUG_IRQ_HANDLE(USART1)(void)\n{\n\tuint8_t value = 0;\n\tif((USART1->SR & UART_IT_RXNE) != 0)\n\t{\n\t\tvalue = USART1->DR;  \n\t\tpush_cmd_cache(value);\t\t//启动调试\n\t}\n\t\n\tif((USART1->SR & UART_IT_IDLE) != 0)\n\t{\n\t\t//清中断标志\n\t\tvalue = USART1->DR;\n\t\tvalue = USART1->SR;\n\t\t//写完成标志 \n\t}\n}\n\n\n\nvoid print_hex(uint8_t *buff, uint16_t len)\n{\n\tfor(int i=0; i<len; i++)\n\t{\n\t\tprintf(\"%02x \", buff[i]);\n\t}\n}\n\n\nvoid logUsartTx(uint8_t *buff, int len)\n{\n\tfor(int i=0; i<len; i++)\n\t{\n\t\tdebug_send(buff[i]);\n\t}\n}\n\nint logUsart(const char* format, ...)\n{\n  #if (USE_LOGGER == LOGGER_ON)\n  {\n    #define LOG_BUFFER_SIZE 256\n    char buf[LOG_BUFFER_SIZE];\n    va_list argptr;\n    va_start(argptr, format);\n    int cnt = vsnprintf(buf, LOG_BUFFER_SIZE, format, argptr);\n    va_end(argptr);  \n      \n    /* */\n    logUsartTx((uint8_t*)buf, strlen(buf));\n    return cnt;\n  }\n  #else\n  {\n    return 0;\n  }\n  #endif /* #if USE_LOGGER == LOGGER_ON */\n}\n\n",
							"origin_encoding": "GB2312",
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "hardware/src/bsp_init.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18869,
						"regions":
						{
						},
						"selection":
						[
							[
								12949,
								12953
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#include \"bsp_init.h\"\n#include \"main.h\"\n#include \"can_drv.h\" \n\nADC_HandleTypeDef hadc1;\nDMA_HandleTypeDef hdma_adc1;\n\nCAN_HandleTypeDef hcan;\n\nSPI_HandleTypeDef hspi1;\nSPI_HandleTypeDef hspi2;\n\nTIM_HandleTypeDef htim2;\nTIM_HandleTypeDef htim3;\n\nUART_HandleTypeDef huart1;\n\n/**\n  * @brief System Clock Configuration\n  * @retval None\n  */\nvoid SystemClock_Config(void)\n{\n  RCC_OscInitTypeDef RCC_OscInitStruct = {0};\n  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};\n  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};\n\n  /** Initializes the CPU, AHB and APB busses clocks \n  */\n  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;\n  RCC_OscInitStruct.HSEState = RCC_HSE_ON;\n  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;\n  RCC_OscInitStruct.HSIState = RCC_HSI_ON;\n  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;\n  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;\n  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;\n  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /** Initializes the CPU, AHB and APB busses clocks \n  */\n  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK\n                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;\n  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;\n  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;\n\n  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;\n  PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV6;\n  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)\n  {\n    Error_Handler();\n  }\n}\n\n/**\n  * @brief ADC1 Initialization Function\n  * @param None\n  * @retval None\n  */\nstatic void MX_ADC1_Init(void)\n{\n\n  /* USER CODE BEGIN ADC1_Init 0 */\n\n  /* USER CODE END ADC1_Init 0 */\n\n  ADC_ChannelConfTypeDef sConfig = {0};\n\n  /* USER CODE BEGIN ADC1_Init 1 */\n\n  /* USER CODE END ADC1_Init 1 */\n  /** Common config \n  */\n  hadc1.Instance = ADC1;\n  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;\n  hadc1.Init.ContinuousConvMode = ENABLE;\n  hadc1.Init.DiscontinuousConvMode = DISABLE;\n  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;\n  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;\n  hadc1.Init.NbrOfConversion = 2;\n  if (HAL_ADC_Init(&hadc1) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /** Configure Regular Channel \n  */\n  sConfig.Channel = ADC_CHANNEL_9;\n  sConfig.Rank = ADC_REGULAR_RANK_1;\n  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;\n  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /** Configure Regular Channel \n  */\n  sConfig.Channel = ADC_CHANNEL_0;\n  sConfig.Rank = ADC_REGULAR_RANK_2;\n  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /* USER CODE BEGIN ADC1_Init 2 */\n\n  /* USER CODE END ADC1_Init 2 */\n\n}\n  \n/**\n  * @brief CAN Initialization Function\n  * @param None\n  * @retval None\n  */\nstatic void MX_CAN_Init(uint8_t can_addr)\n{\n\tuint32_t filter_value = SIGNAL_SLAVE_FILTERID;\n\tuint32_t filter_mask = SIGNAL_SLAVE_MASK;\n\t\n  /* USER CODE BEGIN CAN_Init 0 */\n\n\tCAN_FilterTypeDef CAN_FilterInitStructure;\n  /* USER CODE END CAN_Init 0 */\n\n  /* USER CODE BEGIN CAN_Init 1 */\n\t//500k\n  /* USER CODE END CAN_Init 1 */\n  hcan.Instance = CAN1;\n  hcan.Init.Prescaler = 12;\n  hcan.Init.Mode = CAN_MODE_NORMAL;\n  hcan.Init.SyncJumpWidth = CAN_SJW_1TQ;\n  hcan.Init.TimeSeg1 = CAN_BS1_3TQ;\n  hcan.Init.TimeSeg2 = CAN_BS2_2TQ;\n  hcan.Init.TimeTriggeredMode = DISABLE;\n  hcan.Init.AutoBusOff = ENABLE;\n  hcan.Init.AutoWakeUp = ENABLE;\n  hcan.Init.AutoRetransmission = DISABLE;\n  hcan.Init.ReceiveFifoLocked = DISABLE;\n  hcan.Init.TransmitFifoPriority = DISABLE;\n  if (HAL_CAN_Init(&hcan) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /* USER CODE BEGIN CAN_Init 2 */\n\t\n\t//判断地址是否为空\n\tif(can_addr != CAN_ADDR_NULL)\t\t//进行地址滤波\n\t{\n\t\t//如果地址不为空，加入地址滤波\n\t\tfilter_value  &= 0xFFFFFF00;\n\t\tfilter_value  |= can_addr;\n\t\tfilter_mask   &= 0xFFFFFF00;\n\t\tfilter_mask   |= 0x000000FF;\n\t}\n\t\n\t/*===========================FIFO0 过滤=============================*/\n\t//单包接收，地址过滤\n\tCAN_FilterInitStructure.FilterBank \t= 0;     /* 过滤器组 */\n\tCAN_FilterInitStructure.FilterMode \t\t= CAN_FILTERMODE_IDMASK;//CAN_FilterMode_IdList;//CAN_FilterMode_IdMask;  /* 屏敝模式 */\n\tCAN_FilterInitStructure.FilterScale \t= CAN_FILTERSCALE_32BIT; ///* 32位 */\n\t \n\tCAN_FilterInitStructure.FilterIdHigh \t\t\t= FILTER_MASK_H(filter_value);  \n\tCAN_FilterInitStructure.FilterIdLow \t\t\t= FILTER_MASK_L(filter_value)|CAN_ID_EXT;\n\tCAN_FilterInitStructure.FilterMaskIdHigh \t= FILTER_MASK_H(filter_mask);\n\tCAN_FilterInitStructure.FilterMaskIdLow \t= FILTER_MASK_L(filter_mask)|CAN_ID_EXT;\n\t  \n\tCAN_FilterInitStructure.FilterFIFOAssignment \t= CAN_FILTER_FIFO0;  ///* 能够通过该过滤器的报文存到fifo0中 */\n\tCAN_FilterInitStructure.FilterActivation = ENABLE;\n\tHAL_CAN_ConfigFilter(&hcan,&CAN_FilterInitStructure);\n\t \n\t\t//判断地址是否为空\n\tif(can_addr != CAN_ADDR_NULL)\t\t//进行地址滤波\n\t{\n\t\tfilter_value = SIGNAL_SLAVE_FILTERID;\n\t\tfilter_mask = SIGNAL_SLAVE_MASK;\n\t\t//如果地址不为空，加入地址滤波\n\t\tfilter_value  &= 0xFFFFFF00;\n\t\tfilter_value  |= 0xFF;\n\t\tfilter_mask   &= 0xFFFFFF00;\n\t\tfilter_mask   |= 0x000000FF;\n\t}\n\t\n\tCAN_FilterInitStructure.FilterBank \t= 1;     /* 过滤器组 ， 添加全局地址0xFF地址*/ \n\tCAN_FilterInitStructure.FilterMode \t\t= CAN_FILTERMODE_IDMASK;//CAN_FilterMode_IdList;//CAN_FilterMode_IdMask;  /* 屏敝模式 */\n\tCAN_FilterInitStructure.FilterScale \t= CAN_FILTERSCALE_32BIT; ///* 32位 */\n\t \n\tCAN_FilterInitStructure.FilterIdHigh \t\t\t= FILTER_MASK_H(filter_value);  \n\tCAN_FilterInitStructure.FilterIdLow \t\t\t= FILTER_MASK_L(filter_value)|CAN_ID_EXT;\n\tCAN_FilterInitStructure.FilterMaskIdHigh \t= FILTER_MASK_H(filter_mask);\n\tCAN_FilterInitStructure.FilterMaskIdLow \t= FILTER_MASK_L(filter_mask)|CAN_ID_EXT;\n\t  \n\tCAN_FilterInitStructure.FilterFIFOAssignment \t= CAN_FILTER_FIFO0;  ///* 能够通过该过滤器的报文存到fifo0中 */\n\tCAN_FilterInitStructure.FilterActivation = ENABLE;\n\tHAL_CAN_ConfigFilter(&hcan,&CAN_FilterInitStructure);\n\t\n\t/*===========================FIFO1 过滤=============================*/\n\t//多包接收\n\t//过滤组\n\t\t\t//判断地址是否为空\n\tif(can_addr != CAN_ADDR_NULL)\t\t//进行地址滤波\n\t{\n\t filter_value = MUTIL_SLAVE_FILTERID;\n\t filter_mask = MUTIL_SLAVE_MASK0;\n\t\t\n\t\t//如果地址不为空，加入地址滤波\n\t\tfilter_value  &= 0xFFFFFF00;\n\t\tfilter_value  |= can_addr;\n\t\tfilter_mask   &= 0xFFFFFF00;\n\t\tfilter_mask   |= 0x000000FF;\n\t}\n\t\n\tCAN_FilterInitStructure.FilterBank \t= 2;     /* 过滤器组 */\n\tCAN_FilterInitStructure.FilterMode \t\t= CAN_FILTERMODE_IDMASK;//CAN_FilterMode_IdList;//CAN_FilterMode_IdMask;  /* 屏敝模式 */\n\tCAN_FilterInitStructure.FilterScale \t= CAN_FILTERSCALE_32BIT; ///* 32位 */\n\t \n\tCAN_FilterInitStructure.FilterIdHigh \t\t\t= FILTER_MASK_H(filter_value);  \n\tCAN_FilterInitStructure.FilterIdLow \t\t\t= FILTER_MASK_L(filter_value)|CAN_ID_EXT;\n\tCAN_FilterInitStructure.FilterMaskIdHigh \t= FILTER_MASK_H(filter_mask);\n\tCAN_FilterInitStructure.FilterMaskIdLow \t= FILTER_MASK_L(filter_mask)|CAN_ID_EXT;\n\t  \n\tCAN_FilterInitStructure.FilterFIFOAssignment \t= CAN_FILTER_FIFO1;  ///* 能够通过该过滤器的报文存到fifo0中 */\n\tCAN_FilterInitStructure.FilterActivation = ENABLE;\n\tHAL_CAN_ConfigFilter(&hcan,&CAN_FilterInitStructure);\n\t\n\t//过滤组\n\t\t\t\t//判断地址是否为空\n\tif(can_addr != CAN_ADDR_NULL)\t\t//进行地址滤波\n\t{\n\t filter_value = MUTIL_SLAVE_FILTERID;\n\t filter_mask = MUTIL_SLAVE_MASK1;\n\t\t\n\t\t//如果地址不为空，加入地址滤波\n\t\tfilter_value  &= 0xFFFFFF00;\n\t\tfilter_value  |= can_addr;\n\t\tfilter_mask   &= 0xFFFFFF00;\n\t\tfilter_mask   |= 0x000000FF;\n\t}\n\t\n\tCAN_FilterInitStructure.FilterBank \t= 3;     /* 过滤器组 */\n\tCAN_FilterInitStructure.FilterMode \t\t= CAN_FILTERMODE_IDMASK;//CAN_FilterMode_IdList;//CAN_FilterMode_IdMask;  /* 屏敝模式 */\n\tCAN_FilterInitStructure.FilterScale \t= CAN_FILTERSCALE_32BIT; ///* 32位 */\n\n\tCAN_FilterInitStructure.FilterIdHigh \t\t\t= FILTER_MASK_H(filter_value);  \n\tCAN_FilterInitStructure.FilterIdLow \t\t\t= FILTER_MASK_L(filter_value)|CAN_ID_EXT;\n\tCAN_FilterInitStructure.FilterMaskIdHigh \t= FILTER_MASK_H(filter_mask);\n\tCAN_FilterInitStructure.FilterMaskIdLow \t= FILTER_MASK_L(filter_mask)|CAN_ID_EXT;\n\n\tCAN_FilterInitStructure.FilterFIFOAssignment \t= CAN_FILTER_FIFO1;  ///* 能够通过该过滤器的报文存到fifo0中 */\n\tCAN_FilterInitStructure.FilterActivation = ENABLE;\n\tHAL_CAN_ConfigFilter(&hcan,&CAN_FilterInitStructure);\n\t \n\t\n//\t//CAN1->IER |= CAN_IT_BOF|CAN_IT_FMP0|CAN_IT_ERR;\n//\t__HAL_CAN_ENABLE_IT(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING);\t//FIFO0消息挂起中断允许.\t \n//\t__HAL_CAN_ENABLE_IT(&hcan, CAN_IT_RX_FIFO1_MSG_PENDING);\t//FIFO0消息挂起中断允许.\t \t\n////  HAL_NVIC_SetPriority(CAN1_RX0_IRQn,1,2);    \t//抢占优先级1，子优先级2\n////  HAL_NVIC_EnableIRQ(CAN1_RX0_IRQn);          \t//使能中断\n\n\n//\tHAL_CAN_Start(&hcan);\n//\tHAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING);\n//\tHAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO1_MSG_PENDING);\n  /* USER CODE END CAN_Init 2 */\n\n}\n\n/**\n  * @brief SPI1 Initialization Function\n  * @param None\n  * @retval None\n  */\nstatic void MX_SPI1_Init(void)\n{\n\n  /* USER CODE BEGIN SPI1_Init 0 */\n\n  /* USER CODE END SPI1_Init 0 */\n\n  /* USER CODE BEGIN SPI1_Init 1 */\n\n  /* USER CODE END SPI1_Init 1 */\n  /* SPI1 parameter configuration*/\n  hspi1.Instance = SPI1;\n  hspi1.Init.Mode = SPI_MODE_MASTER;\n  hspi1.Init.Direction = SPI_DIRECTION_2LINES;\n  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;\n  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;\n  hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;\n  hspi1.Init.NSS = SPI_NSS_SOFT;\n  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;\n  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;\n  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;\n  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;\n  hspi1.Init.CRCPolynomial = 10;\n  if (HAL_SPI_Init(&hspi1) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /* USER CODE BEGIN SPI1_Init 2 */\n//\t__HAL_SPI_ENABLE(&hspi1);\n  /* USER CODE END SPI1_Init 2 */\n\n}\n\n/**\n  * @brief SPI2 Initialization Function\n  * @param None\n  * @retval None\n  */\nstatic void MX_SPI2_Init(void)\n{\n\n  /* USER CODE BEGIN SPI2_Init 0 */\n\n  /* USER CODE END SPI2_Init 0 */\n\n  /* USER CODE BEGIN SPI2_Init 1 */\n\n  /* USER CODE END SPI2_Init 1 */\n  /* SPI2 parameter configuration*/\n  hspi2.Instance = SPI2;\n  hspi2.Init.Mode = SPI_MODE_MASTER;\n  hspi2.Init.Direction = SPI_DIRECTION_2LINES;\n  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;\n  hspi2.Init.CLKPolarity = SPI_POLARITY_HIGH;\n  hspi2.Init.CLKPhase = SPI_PHASE_2EDGE;\n  hspi2.Init.NSS = SPI_NSS_SOFT;\n  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;\n  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;\n  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;\n  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;\n  hspi2.Init.CRCPolynomial = 10;\n  if (HAL_SPI_Init(&hspi2) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /* USER CODE BEGIN SPI2_Init 2 */\n\t__HAL_SPI_ENABLE(&hspi2);\n  /* USER CODE END SPI2_Init 2 */\n\n}\n\n/**\n  * @brief TIM2 Initialization Function\n  * @param None\n  * @retval None\n  */\nstatic void MX_TIM2_Init(void)\n{\n\n  /* USER CODE BEGIN TIM2_Init 0 */\n\n  /* USER CODE END TIM2_Init 0 */\n\n  TIM_MasterConfigTypeDef sMasterConfig = {0};\n  TIM_OC_InitTypeDef sConfigOC = {0};\n\n  /* USER CODE BEGIN TIM2_Init 1 */\n\n  /* USER CODE END TIM2_Init 1 */\n  htim2.Instance = TIM2;\n  htim2.Init.Prescaler = 72-1;\n  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;\n  htim2.Init.Period = 20000;\n  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;\n  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;\n  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;\n  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;\n  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  sConfigOC.OCMode = TIM_OCMODE_PWM1;\n  sConfigOC.Pulse = 0;\n  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;\n  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;\n  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /* USER CODE BEGIN TIM2_Init 2 */\n\n\tHAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3); \n  /* USER CODE END TIM2_Init 2 */\n  HAL_TIM_MspPostInit(&htim2);\n\n}\n\n/**\n  * @brief TIM3 Initialization Function\n  * @param None\n  * @retval None\n  */\nstatic void MX_TIM3_Init(void)\n{\n\n  /* USER CODE BEGIN TIM3_Init 0 */\n\n  /* USER CODE END TIM3_Init 0 */\n\n  TIM_MasterConfigTypeDef sMasterConfig = {0};\n  TIM_OC_InitTypeDef sConfigOC = {0};\n\n  /* USER CODE BEGIN TIM3_Init 1 */\n\n  /* USER CODE END TIM3_Init 1 */\n  htim3.Instance = TIM3;\n  htim3.Init.Prescaler = 71;\n  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;\n  htim3.Init.Period = 1000;\n  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;\n  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;\n  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;\n  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;\n  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  sConfigOC.OCMode = TIM_OCMODE_PWM1;\n  sConfigOC.Pulse = 1000;\n  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;\n  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;\n  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /* USER CODE BEGIN TIM3_Init 2 */\n\n\tHAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1); \n  /* USER CODE END TIM3_Init 2 */\n  HAL_TIM_MspPostInit(&htim3);\n\n}\n\n/**\n  * @brief USART1 Initialization Function\n  * @param None\n  * @retval None\n  */\nstatic void MX_USART1_UART_Init(void)\n{\n\n  /* USER CODE BEGIN USART1_Init 0 */\n\n  /* USER CODE END USART1_Init 0 */\n\n  /* USER CODE BEGIN USART1_Init 1 */\n\n  /* USER CODE END USART1_Init 1 */\n  huart1.Instance = USART1;\n  huart1.Init.BaudRate = 115200;\n  huart1.Init.WordLength = UART_WORDLENGTH_8B;\n  huart1.Init.StopBits = UART_STOPBITS_1;\n  huart1.Init.Parity = UART_PARITY_NONE;\n  huart1.Init.Mode = UART_MODE_TX_RX;\n  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;\n  huart1.Init.OverSampling = UART_OVERSAMPLING_16;\n  if (HAL_UART_Init(&huart1) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /* USER CODE BEGIN USART1_Init 2 */\n\t__HAL_UART_ENABLE(&huart1);\n  /* USER CODE END USART1_Init 2 */\n\n}\n\n/** \n  * Enable DMA controller clock\n  */\nstatic void MX_DMA_Init(void) \n{\n\n  /* DMA controller clock enable */\n  __HAL_RCC_DMA1_CLK_ENABLE();\n\n  /* DMA interrupt init */\n  /* DMA1_Channel1_IRQn interrupt configuration */\n  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);\n  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);\n\n}\n\n/**\n  * @brief GPIO Initialization Function\n  * @param None\n  * @retval None\n  */\nstatic void MX_GPIO_Init(void)\n{\n  GPIO_InitTypeDef GPIO_InitStruct = {0};\n\n  /* GPIO Ports Clock Enable */ \n  __HAL_RCC_GPIOC_CLK_ENABLE();\n  __HAL_RCC_GPIOD_CLK_ENABLE();\n  __HAL_RCC_GPIOA_CLK_ENABLE();\n  __HAL_RCC_GPIOB_CLK_ENABLE();\n\n  /*Configure GPIO pin Output Level */\n  HAL_GPIO_WritePin(MAIN_LED_GPIO_Port, MAIN_LED_Pin, GPIO_PIN_RESET);\n\t\n  /*Configure GPIO pin Output Level */\n  HAL_GPIO_WritePin(GPIOA, PTC_CTRL_Pin|ST25R_CS_Pin|BEEP_Pin, GPIO_PIN_RESET);\n\n  /*Configure GPIO pin Output Level */\n  HAL_GPIO_WritePin(GPIOB, MOTOR_POWER_Pin, GPIO_PIN_RESET);\n\t\n\tHAL_GPIO_WritePin(GPIOB, OLED_DC_Pin|OLED_RES1_Pin|OELD_RES2_Pin|OLED_CS2_Pin \n\t\t\t\t\t\t\t\t\t\t\t\t|CS_FLASH_Pin|OLED_CS1_Pin, GPIO_PIN_SET);\n\n \n\t  /*Configure GPIO pin : MAIN_LED_Pin */\n  GPIO_InitStruct.Pin = MAIN_LED_Pin;\n  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n  HAL_GPIO_Init(MAIN_LED_GPIO_Port, &GPIO_InitStruct);\n\t\n  /*Configure GPIO pins : PTC_CTRL_Pin ST25R_CS_Pin BEEP_Pin */\n  GPIO_InitStruct.Pin = PTC_CTRL_Pin|ST25R_CS_Pin|BEEP_Pin;\n  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n\n  /*Configure GPIO pin : ST25R_IRQ_Pin */\n  GPIO_InitStruct.Pin = ST25R_IRQ_Pin;\n  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  HAL_GPIO_Init(ST25R_IRQ_GPIO_Port, &GPIO_InitStruct);\n\n  /*Configure GPIO pins : OLED_DC_Pin OLED_RES1_Pin OELD_RES2_Pin OLED_CS2_Pin \n                           MOTOR_POWER_Pin CS_FLASH_Pin OLED_CS1_Pin */\n  GPIO_InitStruct.Pin = OLED_DC_Pin|OLED_RES1_Pin|OELD_RES2_Pin|OLED_CS2_Pin \n                          |MOTOR_POWER_Pin|CS_FLASH_Pin|OLED_CS1_Pin;\n  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);\n\n  /*Configure GPIO pin : HALL_Pin */\n  GPIO_InitStruct.Pin = HALL_Pin;\n  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  HAL_GPIO_Init(HALL_GPIO_Port, &GPIO_InitStruct);\n\n  /* EXTI interrupt init*/\n  HAL_NVIC_SetPriority(EXTI3_IRQn, 0, 0);\n  HAL_NVIC_EnableIRQ(EXTI3_IRQn);\n\n}\n\n/* USER CODE BEGIN 4 */\n\n/* USER CODE END 4 */\n\n/**\n  * @brief  This function is executed in case of error occurrence.\n  * @retval None\n  */\nvoid Error_Handler(void)\n{\n  /* USER CODE BEGIN Error_Handler_Debug */\n  /* User can add his own implementation to report the HAL error return state */\n\n  /* USER CODE END Error_Handler_Debug */\n}\n\n#ifdef  USE_FULL_ASSERT\n/**\n  * @brief  Reports the name of the source file and the source line number\n  *         where the assert_param error has occurred.\n  * @param  file: pointer to the source file name\n  * @param  line: assert_param error line source number\n  * @retval None\n  */\nvoid assert_failed(uint8_t *file, uint32_t line)\n{ \n  /* USER CODE BEGIN 6 */\n  /* User can add his own implementation to report the file name and line number,\n     tex: printf(\"Wrong parameters value: file %s on line %d\\r\\n\", file, line) */\n  /* USER CODE END 6 */\n}\n#endif /* USE_FULL_ASSERT */\n\n\n\n\n\n\n/*==================================================================================\n* 函 数 名： bsp_init\n* 参    数： None\n* 功能描述:  板级初始化\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-24 111301\n==================================================================================*/\nvoid bsp_init(uint8_t can_addr)\n{\n\tSystemClock_Config();\n\n\tMX_GPIO_Init();\n\n\tMX_DMA_Init(); \n\tMX_ADC1_Init();\n\tMX_CAN_Init(can_addr);\n\tMX_SPI1_Init();\n\tMX_SPI2_Init();\n\tMX_TIM2_Init();\n\tMX_TIM3_Init();\n\tMX_USART1_UART_Init();\n}\n\n/*==================================================================================\n* 函 数 名： systerm_init_complete\n* 参    数： None\n* 功能描述:  系统初始化完成\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-08 143228\n==================================================================================*/\nvoid systerm_init_complete(void)\n{\n\t\n\t//使能CAN总线\n\t__HAL_CAN_ENABLE_IT(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING);\t//FIFO0消息挂起中断允许.\t \n\t__HAL_CAN_ENABLE_IT(&hcan, CAN_IT_RX_FIFO1_MSG_PENDING);\t//FIFO0消息挂起中断允许.\t \n\tHAL_CAN_Start(&hcan);\n\tHAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING);\n\tHAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO1_MSG_PENDING);\n}\n",
							"origin_encoding": "GB2312",
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "device_lib/ST_RFID/hardware/ST25R3911/Src/main.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13132,
						"regions":
						{
						},
						"selection":
						[
							[
								4276,
								4294
							]
						],
						"settings":
						{
							"origin_encoding": "ASCII",
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "device_lib/ST_RFID/hardware/ST25R3911/Src/dispatcher.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 96065,
						"regions":
						{
						},
						"selection":
						[
							[
								38059,
								38059
							]
						],
						"settings":
						{
							"origin_encoding": "ASCII",
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 14,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "device_lib/ST_RFID/hardware/common/utils/Src/stream_dispatcher.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7932,
						"regions":
						{
						},
						"selection":
						[
							[
								2676,
								2676
							]
						],
						"settings":
						{
							"origin_encoding": "ASCII",
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "hardware/src/ex_device.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2449,
						"regions":
						{
						},
						"selection":
						[
							[
								1383,
								1383
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#include \"ex_device.h\"\n\n/*==================================================================================\n* 函 数 名： door_open\n* 参    数： None\n* 功能描述:  开门\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-19 163734\n==================================================================================*/\nvoid door_open(void)\n{\n\tMOTOR_ENABLE_OUT(); \t//开  留一定的余量，防止舵机卡到\n\tSERVO_SET_PWM(2400);\n\tHAL_Delay(500);\t\t\t\t//后期不能使用延时操作\n\tMOTOR_DISABLE_OUT()\t;\n}\n\n/*==================================================================================\n* 函 数 名： door_open\n* 参    数： None\n* 功能描述:  开门\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-19 164031\n==================================================================================*/\nvoid door_close(void)\n{\n\tSERVO_SET_PWM(10); \t\t//等待关, 留一定的余量，防止舵机卡到\n\tMOTOR_ENABLE_OUT();\n\tHAL_Delay(500);\t\t\t\t\t//后期不能使用延时操作\n\tMOTOR_DISABLE_OUT();\n}\n\n/*==================================================================================\n* 函 数 名： set_light_mode\n* 参    数： None\n* 功能描述:  设置照明灯状态和亮度\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-19 164031\n==================================================================================*/\nvoid set_light_mode(uint8_t type, uint8_t level)\n{\n\tLIGHT_ENABLE_OUT();\n\tfor(int i=0; i<=1000; i++)\n\t{\n\t\tLIGHT_DISABLE_OUT();\n\t\tLIGHT_SET_PWM(i)\t;\n\n\t\tLIGHT_ENABLE_OUT();\n\t\tHAL_Delay(10);\n\t}\n}\n\n/*==================================================================================\n* 函 数 名： get_door_state\n* 参    数： None\n* 功能描述:  获取门状态\n* 返 回 值： 0:关  0x1：开\n* 备    注： \n* 作    者：  xiaozh\n* 创建时间： 2019-09-24 124042\n==================================================================================*/\nuint8_t get_door_state(void)\n{\n\tif(READ_HALL_STATUE())\n\t{\n\t\treturn 0;\n\t}\n\telse \n\t{\n\t\treturn 0x01;\n\t}\n}\n\n/*==================================================================================\n* 函 数 名： set_debug_led_state\n* 参    数： None\n* 功能描述:  设置调试灯状态\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-04 141233\n==================================================================================*/\nvoid debug_led_control(uint8_t state)\n{\n\tif(state != 0)\n\t{\n\t MAIN_LED_GPIO_Port->BRR = (uint32_t)MAIN_LED_Pin;\n\t}\n\telse\n\t{\n\t MAIN_LED_GPIO_Port->BSRR = (uint32_t)MAIN_LED_Pin;\n\t}\n}\n\n\n \nvoid ex_device_test()\n{\n//\tset_light_mode(0,  0);\n\tdoor_open();\n\tHAL_Delay(1000);\n\tdoor_close();\n}\n\n\n",
							"origin_encoding": "GB2312",
							"revert_to_scratch": true,
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "hardware/inc/can_drv.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1274,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#ifndef  __CAN_DRV_H\n#define  __CAN_DRV_H\n#include <stdint.h>\n#include \"main.h\"\n\n\n#define  CAN_GLOBAL_ADDR\t\t\t0xFF\t\t//can总线全局地址\n#define  CAN_MASTER_ADDR\t\t\t0xAE\t\t//主节点地址\n#define  CAN_ADDR_NULL\t\t\t\t0xFE\t\t\t\t\t//空地址 \n#define  CAN_STD_ID\t\t\t\t\t\t0x12\t\t\t\t\t//标准帧ID\n#define  CAN_FRAME_TYPE\t\t\tCAN_ID_EXT\t\t//本网络中通信都使用扩展帧，波特率250kbps\n\n\n//从机过滤设置\n#define SIGNAL_SLAVE_FILTERID\t\t\t0x0000FF00\t\t//设置过滤，不接收从机数据,只接收主机地址\n#define SIGNAL_SLAVE_MASK\t\t\t\t\t0x0300AE00\t\t//设置掩码，不接收从机数据，只接收单帧数据\n\n\n#define MUTIL_SLAVE_FILTERID\t\t\t0x0300FF00\t\t//设置过滤，不接收从机数据,只接收主机地址 \n#define MUTIL_SLAVE_MASK0\t\t\t\t\t0x0100AE00\t\t//设置掩码，不接收从机数据，只接收单帧数据\n#define MUTIL_SLAVE_MASK1\t\t\t\t\t0x0200AE00\t\t//设置掩码，不接收从机数据，只接收单帧数据\n \n#define MAX_CAN_NUM\t\t\t\t\t\t\t8+1\t//数据域长度\n#define MAX_CACHE_NUM\t\t\t\t\t\t32\t//最大缓存池\n#define MAX_RX_CAN_NUM\t\t\t\t\t256\t\t//最大can接收返回buff\n\n\ntypedef union\n{\n\tstruct\n\t{\n\t\tuint32_t d_addr:8;\t\t\t//目的地址，接收方地址， 0xFF为广播\n\t\tuint32_t s_addr:8;\t\t  //源地址，发送方的地址\n\t\tuint32_t png_cmd:8;\t\t\t//命令字 \n\t\tuint32_t is_sigle:2;\t\t//是否连包，0：为单帧数据  1：连包数据 2:连包结尾\n\t\tuint32_t a_res:3;\t\t\t\t//可用保留\n\t\tuint32_t res:3;\t\t\t\t\t//保留位\n\t}_bit;\n\t\n\tuint32_t EX_ID;\t\t\t//29位\n}_Ex_id,*_pEx_id;\n\ntypedef struct\n{\n\t_Ex_id  ex_id;\t\t//扩展帧ID\t\n\t\n\tuint8_t  byte_count;\n\tuint8_t  data[MAX_CAN_NUM];\n}_Can_Msg,*_pCan_Msg;\n \n\n \nuint8_t  can_sed_pkg_without_cache(void* can_msg); \n#endif\n",
							"origin_encoding": "GB2312",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 515.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "hardware/inc/ex_device.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1697,
						"regions":
						{
						},
						"selection":
						[
							[
								595,
								600
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#ifndef  __EX_DEVICE_H\n#define  __EX_DEVICE_H\n\n#include \"main.h\"\n  \n \n#define   LIGHT_ENABLE_OUT()\t\t\t\tdo { \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t TIM3->CCER &= ~(TIM_CCER_CC1E << TIM_CHANNEL_1);\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t TIM3->CCER |=  (uint32_t)(TIM_CCx_ENABLE << TIM_CHANNEL_1);\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} while(0)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n#define   LIGHT_DISABLE_OUT()\t\t\t\tdo { \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t TIM3->CCER &= ~(TIM_CCER_CC1E << TIM_CHANNEL_1);\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTIM3->CCER |=  (uint32_t)(TIM_CCx_DISABLE << TIM_CHANNEL_1);\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} while(0)\n\n#define  LIGHT_SET_PWM(value)\t\t\t\t\t(TIM3->CCR1 = value)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\n\n#define  MOTOR_ENABLE_OUT()\t\t\t\t\t\tdo{GPIOB->BSRR = GPIO_PIN_3;}while(0)\n#define  MOTOR_DISABLE_OUT()\t\t\t\t\tdo{GPIOB->BSRR = (uint32_t)GPIO_PIN_3 << 16u;}while(0)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n#define   SERVO_ENABLE_OUT()\t\t\t\tdo { \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t TIM2->CCER &= ~(TIM_CCER_CC1E << TIM_CHANNEL_3);\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t TIM2->CCER |=  (uint32_t)(TIM_CCx_ENABLE << TIM_CHANNEL_3);\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} while(0)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n#define   SERVO_DISABLE_OUT()\t\t\t\tdo { \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t TIM2->CCER &= ~(TIM_CCER_CC1E << TIM_CHANNEL_3);\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTIM2->CCER |=  (uint32_t)(TIM_CCx_DISABLE << TIM_CHANNEL_3);\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} while(0)\n\n#define  SERVO_SET_PWM(value)\t\t\t\t(TIM2->CCR3 = value)\n \n#define READ_HALL_STATUE()\t\t\t\t\tHAL_GPIO_ReadPin(HALL_GPIO_Port, HALL_Pin)\t\t//1:CLOSE  0:OPEN\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ntypedef enum\n{\n\tBright_to_Dark=0,\t\t//从亮到灭\n\tDark_to_Bright,\t\t//从灭到亮\n\t\n}_Light_Type;\n\n\nuint16_t get_temperature(void); //获取温度值\nuint8_t get_door_state(void);\t//获取门状态\nvoid door_open(void);\t\nvoid door_close(void);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n#endif\n",
							"origin_encoding": "GB2312",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 11,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13759,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										176,
										190
									],
									[
										512,
										526
									],
									[
										602,
										616
									],
									[
										696,
										710
									],
									[
										1122,
										1136
									],
									[
										1618,
										1632
									],
									[
										1945,
										1959
									],
									[
										2158,
										2172
									],
									[
										2231,
										2245
									],
									[
										2311,
										2325
									],
									[
										2389,
										2403
									],
									[
										2752,
										2766
									],
									[
										3087,
										3101
									],
									[
										3462,
										3476
									],
									[
										3482,
										3496
									],
									[
										3991,
										4005
									],
									[
										4099,
										4113
									],
									[
										4197,
										4211
									],
									[
										4299,
										4313
									],
									[
										4409,
										4423
									],
									[
										4453,
										4467
									],
									[
										4949,
										4963
									],
									[
										5438,
										5452
									],
									[
										5923,
										5937
									],
									[
										6013,
										6027
									],
									[
										6555,
										6569
									],
									[
										6974,
										6988
									],
									[
										7311,
										7325
									],
									[
										7518,
										7532
									],
									[
										7649,
										7663
									],
									[
										7773,
										7787
									],
									[
										8129,
										8143
									],
									[
										8555,
										8569
									],
									[
										9083,
										9097
									],
									[
										9472,
										9486
									],
									[
										9768,
										9782
									],
									[
										9941,
										9955
									],
									[
										10021,
										10035
									],
									[
										10099,
										10113
									],
									[
										10538,
										10552
									],
									[
										10650,
										10664
									],
									[
										10694,
										10708
									],
									[
										11177,
										11191
									],
									[
										11197,
										11211
									],
									[
										11609,
										11623
									],
									[
										12118,
										12132
									],
									[
										12235,
										12249
									],
									[
										12734,
										12748
									],
									[
										12824,
										12838
									],
									[
										13388,
										13402
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								7316,
								7316
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 2,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 1931.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "Inc/main.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3175,
						"regions":
						{
						},
						"selection":
						[
							[
								2714,
								2730
							]
						],
						"settings":
						{
							"origin_encoding": "ASCII",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "hardware/inc/led_beep.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 268,
						"regions":
						{
						},
						"selection":
						[
							[
								180,
								188
							]
						],
						"settings":
						{
							"origin_encoding": "ASCII",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 25,
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "hardware/src/led_beep.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 629,
						"regions":
						{
						},
						"selection":
						[
							[
								21,
								0
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#include \"led_beep.h\"\n\n \nvoid led_beep(void)\n{\n//\tBEEP_ON();\n//\tHAL_Delay(500);\n//\tBEEP_OFF();\n//\t\n//\tLIGHT_ENABLE_OUT()\t;\n//\tfor(int i=0; i<=1000; i++)\n//\t{\n////\t\tLIGHT_DISABLE_OUT()\t;\n//\t\t\tLIGHT_SET_PWM(i)\t;\n//\t\t\n////\t\t\tLIGHT_ENABLE_OUT();\n//\t\tHAL_Delay(10);\n//\t}\n//\t\n//\tSERVO_ENABLE_OUT();\n\n//\t\t\tMOTOR_ENABLE_OUT(); \t//开\n//\t\t\tSERVO_SET_PWM(10);\n//\t\t\tHAL_Delay(500);\n//\t\t\tMOTOR_DISABLE_OUT()\t;\n\t \n//\t\tSERVO_SET_PWM(600); \t\t//等待关\n//\t\tMOTOR_ENABLE_OUT();\n//\t\tHAL_Delay(200);\n//\t\tMOTOR_DISABLE_OUT()\t;\n\t \n//\tif(!READ_HALL_STATUE())\n//\t{\n//\t\tLIGHT_ENABLE_OUT()\t;\n//\t}\n//\telse\n//\t{\n//\t\tLIGHT_DISABLE_OUT()\t;\n//\t}\n\tHAL_Delay(100);\n}\n",
							"origin_encoding": "GB2312",
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 15,
					"file": "application/src/command.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6590,
						"regions":
						{
						},
						"selection":
						[
							[
								3123,
								3123
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#include \"command.h\"\n#include \"includes.h\"\n\nextern _App_Param mApp_Param;\n\n\nstatic uint8_t check_can_frame(void *ret_msg);\nstatic void can_read_parse(void* ret_msg);\nstatic void can_write_parse(void* ret_msg);\nstatic void can_update_tag_info(void* ret_msg);\nstatic uint8_t can_simply_ack(uint8_t cmd, uint8_t state);\nstatic void cfg_can_addr(void* ret_msg);\n\n#define SIMPLY_ACK(state) \t\t\tcan_simply_ack(pmsg->ex_id._bit.png_cmd, state)\n\n/*==================================================================================\n* 函 数 名： can_frame_parse\n* 参    数： None\n* 功能描述:  can协议解析\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-09-24 162950\n==================================================================================*/\nvoid can_frame_parse(void* ret_msg)\n{\n\t_pRet_Msg pmsg = ret_msg;\n\t//判断数据合法性\n\tif((pmsg->ex_id._bit.d_addr != mApp_Param.can_addr)&&(pmsg->ex_id._bit.d_addr != CAN_GLOBAL_ADDR)&&(mApp_Param.can_addr != CAN_ADDR_NULL))\t//判断是否为自己的地址\n\t{\n\t\treturn ;\n\t}\n\t\n\t//判断数据合法性\n\tif(pmsg->ex_id._bit.is_sigle != 0)\t\t//如果不为单帧数据\n\t{\n\t\t//进行CRC校验\n\t\tif(check_can_frame(ret_msg) != 0)\t//检验成功\n\t\t{\n\t\t\treturn ;\n\t\t}\n\t}\n\t\n\tdebug_print(\"can_rev,\");\n\tdebug_print(\"ex_id:%4x, \", pmsg->ex_id.EX_ID);\n\tdebug_print(\"lens=0x%02x, \", pmsg->byte_count);\n\tdebug_print(\"rev_data:\");\n\tdebug_print_hex(pmsg->data, pmsg->byte_count);\n\tdebug_print(\"\\n\");\n\t \n\t//进行协议解析\n\tswitch(pmsg->ex_id._bit.png_cmd)\n\t{\n\t\tcase get_hb_cmd:\t//查询心跳\n\t\t{\n\t\t\tcan_sed_heartbeat();\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase read_cmd:\t//状态读取\n\t\t{\n\t\t\tcan_read_parse(pmsg);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase write_cmd:\t//写\n\t\t{\n\t\t\tcan_write_parse(pmsg);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase update_tag_info:\n\t\t{\n\t\t\tcan_update_tag_info(pmsg);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t/*============================地址分配==========================*/\n\t\tcase config_can_addr:\t//配置CAN总线地址\n\t\t{\n\t\t\tcfg_can_addr(ret_msg);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdefault:\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n  \n/*==================================================================================\n* 函 数 名： check_can_frame\n* 参    数： None\n* 功能描述:  校验CAN数据数据是否完整\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-29 145723\n==================================================================================*/ \nstatic uint8_t check_can_frame(void *ret_msg)\n{\n\t_pRet_Msg pmsg = ret_msg;\n\tuint16_t crc_16 = 0; \n\t\t\n\t//判断是否是自己的数据\n\t\t//进行数据校验\n\tif((crc_16 = crc16_ccitt(pmsg->data, pmsg->byte_count-2)) == *(uint16_t *)(pmsg->data+pmsg->byte_count-2))\t//判断CRC校验\n\t{\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\t\t\n\t\tprintf(\"crc is error, crc = %04x, data[crc]=%2X\\n\",crc_16, *(uint16_t *)(pmsg->data+pmsg->byte_count-2));\n\t\treturn 0x82;\n\t}\n}\n\n/*==================================================================================\n* 函 数 名： can_sed_heartbeat\n* 参    数： None\n* 功能描述:  发送心跳包\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-24 121722\n==================================================================================*/\nvoid can_sed_heartbeat(void)\n{\n\tuint8_t sed_buff[8] = {0}; \n\tuint16_t temp = 0;\n\t \n\tsed_buff[0] = (get_door_state() & 0x03);\t//门状态\n\t\n\ttemp = get_adc_temp();\n\tsed_buff[1] = (uint8_t)((temp>>8)&0x00FF);\t//温度\n\tsed_buff[2] = (uint8_t)((temp)&0x00FF);\t\t\t//温度\n\t\n\ttemp = get_adc_ev();\n\tsed_buff[3] = (uint8_t)((temp>>8)&0x00FF);\t//电流\n\tsed_buff[4] = (uint8_t)((temp)&0x00FF);\t\t\t//电流 \n\tsed_buff[5] = SOFT_VERSION;\t//软件版本\n\tsed_buff[6] = mApp_Param.hard_ver;\t//硬件版本\n\tsed_buff[7] = get_total_tag_num();\t//标签总个数\n\t \n\tcan_sed_link_pkg(get_hb_cmd, CAN_MASTER_ADDR, sed_buff, 8);\n}\n\n/*==================================================================================\n* 函 数 名： can_simply_ack\n* 参    数： None\n* 功能描述:  can命令简单响应\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-08 122358\n==================================================================================*/\nstatic uint8_t can_simply_ack(uint8_t cmd, uint8_t state)\n{\n\tuint8_t sed_buff[1] = {0};  \n\n\tsed_buff[0] = state;\t//门状态\n\n\tcan_sed_link_pkg(cmd, CAN_MASTER_ADDR, sed_buff, 1);\n\n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： can_read_parse\n* 参    数： None\n* 功能描述:  can协议解析\n* 返 回 值： None\n* 备    注： 默认间隔10ms进行接收数据解析\n* 作    者： xiaozh\n* 创建时间： 2019-09-23 180348\n==================================================================================*/\nstatic void can_read_parse(void* ret_msg)\n{\n\t\n}\n\n/*==================================================================================\n* 函 数 名： can_update_tag_info\n* 参    数： None\n* 功能描述:  can更新标签信息\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-30 151308\n==================================================================================*/\nstatic void can_update_tag_info(void* ret_msg)\n{\n\t_pRet_Msg pmsg = ret_msg;\n\n\t//判断数据帧中协议带的标签信息\n\ttag_info_param_ack(pmsg->data, pmsg->byte_count);\n\t\n}\n\n\n/*==================================================================================\n* 函 数 名： cfg_can_addr\n* 参    数： None\n* 功能描述:  配置总线地址\n* 返 回 值： None\n* 备    注： 配置地址\n* 作    者： xiaozh\n* 创建时间： 2019-11-08 114953\n==================================================================================*/\nstatic void cfg_can_addr(void* ret_msg)\n{ \n\t_pRet_Msg pmsg = ret_msg;\n\t\n\tprintf(\"entry cfg_can_addr\\n\");\n\t//校验数据帧是否合法\n\tif(pmsg->data[0] == 0xAA)\t//判读固定字\n\t{\n\t\tif((crc8(pmsg->data, 3) == pmsg->data[3])&&(pmsg->data[1]+pmsg->data[2] == 0xFF))\t\t//校验是否合法\n\t\t{\n\t\t\t//配置地址参数\n\t\t\tconfig_mcan_addr(pmsg->data[1]);\n\t\t\t\n\t\t\tprintf(\"addr check is ok! addr=%d \\n\", pmsg->data[1]);\n\t\t\t//回复主机点配置成功\n\t\t\tSIMPLY_ACK(0x01);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//回复主机点配置失败\n\t\t\tSIMPLY_ACK(0x81);\n\t\t}\n\t}\n}\n\n/*==================================================================================\n* 函 数 名： can_write_parse\n* 参    数： None\n* 功能描述:  can协议解析\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-09-23 180348\n==================================================================================*/\nstatic void can_write_parse(void* ret_msg)\n{\n\t_pRet_Msg pmsg = ret_msg;\n\tswitch(pmsg->data[0])\t\t//查询索引操作\n\t{\n\t\tcase box_control_cmd:\t\t//box电源控制控制\n\t\t{ \n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase led_control_cmd:\t//LED灯控制\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase heat_control_cmd:\t//加热控制\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase screen_control_cmd:\t//屏幕操作\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase reader_control_cmd:\t//读写器\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase door_control_cmd:\t\t//门控制\n\t\t{\n\t\t\tif(pmsg->data[1] & 0x01)\t\t//1开\n\t\t\t{\n\t\t\t\tdoor_open();\n\t\t\t}\n\t\t\telse if(pmsg->data[1] & 0x02)\t//等待关关\n\t\t\t{\n\t\t\t\tdoor_close();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase beep_control_cmd:\t//蜂鸣器控制\n\t\t{\n\t\t\tif(pmsg->data[1] & 0x01)\t\t//1开\n\t\t\t{\n\t\t\t\tBEEP_ON();\n\t\t\t}\n\t\t\telse\t//关\n\t\t\t{\n\t\t\t\tBEEP_OFF();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcase display_cmd:\t//显示命令\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdefault:\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n",
							"origin_encoding": "GB2312",
							"revert_to_scratch": false,
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 20,
					"type": "text"
				},
				{
					"buffer": 16,
					"file": "application/src/comm_can.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9183,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#include \"comm_can.h\" \n#include \"crc.h\"\n#include \"can_def_fifo.h\"\n#include \"includes.h\"\n\n\nstatic _Mutil_Ring \t mMutil_Ring[MAX_MUTIL_ITEM_NUM];\t\t//多包接收 \nstatic _Can_Instance mCan_Instance;\n \nstatic _Can_Msg can_sed_fifo[CAN_MAX_CACHE_LEN];\t//can发送缓存\nstatic _Can_Msg can_rev_fifo[CAN_MAX_CACHE_LEN];\t//can接收缓存（单帧）\nstatic uint64_t mutil_mark_table[64] = {0};\n\n#define ID_MASK\t\t\t0xFCFFFFFF\n#define COMPARE_ID(ID1, ID2) (((ID1&ID_MASK) == (ID2&ID_MASK))?(1):(0))\t\t//对比两个ID是否相同，长包\n\n/*==================================================================================\n* 函 数 名： can_instance_init\n* 参    数： None\n* 功能描述:  can初始化\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-28 170617\n==================================================================================*/\nvoid can_instance_init(void)\n{\n\t//初始化函数接口\n\tmCan_Instance.p_ffunc\t= pCan_Fifo_Func,\n\t\n\t//发送接收缓存初始化（单帧） \n\t mCan_Instance.Sed_Fifo = mCan_Instance.p_ffunc->init_m(can_sed_fifo, CAN_MAX_CACHE_LEN);\n\t mCan_Instance.Rcv_Fifo = mCan_Instance.p_ffunc->init_m(can_rev_fifo, CAN_MAX_CACHE_LEN); \n\t\n\t//长帧接收初始化\n\tmCan_Instance.pMutil_Fifo = mMutil_Ring;\n\t\n\tfor(int i=0; i<MAX_MUTIL_ITEM_NUM; i++)\n\t{\n\t\tmMutil_Ring[i].ex_id.EX_ID = 0;\n\t\tmMutil_Ring[i].in_use = 0;\n\t\tmMutil_Ring[i].is_complete = 0;\n\t\tmMutil_Ring[i].real_mark = 0;\n\t\tmemset(mMutil_Ring[i].r_data, 0, sizeof(mMutil_Ring[i].r_data));\n\t}\n\t \n\tfor(int i=0; i<64; i++)\n\t{\n\t\tfor(int j=0; j<i+1; j++)\n\t\t{\n\t\t\tmutil_mark_table[i] |= (0x0000000000000001<<j);\t\t//空间换时间\n\t\t}\n\t} \n}\n \n/*==================================================================================\n* 函 数 名： find_avalib_node\n* 参    数： None\n* 功能描述:  查找可以节点\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-28 161141\n==================================================================================*/\nstatic uint8_t find_null_node(void)\n{\n\t//查询可用空节点索引\n\tfor(int i=0; i<MAX_MUTIL_ITEM_NUM; i++)\t//从后往前查找可用的ID号\n\t{\n\tif(mMutil_Ring[i].in_use  == 0)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\t  \n\treturn 0xFF;\t//空，没有可用\n}\n\n/*==================================================================================\n* 函 数 名： delete_item_node\n* 参    数： None\n* 功能描述:  清空节点\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-28 161141\n==================================================================================*/\nstatic uint8_t delete_item_node(uint8_t index)\n{  \n\t  //清空缓存\n\tmMutil_Ring[index].in_use = 0;\t//删除不合法帧 \n\tmMutil_Ring[index].is_complete = 0;\n\tmMutil_Ring[index].ex_id.EX_ID = 0;\n\tmMutil_Ring[index].real_mark = 0;\n\tmMutil_Ring[index].r_len = 0;\n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： item_is_exist\n* 参    数： None\n* 功能描述:  查看是否已经存在\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-28 161141\n==================================================================================*/\nstatic uint8_t item_is_exist(uint32_t ex_id)\n{\n\tuint8_t ret_index = 0xFF;\t//返回的节点索引\n\t_pEx_id pmsg = (_pEx_id)&ex_id; \n\t\n\t//查询当前地址是否已经有缓存帧\n\tfor(int j=0; j<MAX_MUTIL_ITEM_NUM; j++)\t//从后往前查找可用的ID号\n\t{ \n\t\tif(COMPARE_ID(mMutil_Ring[j].ex_id.EX_ID , ex_id))\t//判断ID是否相同\n\t\t{\n\t\t\tret_index = j;\n\t\t}\n\t}\n\t\n\t//没有接收完成的包，丢了结尾帧情况\n\tif(ret_index == 0xFF)\n\t{\n\t\tfor(int i=0; i<MAX_MUTIL_ITEM_NUM; i++)\t//从后往前查找可用的ID号\n\t\t{\n\t\t\tif(mMutil_Ring[i].ex_id._bit.s_addr == pmsg->_bit.s_addr)\t//如果存在相同地址\n\t\t\t{\n\t\t\t\tif((mMutil_Ring[i].is_complete == 0)&&(mMutil_Ring[i].in_use != 0))\t//没有接收完成\n\t\t\t\t{\n\t\t\t\t\t//直接覆盖没有接收完整节点\n\t\t\t\t\tmMutil_Ring[i].ex_id.EX_ID = ex_id;\n\t\t\t\t\tmMutil_Ring[i].real_mark = 0;\n\t\t\t\t\tmMutil_Ring[i].r_len = 0;\n\t\t\t\t\tret_index = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t \n\treturn ret_index;\t//空，没有可用\n}\n\n/*==================================================================================\n* 函 数 名： can_recv_frame\n* 参    数： _pCan_Msg\n* 功能描述:  can总线数据接收\n* 返 回 值： None\n* 备    注： 在中断\n* 作    者： xiaozh\n* 创建时间： 2019-10-28 154449\n==================================================================================*/\nuint8_t can_recv_mutil_frame(void *can_msg)\n{\n\tuint8_t new_index = 0;\t//申请索引\n\t_pCan_Msg pmsg = can_msg;\n\n\tif(pmsg->ex_id._bit.is_sigle == 0)\t//帧错误\n\t{\n\t\treturn 0x81;\n\t}\n\telse\n\t{\n\t\t//判断当前id是否存在\n\t\tif((new_index = item_is_exist(pmsg->ex_id.EX_ID)) == 0xFF)\n\t\t{\n\t\t\t//不存在，则申请新表\n\t\t\tnew_index = find_null_node();\n\n\t\t\t//保存到缓存\n\t\t\tmMutil_Ring[new_index].in_use = 0x01;\t//使用中\n\t\t\tmMutil_Ring[new_index].ex_id.EX_ID = pmsg->ex_id.EX_ID;\n\t\t\tmMutil_Ring[new_index].r_len = (pmsg->byte_count-1);\n\t\t\tmemcpy(mMutil_Ring[new_index].r_data, pmsg->data+1, pmsg->byte_count-1);\t\n\t\t\t//标记接收\n\t\t\tmMutil_Ring[new_index].real_mark = (0x0000000000000001<<pmsg->data[0]);\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//已经存在\n\n\t\t\t//保存到缓存\n\t\t\tmMutil_Ring[new_index].in_use = 0x01;\t//使用中\n\t\t\tmMutil_Ring[new_index].r_len += (pmsg->byte_count-1);\n\t\t\tmemcpy(mMutil_Ring[new_index].r_data+pmsg->data[0]*7, pmsg->data+1, pmsg->byte_count-1);\t\n\t\t\t//标记接收\n\t\t\tmMutil_Ring[new_index].real_mark |= (0x0000000000000001<<pmsg->data[0]);\n\n\t\t\t//判断是否为末尾帧\n\t\t\tif(pmsg->ex_id._bit.is_sigle == 0x02)\t//末尾帧\n\t\t\t{\n\t\t\t\tif(mMutil_Ring[new_index].real_mark == mutil_mark_table[pmsg->data[0]])\n\t\t\t\t{\n\t\t\t\t\tmMutil_Ring[new_index].is_complete = 0x01;\t//接收完成\n\t\t\t\t\tmMutil_Ring[new_index].ex_id._bit.is_sigle = 0x03;\t//接收完成\n\t\t\t\t\t//CRC校验留在协议解析，防止过多占用中断\n\t\t\t\t\tprintf(\"rev complete\\n\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//清空节点\n\t\t\t\t\tdelete_item_node(new_index);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： can_recv_frame\n* 参    数： _pCan_Msg\n* 功能描述:  can总线数据接收\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-28 154449\n==================================================================================*/\nuint8_t can_recv_signal_frame(void *can_msg)\n{\n\tmCan_Instance.p_ffunc->push(mCan_Instance.Rcv_Fifo, can_msg);\n\t\n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： can_pop_one_frame\n* 参    数： _pRet_Msg\n* 功能描述:  can总线数据接收\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-28 154449\n==================================================================================*/\nuint8_t can_pop_one_frame(void *ret_msg)\n{\n\t_pRet_Msg pmsg = ret_msg;\n\t\n\t//先查询长帧\n\tfor(int i=0; i<MAX_MUTIL_ITEM_NUM; i++)\t//从后往前查找可用的ID号\n\t{\n\t\tif(mMutil_Ring[i].is_complete == 0x01)\n\t\t{\n\t\t\tpmsg->ex_id.EX_ID = mMutil_Ring[i].ex_id.EX_ID;\n\t\t\tpmsg->byte_count = mMutil_Ring[i].r_len;\n\t\t\tmemcpy(pmsg->data, mMutil_Ring[i].r_data,  mMutil_Ring[i].r_len);\n\n\t\t\t//清空节点\n\t\t\tdelete_item_node(i);\n\t\t\treturn pmsg->byte_count;\n\t\t}\n\t}\n\t\n\t//查询短帧 \n\tif(\tmCan_Instance.p_ffunc->pop(mCan_Instance.Rcv_Fifo, ret_msg) != 0) \n\t{\n\t\t//查找成功\n\t\treturn pmsg->byte_count;\n\t}\n\t\n\treturn 0xFF;\n}\n\n/*==================================================================================\n* 函 数 名： can_sed_loop_check\n* 参    数： None\n* 功能描述:  CAN循环检测是否有发送的数据\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-10-28 171529\n==================================================================================*/\nvoid can_sed_loop_check(void)\n{\n\t_Can_Msg can_msg;\n\n\t//检查是否为空\n\tif(\tmCan_Instance.p_ffunc->pop(mCan_Instance.Sed_Fifo, &can_msg))\t//如果不为空\n\t{\n\t\t//屏蔽全局中断\n\t\t\n\t\t//获取数据\n//\t\tmCan_Instance.p_ffunc->pop(mCan_Instance.Sed_Fifo, &can_msg);\n\t\t//开启全局中断\n\n\t\t//发送数据\n\t\t can_sed_pkg_without_cache(&can_msg);\n\t}\n}\nextern _App_Param mApp_Param;\n/*==================================================================================\n* 函 数 名： can_sed_link_pkg\n* 参    数： None\n* 功能描述:  发送连包\n* 返 回 值： None\n* 备    注： \n* 作    者：  xiaozh\n* 创建时间： 2019-09-25 162917\n==================================================================================*/\nuint8_t can_sed_link_pkg(uint8_t host_cmd, uint8_t d_addr, uint8_t* buff, uint16_t len)\n{\n\t_Can_Msg c_msg;\n\tuint8_t count = 1;\n\tuint8_t pkg_step = 0;\n\tuint16_t s_len = len;\n\tuint16_t crc16_result = 0;\n\tuint8_t sed_buff[256] = {0};\n\t\n\tprintf(\"can_sed_link_pkg\\n\");\n\tif(s_len > 254*7)\n\t{\n//\t\tdebug_print(\"超过can总线最大发包能力\\n\");\n\t\treturn 0x81;\n\t}\n\t\n\t//当本节点没有分配CAN总线地址时候，只允许发送心跳命令\n\tif((mApp_Param.can_addr == CAN_ADDR_NULL)&&(host_cmd != get_hb_cmd))\t\t//空地址\n\t{\n\t\treturn 0x82;\t//当前节点地址为空\n\t}\n\t\n\tc_msg.ex_id.EX_ID = 0;\n\tc_msg.ex_id._bit.d_addr = d_addr;\t//目的地址\n\tc_msg.ex_id._bit.s_addr = MSELF_CAN_ADDR;\t//自己地址\n\tc_msg.ex_id._bit.png_cmd = host_cmd;\t\n\t\n\t//判断是否连包\n\tif(s_len <= 8)\n\t{\n\t\tc_msg.byte_count = s_len;\n\t\tmemset(c_msg.data, 0, 8);\n\t\tfor(int j=0; j<s_len; j++)\n\t\t{\n\t\t\tc_msg.data[j] = buff[j]; \n\t\t}\n\t\t\n\t\tmCan_Instance.p_ffunc->push(mCan_Instance.Sed_Fifo, &c_msg); \n\t}\n\telse\n\t{\n\t\tc_msg.ex_id._bit.is_sigle = 0x01;\t\t//连包数据\n\t\ts_len = len+2;\t//增加CRC16\n\t\t\n\t\tmemcpy(sed_buff, buff, len);\n\t\t\n\t\t//计算CRC16\n\t\tcrc16_result = crc16_ccitt(buff, len);\n\t\t\n\t\tsed_buff[len] = (uint8_t)((crc16_result>>0)&0x00FF); \n\t\tsed_buff[len+1] = (uint8_t)((crc16_result>>8)&0x00FF);\n\t  \n\t\twhile(s_len > 0)\n\t\t{\n\t\t\tcount = 0x01;\n\t\t\tc_msg.data[0] = pkg_step++;\n\n\t\t\t//判断是否为最后一帧数据\n\t\t\tif(s_len  <= 7)\n\t\t\t{\n\t\t\t\tc_msg.byte_count = s_len+1;\n\t\t\t\tc_msg.ex_id._bit.is_sigle = 0x02;\t\t//连包结尾数据\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc_msg.byte_count = 8; \n\t\t\t}\n\n\t\t\tfor(int j=0; j<c_msg.byte_count; j++)\n\t\t\t{\n\t\t\t\tc_msg.data[count++] = sed_buff[(pkg_step-1)*7+j];\n\t\t\t}\n\t\t\t\n\t\t\ts_len -= (c_msg.byte_count-1);\n\n\t\t\t//填充数据 \n\t\t\tmCan_Instance.p_ffunc->push(mCan_Instance.Sed_Fifo, &c_msg);\n\t\t}\n\t}\n\t \n\treturn 0;\n}\n\n\n",
							"origin_encoding": "GB2312",
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 19,
					"type": "text"
				},
				{
					"buffer": 17,
					"file": "hardware/src/adc_drv.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3626,
						"regions":
						{
						},
						"selection":
						[
							[
								1983,
								1983
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#include \"adc_drv.h\"\n#include \"main.h\"\n\nextern ADC_HandleTypeDef hadc1;\n\n\ntypedef struct\n{\n\tuint8_t is_complete;\t\t//是否扫描完成  0：未完成   1：完成一次扫描\n\tuint32_t temp_adc_value;\t\t//温度adc值\n\tuint32_t ev_adc_value;\t\t\t//电流值\n\t\n\tuint32_t adc_buff[MAX_ACD_NUM];\t\t//最大采集缓存，两个通道，每个通道采集10次，求平均\n}_Adc_Info, *_pAdc_Info;\n\n \n_Adc_Info mAdc_Info = \n{\n\t.is_complete\t\t\t= 0,\n};\n\n \nvoid  HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//4\n{ \n\t//关闭中断\n\t HAL_ADC_Stop_DMA(hadc);\n\t\n\t mAdc_Info.is_complete = 0x01;\t//完成一次扫描\n}\n\n/*==================================================================================\n* 函 数 名： start_once_conv\n* 参    数： None\n* 功能描述:  使能数据采集\n* 返 回 值： None\n* 备    注： 100ms采集一次\n* 作    者： xiaozh\n* 创建时间： 2019-09-23 185058\n==================================================================================*/\nvoid start_once_conv(void)\n{ \n  HAL_ADC_Start_DMA(&hadc1, mAdc_Info.adc_buff, MAX_CONV_NUM);\n}\n\n/*==================================================================================\n* 函 数 名： adc_filter_conver\n* 参    数： None\n* 功能描述:  ADC滤波算法\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2017-2-20 \n==================================================================================*/\nuint16_t adc_filter_conver(uint16_t* AdcBuff,uint8_t Len)\n{\n\tuint8_t count,i,j;\n\tuint64_t  sum=0;\n\tuint16_t temp  = 0;\n\t\n   for (j=0;j<Len-1;j++)\n   {\n      for (i=0;i<Len-j;i++)\n      {\n         if (AdcBuff[i] < AdcBuff[i+1])\n         {\n            temp = AdcBuff[i];\n            AdcBuff[i] = AdcBuff[i+1]; \n             AdcBuff[i+1] = temp;\n         }\n      }\n   }\n\t \n   for(count=1;count<Len-1;count++)\n      sum += AdcBuff[count];\n\t \n   return (uint16_t)(sum/(Len-2));\n}\n\n/*==================================================================================\n* 函 数 名： adc_conver_refresh\n* 参    数： None\n* 功能描述:  ADC转换值更新\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-24 105740\n==================================================================================*/\nvoid adc_conver_refresh(void)\n{\n\tuint16_t temp_adc_buff[16] = {0};\n\tuint16_t ev_adc_buff[16] = {0};\n\t\n\tfor(int i=0,j=0; i<MAX_CONV_NUM/2; i++)\n\t{  \n\t\ttemp_adc_buff[i] = mAdc_Info.adc_buff[j++];\n\t\tev_adc_buff[i] = mAdc_Info.adc_buff[j++];\n\t}\n\t\n\t//软件滤波\n\tmAdc_Info.temp_adc_value = adc_filter_conver(temp_adc_buff, MAX_CONV_NUM/2);\n\tmAdc_Info.ev_adc_value = adc_filter_conver(ev_adc_buff, MAX_CONV_NUM/2);\n}\n \n/*==================================================================================\n* 函 数 名： adc_scan_loop_task\n* 参    数： None\n* 功能描述:  ADC采集更新\n* 返 回 值： None\n* 备    注： 间隔200ms扫描一次\n* 作    者： xiaozh\n* 创建时间： 2019-09-24 105740\n==================================================================================*/\nvoid adc_scan_loop_task(void* argv)\n{\n\t//如果完成一次扫描，则进行数据解析\n\tif(mAdc_Info.is_complete)\n\t{\n\t\tmAdc_Info.is_complete = 0;\n\t\t\n\t\t//进行数据转换\n\t\tadc_conver_refresh();\n\t}\n\telse\n\t{\n\t\t//开启一次ADC转换\n\t\tstart_once_conv();\n\t}\n}\n\n/*==================================================================================\n* 函 数 名： get_adc_temp\n* 参    数： None\n* 功能描述:  获取温度的ADC值\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-09-24 105740\n==================================================================================*/\nuint16_t get_adc_temp(void)\n{\n\treturn mAdc_Info.temp_adc_value;\n}\n\n/*==================================================================================\n* 函 数 名： get_adc_ev\n* 参    数： None\n* 功能描述:  获取电流的ADC值\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-09-24 105740\n==================================================================================*/\nuint16_t get_adc_ev(void)\n{\n\treturn mAdc_Info.ev_adc_value;\n}\n\n",
							"origin_encoding": "GB2312",
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 24,
					"type": "text"
				},
				{
					"buffer": 18,
					"file": "hardware/src/gt32l_drv.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9447,
						"regions":
						{
						},
						"selection":
						[
							[
								6060,
								6070
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#include \"gt32l_drv.h\"\n\n\n#define SPI_CS_HIGH()\t\t\tdo{HAL_GPIO_WritePin(GPIOB, CS_FLASH_Pin, GPIO_PIN_SET);}while(0)\n#define SPI_CS_LOW()\t\t\tdo{ HAL_GPIO_WritePin(GPIOB, CS_FLASH_Pin, GPIO_PIN_RESET);}while(0)\n\n\n/*==================================================================================\n* 函 数 名： spi1_sed_rev\n* 参    数： None\n* 功能描述:  SPI1接口发送数据\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-05 143321\n==================================================================================*/\nstatic uint8_t gt_sed_rev_byte( uint8_t value)\n{\n//\tSPI_TypeDef\t* pthis = SPI2;\n\tuint8_t ret = 0; \n\twhile((SPI2->SR & SPI_FLAG_TXE) == RESET);\t//等待发送缓冲区空\n\n\tSPI2->DR = value; \t//发送一个字节  \n\n\twhile((SPI2->SR & SPI_FLAG_RXNE) == RESET);\t //等待是否接收到一个字节  \n\t\n\tret = SPI2->DR; \t\t\t\t\t\t\t\t\t\t\t\t\t//获得该字节\n\t\n\treturn ret; //返回收到的字节\n}\n\n//---------私有函数\nunsigned char r_dat_bat(unsigned long address,unsigned long byte_long,unsigned char *p_arr)\n{\n\tunsigned long  i = 0;\n\tSPI_CS_LOW();\n\t\n\tgt_sed_rev_byte(READ_DATA_CMD);\t\n\t//发送地址\n//\tgt_sed_rev_byte(address>>24);\t\t\t\t//发送地址高8位\n\tgt_sed_rev_byte(address>>16);\t\t\t\t//发送地址\n\tgt_sed_rev_byte(address>>8);\t\t\t\t//发送地址\n\tgt_sed_rev_byte(address);\t\t\t\t\t\t//发送地址\n\t\n\t//发送数据\n\tfor(i=0; i<byte_long; i++)\n\t{\n\t\tp_arr[i] = gt_sed_rev_byte(0xFF);\n\t}\n\t\n\tSPI_CS_HIGH();\n\treturn p_arr[0]; \n}\n\n/*==================================================================================\n* 函 数 名： gt32l_execute_cmd\n* 参    数： None\n* 功能描述:  执行单条命令\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-12 121940\n==================================================================================*/\nuint8_t gt32l_execute_cmd(uint8_t cmd)\n{\n\tSPI_CS_LOW();\n\tgt_sed_rev_byte(cmd);\t\t\t//发送页写入指令\n\tSPI_CS_HIGH(); \n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： write_enable\n* 参    数： None\n* 功能描述:  写使能\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-12 121940\n==================================================================================*/\nuint8_t write_enable(void)\n{\n\tSPI_CS_LOW();\n\tgt_sed_rev_byte(0x06);\t\t\t//发送页写入指令\n\tSPI_CS_HIGH(); \n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： write_disable\n* 参    数： None\n* 功能描述:  写失能\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-12 121940\n==================================================================================*/\nuint8_t write_disable(void)\n{ \n\tSPI_CS_LOW();\n\tgt_sed_rev_byte(0x06);\t\t\t//发送页写入指令\n\tSPI_CS_HIGH(); \n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： gt32_read_status\n* 参    数： None\n* 功能描述:  读取芯片状态\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-12 122209\n==================================================================================*/\nuint8_t gt32_read_status(void)\n{\n\tuint8_t chip_status = 0;\n\t\n\tSPI_CS_LOW();\n\t\n\tgt_sed_rev_byte(READ_STATUS_CMD);\t\t\t//发送页写入指令\n\t\n\t//发送地址 \n\tchip_status = gt_sed_rev_byte(0xFF);\t\t\t\t//发送地址 \n\t\n\tSPI_CS_HIGH();\n\t\n\treturn chip_status;\n}\n  \n/*==================================================================================\n* 函 数 名： check_chip_status\n* 参    数： None\n* 功能描述:  检查芯片的状态\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-12 145307\n==================================================================================*/\nvoid check_chip_status(void)\n{\n\tuint8_t chip_status = 0;\n\tdo{\n\t\tchip_status = gt32_read_status();\n\t}while(chip_status&0x01);\n}\n\n/*==================================================================================\n* 函 数 名： page_program\n* 参    数： None\n* 功能描述:  写操作\n* 返 回 值： None\n* 备    注： 一次最大只能写入256个字节，不能执行跨页写操作\n* 作    者： xiaozh\n* 创建时间： 2019-11-12 122209\n==================================================================================*/\nuint8_t page_program(uint32_t address, uint8_t *buff, uint8_t length)\n{\n\tuint16_t i = 0;\n\n\t//使能写操作\n\twrite_enable();\n\t\n\tSPI_CS_LOW();\n\tgt_sed_rev_byte(0x02);\t\t\t//发送页写入指令\n\t\n\t//发送地址 \n\tgt_sed_rev_byte((uint8_t)((address>>16)&0x000000FF));\t\t\t\t//发送地址\n\tgt_sed_rev_byte((uint8_t)((address>>8)&0x000000FF));\t\t\t\t//发送地址\n\tgt_sed_rev_byte((uint8_t)((address>>0)&0x000000FF));\t\t\t\t\t\t//发送地址\n\t\n\t//发送数据\n\tfor(i=0; i<length; i++)\n\t{\n\t\tgt_sed_rev_byte(buff[i]);\n\t}\n\t\n\tSPI_CS_HIGH();\n\t\n\t//检查是否执行完成\n\tcheck_chip_status();\n\t\n\treturn 0x00; \n}\n\n/*==================================================================================\n* 函 数 名： sector_erase\n* 参    数： None\n* 功能描述:  芯片擦除\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-12 122209\n==================================================================================*/\nuint8_t gt32_sector_erase(uint32_t address)\n{\n\t//使能写操作\n\twrite_enable();\n\t\n\tSPI_CS_LOW(); \n\tgt_sed_rev_byte(0x20);\t\t\t//发送页写入指令\n\n\t//发送地址 \n\tgt_sed_rev_byte((uint8_t)((address>>16)&0x000000FF));\t\t\t\t//发送地址\n\tgt_sed_rev_byte((uint8_t)((address>>8)&0x000000FF));\t\t\t\t//发送地址\n\tgt_sed_rev_byte((uint8_t)((address>>0)&0x000000FF));\t\t\t\t\t\t//发送地址\n\t\n\tSPI_CS_HIGH();\n\t\n\t//检查是否执行完成\n\tcheck_chip_status();\n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： gt32_chip_read\n* 参    数： None\n* 功能描述:  芯片读取操作\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-12 122209\n==================================================================================*/\nuint8_t gt32_chip_read(uint32_t address, uint8_t* buff, uint32_t length)\n{\n\tr_dat_bat(address,  length, buff);\n\treturn 0;\n}\n\n/*==================================================================================\n* 函 数 名： gt32_chip_write\n* 参    数： None\n* 功能描述:  芯片写操作\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-11-12 122209\n==================================================================================*/\nuint8_t gt32_chip_write(uint32_t address, uint8_t* buff, uint32_t length)\n{\n\t\n//\twrite_enable();\n\tpage_program(address, buff, length);\n//\twrite_disable();\n\t\n\treturn 0;\n}\n \n\n\n#define  HZ_MODE00 0//竖置横排(Y)\n#define  HZ_MODE01 1//竖置竖排(Z)\n#define  HZ_MODE10 2//横置横排(W)\n#define  HZ_MODE11 3//横置竖排(X)\n\n#define  HZ_MODE4  4//Y-->W \n//条件putdata的数据写入X，Y的LCD显示缓冲RAM中\n\nvoid lcdram_map( uint8_t *getdate,uint8_t *putdata, uint8_t width, uint8_t high, uint8_t style )\n{\n  uint16_t i,j,hbyte,wbyte;\n  unsigned char i_8,j_8;\n  wbyte = (width+7)/8;\n  hbyte = (high+7)/8;\n   //--------------------------------------------------------------------------\n   // Y--> W; Y-->X; Y-->Z;\n   //--------------------------------------------------------------------------\n  if( style == HZ_MODE4 )\t//竖置横排 转 横置横排 ( Y-->W )\n  {\n\tfor( i = 0; i < high; i++ )\n\t\tfor( j = 0; j < width; j++ )\n\t\t{\n\t\t\ti_8 = i/8;\n\t\t\tif((*(putdata+i_8*width+j)&(0x01<<(i%8))) > 0)\n\t\t\t\tgetdate[wbyte*i+j/8] |= (0x80>>(j%8));\n\t\t\telse\n\t\t\t\tgetdate[wbyte*i+j/8] &= (~(0x80>>(j%8)));\n\t\t}\n  }\t\n   //--------------------------------------------------------------------------\n   // W--> Y;  W-->Z;W-->X;\n   //--------------------------------------------------------------------------\n  \n  if( style == HZ_MODE00 )\t//竖置横排 (W--> Y)\n  {\n\t  for( i = 0; i < high; i++ )\n\t\t  for( j = 0; j < width; j++ )\n\t\t  {\n\t\t\ti_8 = i/8;\n\t\t\tif((*(putdata+wbyte*i+j/8)&(0x80>>(j%8))) > 0)\n\t\t\t\tgetdate[i_8*width+j] |= (0x01<<(i%8));\n\t\t\telse\n\t\t\t\tgetdate[i_8*width+j] &= (~(0x01<<(i%8)));\n\t\t  }\n  }\n  else if(style == HZ_MODE01)\t//竖置竖排 (W-->Z)\n  {\n    for( i = 0; i < high; i++ )\n      for( j = 0; j < width; j++ )\n      {\n        if((*(putdata+wbyte*i+j/8)&(0x80>>(j%8))) > 0)\n\t\t\t\t\tgetdate[j*hbyte+i/8] |= (0x01<<(i%8));\n        else\n\t\t\t\t\tgetdate[j*hbyte+i/8]  &= (~(0x01<<(i%8)));\n      }\n  }\n  else if(style == HZ_MODE11)//横置竖排 (W-->X)\n  {\n    for( i = 0; i < high; i++ )\n      for( j = 0; j < width; j++ )\n      {\n        j_8 = j/8;\n        if((*(putdata+wbyte*i+j/8)&(0x80>>(j%8))) > 0)\n\t\t\t\t\tgetdate[j_8*high+i] |= (0x80>>(j%8));\n        else\n\t\t\t\t\tgetdate[j_8*high+i] &= (~(0x80>>(j%8)));\n      }\n  }\n  else if(style == HZ_MODE10)//横置横排 做镜像(W-->W')\n  {\n    for( i = 0; i < high; i++)\n      for( j = 0; j < width; j++)\n      {\n        if((*(putdata+wbyte*i+j/8)&(0x80>>(j%8)))>0 )\n\t\t\t\t\t*(getdate+wbyte*i+(width-j)/8) |=(0x80>>((width-j)%8));\n        else\n\t\t\t\t\t*(getdate+wbyte*i+(width-j)/8) &=~(0x80>>((width-j)%8));\n      }\n  }\n}\n\n//竖直竖排转横置横排 Z转W\nvoid Z2W(unsigned char* getData, unsigned char* putData, unsigned char width, unsigned char height) {\n\t\n\tunsigned char line, lie;\n\tunsigned int i=0, count=0, mark = 0;\t//i控制putData的下标, count控制getData的下标\n\t\n\tfor(line=0; line<height; line++) {\t//控制行\n\t\tfor(lie=0; lie<width; lie++) {\t//控制列\n\t\t\tgetData[count] = (unsigned char)(getData[count]<<0x01);\t//准备接收下一下\n\t\t\tif(putData[i]&(0x01<<(line%8))) \n\t\t\t\tgetData[count] += 1;\t//先取低位, 存新数组内\n\t\t\telse\n\t\t\t\tgetData[count] += 0;\n\t\t\ti += height>>3;\t//下一列\n\t\t\tif(lie%8 == 7) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(line%8 == 7) {\n\t\t\ti = ++mark;\n\t\t}else\n\t\t\ti = mark;\n\t}\n}\n\n//竖直竖排转竖置横排(Z->Y)\nvoid Z2Y(unsigned char* getData, unsigned char* putData, unsigned char width, unsigned char height) {\n\tunsigned char line=height>>3;\n\tunsigned int i=0, count=0, mark_count=0, sum = width*height>>3;\n\n\tfor(i=0;i<sum;i++) {\n\t\tgetData[count] = putData[i];\n\t\tcount += width;\n\t\tif( ((i+1)%line) == 0)\n\t\t\tcount = ++mark_count;\n\t}\n}\n\n//竖置横排转竖直竖排  Y转Z\nvoid Y2Z(unsigned char* getData, unsigned char* putData, unsigned char width, unsigned char height) {\n\tunsigned char line=height>>3;\n\tunsigned int i=0, count=0, mark_count=0, sum=width*height>>3;\n\t\n\tfor(i=0; i<sum; i++) {\n\t\tgetData[count] = putData[i];\n\t\tcount += line;\n\t\tif( ((i+1)%width) == 0 ) {\n\t\t\tcount = ++mark_count;\n\t\t}\n\t}\n}\n\n",
							"origin_encoding": "GB2312",
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 16,
					"type": "text"
				},
				{
					"buffer": 19,
					"file": "hardware/src/oled_drv.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 26106,
						"regions":
						{
						},
						"selection":
						[
							[
								24442,
								24442
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#include \"oled_drv.h\"\n#include \"includes.h\"\n\nstatic _Screen_Info mScreen_Info[MAX_SCREEN_NUM];\n\nstatic _pSpi_Class pScreen_R =  &mSpi_Class[oled_1];\nstatic _pSpi_Class pScreen_L =  &mSpi_Class[oled_2];\n\n/*==================================================================================\n* 函 数 名： oled_write_byte\n* 参    数： screen: 0左屏， 1右屏\n*\t\t\t\t\t\tdat:要写入的数据/命令 \n*            cmd:数据/命令标志 0,表示命令;1,表示数据;\n* 功能描述:  向SSD1315写入一个字节\t\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2015.10\n==================================================================================*/\nvoid oled_write_byte(uint8_t screen,uint8_t value,uint8_t cmd_type)\n{\n\t_pSpi_Class pthis = NULL; \n\t\n  if(cmd_type)\n\t{ \n    OLED_DC_HIGH();\n\t}\n  else \n\t{\n\t\tOLED_DC_LOW();\n\t}\n  \n\tif(screen == SCREEN_LEFT)\n\t{ \n\t\tpthis = pScreen_L;\n\t\t\n\t}\n\telse if(screen == SCREEN_RIGHT)\n\t{ \n\t\tpthis = pScreen_R; \n\t}\n\telse\n\t{\n\t\treturn ;\n\t}\n\t\n\tpthis->cs_set(pthis->pContext, 0);\t//cs 0\n\tpthis->sed_rev_byte(pthis->pContext, value);\n\tpthis->cs_set(pthis->pContext, 1); //cs 1\n\t \n\tOLED_DC_HIGH();   \t  \n}\n \n /*==================================================================================\n* 函 数 名： screen_refresh\n* 参    数： 0\n* 功能描述:  屏幕刷新\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-19 171313\n==================================================================================*/\nvoid screen_refresh(uint8_t screen)\n{\n  uint16_t i,n;\t\t \n \t_pScreen_Info pthis = NULL;\n \n\tpthis = &mScreen_Info[screen]; \n\t  \n\t//刷新屏幕显示\n\tfor(i=0;i<DISP_HEIGHT;i++)  \n\t{  \n\t\toled_write_byte(screen, 0xb0+i, OLED_CMD);    //设置页地址（0~7）\n\t\toled_write_byte(screen, 0x00, OLED_CMD);      //设置显示位置―列低地址\n\t\toled_write_byte(screen, 0x10, OLED_CMD);      //设置显示位置―列高地址   \n\t\tfor(n=0;n<DISP_WIDTH;n++)\n\t\t{\n\t\t\toled_write_byte(screen,pthis->frame_buffer[n][i],OLED_DATA);\n\t\t} \n\t}\n}\n\n/*==================================================================================\n* 函 数 名： screen_clear\n* 参    数： None\n* 功能描述:  清屏\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-23 115439\n==================================================================================*/ \nvoid screen_clear(uint8_t screen, uint8_t color)\n{\n  uint16_t i,n;\n\t\n \t_pScreen_Info pthis = NULL;\n \n\tpthis = &mScreen_Info[screen]; \n\n\t//刷新屏幕显示\n\tfor(i=0;i<DISP_HEIGHT;i++)  \n\t{\n\t\tfor(n=0;n<DISP_WIDTH;n++)\n\t\t{\n\t\t\tpthis->frame_buffer[n][i] = ((color == BLACK)?(0x00):(0xFF));\n\t\t} \n\t}\n\t\n\tscreen_refresh(screen);\t\t//刷新屏幕\n}\n\n/*==================================================================================\n* 函 数 名： screen_refresh_all\n* 参    数： 0\n* 功能描述:  刷新所有屏幕显示\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-20 115958\n==================================================================================*/\nvoid screen_refresh_all(void)\n{\n\tscreen_refresh(SCREEN_LEFT);\n\tscreen_refresh(SCREEN_RIGHT);\n}\n\n /*==================================================================================\n* 函 数 名： screen_display_on\n* 参    数： 0\n* 功能描述:  开显示\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-20 121045\n==================================================================================*/\nvoid screen_display_on(uint8_t screen)\n{\n\toled_write_byte(screen,0X8D,OLED_CMD);  //SET DCDC命令\n\toled_write_byte(screen,0X14,OLED_CMD);  //DCDC ON\n\toled_write_byte(screen,0XAF,OLED_CMD);  //DISPLAY ON \n}\n\n /*==================================================================================\n* 函 数 名： screen_display_off\n* 参    数： 0\n* 功能描述:  关显示\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-20 121045\n==================================================================================*/\nvoid screen_display_off(uint8_t screen)\n{\n\t oled_write_byte(screen,0X8D,OLED_CMD);  //SET DCDC命令\n\t oled_write_byte(screen,0X10,OLED_CMD);  //DCDC OFF\n\t oled_write_byte(screen,0XAE,OLED_CMD);  //DISPLAY OFF\n}\n\n /*==================================================================================\n* 函 数 名： screen_set_pos\n* 参    数： 0\n* 功能描述:  设置屏幕显示位置\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-20 121045\n==================================================================================*/\nvoid screen_set_pos(uint8_t screen, uint8_t x, uint8_t y)\n{\n\t oled_write_byte(screen,0xb0+y,OLED_CMD);\n\t oled_write_byte(screen,((x&0xf0)>>4)|0x10,OLED_CMD);\n\t oled_write_byte(screen,(x&0x0f)|0x01,OLED_CMD); \n}\n\n /*==================================================================================\n* 函 数 名： screen_draw_point\n* 参    数： None\n* 功能描述:  打点函数\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-20 121045\n==================================================================================*/\nvoid screen_draw_point(uint8_t screen, uint8_t x, uint8_t y, uint8_t color)\n{\n\tuint8_t pos, bx, temp = 0;\n\t\n  if((x > (X_MAX_PIXEL-1)) || (y > (Y_MAX_PIXEL-1)))\n\t{\n\t\treturn ;\n\t}\n\t\n\tbx = y%8;\n\tpos\t = y/8;\n\ttemp = 1<<(bx);\n\t \n\tif(color)\n\t{\n\t\tmScreen_Info[screen].frame_buffer[x][pos] |= temp;\n\t}\n\telse\n\t{\n\t\tmScreen_Info[screen].frame_buffer[x][pos] &= ~temp;\n\t}\n\t \n//\tscreen_refresh_all(); //刷新显示\n}\n\n/*==================================================================================\n* 函 数 名： screen_show_char\n* 参    数： font_size:字体大小：14、 24、 32\n* 功能描述:  显示一个字符\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-20 121045\n==================================================================================*/\nvoid screen_show_char(uint8_t screen, uint8_t x, uint8_t y, uint8_t *c_buff, uint8_t c_size, uint8_t color)\n{\n\tc_size = 16;\n\tuint8_t temp = 0;\n\tuint8_t y0 = y;\n\tfor(int i=0; i<c_size; i++)\n\t{\n\t\ttemp = c_buff[i];\n\t\tfor(int j=0; j<8; j++)\n\t\t{\n\t\t\tif(temp & 0x80)\n\t\t\t{\n\t\t\t\tscreen_draw_point(screen, x, y, color);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tscreen_draw_point(screen, x, y, !color);\n\t\t\t}\n\t\t\t\n\t\t\ttemp <<= 1;\n\t\t\ty++;\n\t\t\tif((y-y0) == c_size)\n\t\t\t{\n\t\t\t\ty=y0;\n\t\t\t\tx++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*==================================================================================\n* 函 数 名： screen_show_char\n* 参    数： font_size:字体大小：14、 24、 32\n* 功能描述:  显示一个字符\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-20 121045\n==================================================================================*/\nvoid screen_show_bmp(uint8_t screen, uint8_t x_s, uint8_t y_s, uint8_t x_e, uint8_t y_e, uint8_t *c_buff, uint8_t color)\n{\n\tuint8_t x, y;\n\tuint16_t j = 0;\n \t_pScreen_Info pthis = NULL;\n\tpthis = &mScreen_Info[screen]; \n\t  \n\tfor(y=y_s; y<y_e; y++)\n\t{\n\t\tfor(x=x_s; x<x_e; x++)\n\t\t{\n\t\t\tpthis->frame_buffer[x][y] = c_buff[j++];\n\t\t}\n\t}\n\t\n\tscreen_refresh(screen);\t\t//刷新屏幕\n}\n \n\n/*横置横排打点函数 -----------------------------------------------------------------*/\nvoid WriteData(uint8_t screen, uint16_t Xpos, uint16_t Ypos, uint8_t data, uint16_t charColor, uint16_t bkColor,uint8_t sizeType)\n{\n\t\tuint16_t j,i;\n\t\tunsigned char count=0;\n\t\tfor( j=0; j<8; j++ )\n\t\t{\n\t\t\t\tif( ((data >> (7-j))&0x01)== 0x01 ){\n\t\t\t\t\t\tfor(count=0;count<sizeType;count++){\n\t\t\t\t\t\t\tfor(i=0;i<sizeType;i++){\n\t\t\t\t\t\t\t\tscreen_draw_point(screen, Xpos + sizeType*j+count, Ypos+i, charColor );\t//修改此函数\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\tfor(count=0;count<sizeType;count++){\n\t\t\t\t\t\t\tfor(i=0;i<sizeType;i++){\n\t\t\t\t\t\t\t\tscreen_draw_point(screen, Xpos + sizeType*j+count, Ypos+i, bkColor );\t//修改此函数\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}    \n\t\t\t\t}\n\t\t}\n}\n \n\n/********o横置横排显示函数************/\nvoid DisZK_DZ_W(uint8_t screen, uint16_t Xpos, uint16_t Ypos, uint16_t W,uint16_t H, uint16_t charColor, uint16_t bkColor,uint8_t*DZ_Data,uint8_t sizeType)\n{\n\tuint16_t Vertical,Horizontal;\n\tuint16_t n_Vertical = Vertical;\n\tuint32_t bit=0;\n\tVertical=Ypos;\n  Horizontal=Xpos; \n\tfor(bit=0;bit<((W+7)/8*H);bit++) //data sizeof (byte)\n\t{\n\t\t\tif((bit%((W+7)/8)==0)&&(bit>0))//W/8 sizeof\n\t\t\t{\n\t\t\t\tVertical+=sizeType;\n\t\t\t\tHorizontal+=sizeType*8; \n\t\t\t\tn_Vertical=Vertical;\t\t\t\n\t\t\t}\n\t\t\telse if(bit>0)\n\t\t\t{\n\t\t\t\tHorizontal=Xpos;\n\t\t\t\tn_Vertical=Vertical+sizeType;\n\t\t\t}\n\t\t\t\t\n\t\t\tWriteData(screen, Horizontal,n_Vertical,DZ_Data[bit],charColor,bkColor,sizeType);\n\t}\n}\n\n/*==================================================================================\n* 函 数 名： screen_show_string\n* 参    数： font_size:字体大小：14、 24、 32\n* 功能描述:  显示一个字符串\n* 返 回 值： None\n* 备    注： \n* 作    者：  \n* 创建时间： 2019-09-23 120610\n==================================================================================*/\nvoid screen_show_string(_pFont_Info pmsg)\n{\n\tgt_get_func p_func;\n\t\n\tuint8_t p_bits[512] = {0};\n\tuint8_t x = 0, y=0;\n\tuint8_t *p_str = pmsg->p_text;\n\tuint8_t ascii_size = 0, ascii_type = 0;\n\tuint8_t hz_size = 0;\n\t\n\tif(pmsg->p_text == NULL)\t\t//判读数据合法性\n\t{\n\t\treturn ;\n\t}\n\t\n\t//字体选择\n\tif(pmsg->font_size == FONT_16)\t\t//16号\n\t{ \n\t\thz_size = 16;\n\t\tascii_size = 16;\n\t\tascii_type = ASCII_16_A;\n\t\t\n\t\tp_func = gt_16_GetData;\t//汉字获取接口\n\t}\n\telse if(pmsg->font_size == FONT_24)\t\t//24号\n\t{\n\t\tascii_size = 24;\n\t\thz_size = 24;\n\t\tascii_type = ASCII_24_A;\n\t\t\n\t\tp_func = gt_24_GetData;\t//汉字获取接口\n\t}\n\telse if(pmsg->font_size == FONT_32)\t\t//32号\n\t{\n\t\tascii_size = 32;\n\t\thz_size = 32;\n\t\tascii_type = ASCII_32_A;\n\t\t\n\t\tp_func = gt_32_GetData;\t//汉字获取接口\n\t}\n\telse\n\t{\n\t\tascii_size = 16;\n\t\thz_size = 16;\n\t\tascii_type = ASCII_16_A;\n\t\tp_func = gt_16_GetData;\t//汉字获取接口\n\t}\n\t\n\tx = pmsg->x;\n\ty = pmsg->y;\n\t\n\t//显示\n\twhile(*p_str != '\\0')\t//判断结尾\n\t{\n\t\tif(*p_str < 0x80)\t//ASCII码\n\t\t{\n\t\t\tASCII_GetData(*p_str, ascii_type, p_bits);\t//示例, 按实际函数名进行修改, 每次读取第一个字节为0xFF\n\t\t\tDisZK_DZ_W(pmsg->screen, x, y,ascii_size,ascii_size,pmsg->font_color ,!pmsg->font_color ,p_bits,pmsg->font_scale);  //显示8X16点ASCII函数\n\t\t\tx=x+ascii_size*pmsg->font_scale;\n\t\t}\n\t\telse\n\t\t{//汉字编码*text是汉字编码的高位，*(text+1)是汉字编码的低位\n\t\t\tp_func(*p_str, *(p_str+1),0, 0, p_bits);\t//示例, 按实际函数名进行修改\n\t\t\tDisZK_DZ_W(pmsg->screen, x,y,hz_size,hz_size,pmsg->font_color, !pmsg->font_color ,p_bits,pmsg->font_scale);  //显示汉字\n\t\t\tx=x+hz_size*pmsg->font_scale;\n\t\t\tp_str++; \n\t\t}\n\t\t\n\t\tp_str++;\n\t}\n}\n   \n/*==================================================================================\n* 函 数 名： oled_init\n* 参    数： None\n* 功能描述:  OLED屏初始化\n* 返 回 值： None\n* 备    注： SSD1315\n* 作    者：  xiaozh\n* 创建时间： 2019-09-23 132006\n==================================================================================*/\nvoid oled_init(uint8_t screen)\n{\n\toled_write_byte(screen,0xAE,OLED_CMD);//--turn off oled panel\n\toled_write_byte(screen,0x00,OLED_CMD);//---set low column address\n\toled_write_byte(screen,0x10,OLED_CMD);//---set high column address\n\toled_write_byte(screen,0x40,OLED_CMD);//--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)\n\toled_write_byte(screen,0x81,OLED_CMD);//--set contrast control register\n\toled_write_byte(screen,0xCF,OLED_CMD); // Set SEG Output Current Brightness\n\toled_write_byte(screen,0xA1,OLED_CMD);//--Set SEG/Column Mapping     0xa0左右反置 0xa1正常\n\toled_write_byte(screen,0xC8,OLED_CMD);//Set COM/Row Scan Direction   0xc0上下反置 0xc8正常\n\toled_write_byte(screen,0xA6,OLED_CMD);//--set normal display\n\toled_write_byte(screen,0xA8,OLED_CMD);//--set multiplex ratio(1 to 64)\n\toled_write_byte(screen,0x3f,OLED_CMD);//--1/64 duty\n\toled_write_byte(screen,0xD3,OLED_CMD);//-set display offset\tShift Mapping RAM Counter (0x00~0x3F)\n\toled_write_byte(screen,0x00,OLED_CMD);//-not offset\n\toled_write_byte(screen,0xd5,OLED_CMD);//--set display clock divide ratio/oscillator frequency\n\toled_write_byte(screen,0x80,OLED_CMD);//--set divide ratio, Set Clock as 100 Frames/Sec\n\toled_write_byte(screen,0xD9,OLED_CMD);//--set pre-charge period\n\toled_write_byte(screen,0xF1,OLED_CMD);//Set Pre-Charge as 15 Clocks & Discharge as 1 Clock\n\toled_write_byte(screen,0xDA,OLED_CMD);//--set com pins hardware configuration\n\toled_write_byte(screen,0x12,OLED_CMD);\n\toled_write_byte(screen,0xDB,OLED_CMD);//--set vcomh\n\toled_write_byte(screen,0x40,OLED_CMD);//Set VCOM Deselect Level\n\toled_write_byte(screen,0x20,OLED_CMD);//-Set Page Addressing Mode (0x00/0x01/0x02)\n\toled_write_byte(screen,0x02,OLED_CMD);//\n\toled_write_byte(screen,0x8D,OLED_CMD);//--set Charge Pump enable/disable\n\toled_write_byte(screen,0x14,OLED_CMD);//--set(0x10) disable\n\toled_write_byte(screen,0xA4,OLED_CMD);// Disable Entire Display On (0xa4/0xa5)\n\toled_write_byte(screen,0xA6,OLED_CMD);// Disable Inverse Display On (0xa6/a7) \n\toled_write_byte(screen,0xAF,OLED_CMD);//--turn on oled panel\n\t\n\n\t//清屏\n\tscreen_clear(screen,BLACK); \t\n\tscreen_clear(screen,BLACK); \t\n}\n\n/*==================================================================================\n* 函 数 名： gt32l_init\n* 参    数： None\n* 功能描述:  字库芯片初始化\n* 返 回 值： None\n* 备    注： 默认上电读取一个，不然第一个自己会为0xFF\n* 作    者：  xiaozh\n* 创建时间： 2019-09-23 132006\n==================================================================================*/\nvoid gt32l_init(void)\n{\n\tuint8_t zk_buff[64] = {0};\n\tASCII_GetData('A',ASCII_16_A,zk_buff);\n}\n\n/*==================================================================================\n* 函 数 名： oled_init\n* 参    数： None\n* 功能描述:  OLED屏初始化\n* 返 回 值： None\n* 备    注： SSD1315\n* 作    者：  xiaozh\n* 创建时间： 2019-09-23 132006\n==================================================================================*/\nvoid oled_gt_init(void)\n{\n\t//GPIO初始化\n\tHAL_GPIO_WritePin(GPIOB, OLED_CS2_Pin|OLED_CS1_Pin|CS_FLASH_Pin, GPIO_PIN_SET);\t//失能片选\n\n\t//OLED使能\n//\tALL_RES_HIGH();\n\t\tHAL_GPIO_WritePin(GPIOB, OLED_RES1_Pin|OELD_RES2_Pin, GPIO_PIN_SET);\n\tHAL_Delay(100);\n\tHAL_GPIO_WritePin(GPIOB, OLED_RES1_Pin|OELD_RES2_Pin, GPIO_PIN_RESET);\n//\tALL_RES_LOW();\n\tHAL_Delay(200);\n//\tALL_RES_HIGH();\nHAL_GPIO_WritePin(GPIOB, OLED_RES1_Pin|OELD_RES2_Pin, GPIO_PIN_SET);\n\t\n\t//OLED初始化\n\toled_init(SCREEN_LEFT);\n\toled_init(SCREEN_RIGHT);\n\n\tHAL_GPIO_WritePin(GPIOB, OLED_DC_Pin|OLED_RES1_Pin|OELD_RES2_Pin|OLED_CS2_Pin \n\t\t\t\t\t\t\t\t\t\t\t\t|CS_FLASH_Pin|OLED_CS1_Pin, GPIO_PIN_SET);\n\t//字库芯片初始化\n//\tgt32l_init();\n}\n\n \nunsigned char BMP1[] =\n{\n\t0x00,0x03,0x05,0x09,0x11,0xFF,0x11,0x89,0x05,0xC3,0x00,0xE0,0x00,0xF0,0x00,0xF8,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x28,0xFF,0x11,0xAA,0x44,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x83,0x01,0x38,0x44,0x82,0x92,\n\t0x92,0x74,0x01,0x83,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x44,0xFF,0x01,0x7D,\n\t0x7D,0x7D,0x01,0x7D,0x7D,0x7D,0x7D,0x01,0x7D,0x7D,0x7D,0x7D,0x7D,0x01,0xFF,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,\n\t0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x3F,0x03,0x03,\n\t0xF3,0x13,0x11,0x11,0x11,0x11,0x11,0x11,0x01,0xF1,0x11,0x61,0x81,0x01,0x01,0x01,\n\t0x81,0x61,0x11,0xF1,0x01,0x01,0x01,0x01,0x41,0x41,0xF1,0x01,0x01,0x01,0x01,0x01,\n\t0xC1,0x21,0x11,0x11,0x11,0x11,0x21,0xC1,0x01,0x01,0x01,0x01,0x41,0x41,0xF1,0x01,\n\t0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x11,0x11,0x11,0x11,0x11,0xD3,0x33,\n\t0x03,0x03,0x3F,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xE0,0x00,0x00,\n\t0x7F,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x7F,0x00,0x00,0x01,0x06,0x18,0x06,\n\t0x01,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x40,0x40,0x7F,0x40,0x40,0x00,0x00,0x00,\n\t0x1F,0x20,0x40,0x40,0x40,0x40,0x20,0x1F,0x00,0x00,0x00,0x00,0x40,0x40,0x7F,0x40,\n\t0x40,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x40,0x30,0x0C,0x03,0x00,0x00,\n\t0x00,0x00,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x07,0x06,0x06,\n\t0x06,0x06,0x04,0x04,0x04,0x84,0x44,0x44,0x44,0x84,0x04,0x04,0x84,0x44,0x44,0x44,\n\t0x84,0x04,0x04,0x04,0x84,0xC4,0x04,0x04,0x04,0x04,0x84,0x44,0x44,0x44,0x84,0x04,\n\t0x04,0x04,0x04,0x04,0x84,0x44,0x44,0x44,0x84,0x04,0x04,0x04,0x04,0x04,0x84,0x44,\n\t0x44,0x44,0x84,0x04,0x04,0x84,0x44,0x44,0x44,0x84,0x04,0x04,0x04,0x04,0x06,0x06,\n\t0x06,0x06,0x07,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x10,0x18,0x14,0x12,0x11,0x00,0x00,0x0F,0x10,0x10,0x10,\n\t0x0F,0x00,0x00,0x00,0x10,0x1F,0x10,0x00,0x00,0x00,0x08,0x10,0x12,0x12,0x0D,0x00,\n\t0x00,0x18,0x00,0x00,0x0D,0x12,0x12,0x12,0x0D,0x00,0x00,0x18,0x00,0x00,0x10,0x18,\n\t0x14,0x12,0x11,0x00,0x00,0x10,0x18,0x14,0x12,0x11,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,\n\t0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x7F,0x03,0x0C,0x30,0x0C,0x03,0x7F,0x00,0x00,0x38,0x54,0x54,0x58,0x00,0x00,\n\t0x7C,0x04,0x04,0x78,0x00,0x00,0x3C,0x40,0x40,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xAA,0xAA,0xAA,\n\t0x28,0x08,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x03,0x0C,0x30,0x0C,0x03,0x7F,\n\t0x00,0x00,0x26,0x49,0x49,0x49,0x32,0x00,0x00,0x7F,0x02,0x04,0x08,0x10,0x7F,0x00,/********************************/\n};\n\n\nunsigned char BMP2[] =\n{\n\t0x00,0x03,0x05,0x09,0x11,0xFF,0x11,0x89,0x05,0xC3,0x00,0xE0,0x00,0xF0,0x00,0xF8,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x28,0xFF,0x11,0xAA,0x44,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x83,0x01,0x38,0x44,0x82,0x92,\n\t0x92,0x74,0x01,0x83,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x44,0xFF,0x01,0x7D,\n\t0x7D,0x7D,0x7D,0x01,0x7D,0x7D,0x7D,0x7D,0x01,0x7D,0x7D,0x7D,0x7D,0x01,0xFF,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,\n\t0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,\n\t0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0xF8,0x18,0x60,0x80,0x00,0x00,0x00,0x80,\n\t0x60,0x18,0xF8,0x00,0x00,0x00,0x20,0x20,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,\n\t0x10,0x08,0x08,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x20,0x20,0xF8,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x88,0x68,\n\t0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,\n\t0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x7F,0x00,0x00,0x01,0x06,0x18,0x06,0x01,\n\t0x00,0x00,0x7F,0x00,0x00,0x00,0x40,0x40,0x7F,0x40,0x40,0x00,0x00,0x00,0x00,0x1F,\n\t0x20,0x40,0x40,0x40,0x40,0x20,0x1F,0x00,0x00,0x00,0x40,0x40,0x7F,0x40,0x40,0x00,\n\t0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x18,0x06,0x01,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x40,0x20,0x20,0x20,0xC0,0x00,0x00,0xE0,0x20,0x20,0x20,\n\t0xE0,0x00,0x00,0x00,0x40,0xE0,0x00,0x00,0x00,0x00,0x60,0x20,0x20,0x20,0xE0,0x00,\n\t0x00,0x00,0x00,0x00,0xE0,0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00,0x00,0x40,0x20,\n\t0x20,0x20,0xC0,0x00,0x00,0x40,0x20,0x20,0x20,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x0C,0x0A,0x0A,0x09,0x0C,0x00,0x00,0x0F,0x08,0x08,0x08,\n\t0x0F,0x00,0x00,0x00,0x08,0x0F,0x08,0x00,0x00,0x00,0x0C,0x08,0x09,0x09,0x0E,0x00,\n\t0x00,0x0C,0x00,0x00,0x0F,0x09,0x09,0x09,0x0F,0x00,0x00,0x0C,0x00,0x00,0x0C,0x0A,\n\t0x0A,0x09,0x0C,0x00,0x00,0x0C,0x0A,0x0A,0x09,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,\n\t0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x7F,0x03,0x0C,0x30,0x0C,0x03,0x7F,0x00,0x00,0x38,0x54,0x54,0x58,0x00,0x00,\n\t0x7C,0x04,0x04,0x78,0x00,0x00,0x3C,0x40,0x40,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xAA,0xAA,0xAA,\n\t0x28,0x08,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x03,0x0C,0x30,0x0C,0x03,0x7F,\n\t0x00,0x00,0x26,0x49,0x49,0x49,0x32,0x00,0x00,0x7F,0x02,0x04,0x08,0x10,0x7F,0x00,/***************************************/\n\t\n};\n\n/*==================================================================================\n* 函 数 名： main_oled_test\n* 参    数： None\n* 功能描述:  OLED和字库测试函数\n* 返 回 值： None\n* 备    注： SSD1315\n* 作    者：  xiaozh\n* 创建时间： 2019-09-23 132006\n==================================================================================*/\nvoid main_oled_test()\n{\n\tunsigned char jtwb[128]=\"ABC寻缺另\";\t//每个中文字符实际由两个字节组成, 对应GBK等编码\n \n\toled_gt_init();\n\t\n\t_Font_Info mFont_Info = _FONT_INIT();\n\n\t//汉字显示测试\n\tmFont_Info.p_text = jtwb;\n\tscreen_show_string(&mFont_Info);\n\tmFont_Info.screen = SCREEN_RIGHT;\n\tscreen_show_string(&mFont_Info);\n\tscreen_refresh_all(); //刷新显示 \n\t\n\tHAL_Delay(1000);\n\t\n\t//图片显示测试\n\tscreen_show_bmp(SCREEN_RIGHT,0,0,128,8,BMP1,1);\n\tscreen_show_bmp(SCREEN_LEFT,0,0,128,8,BMP2,1);\n\t//\tscreen_show_bmp(0, )\n}\n\n\nextern _App_Param mApp_Param;\nvoid show_read_tag(uint8_t read_num, uint8_t real_num)\n{ \n\tuint8_t count_step = 0; \n\tunsigned char show_str[]=\"read:000\";\t//每个中文字符实际由两个字节组成, 对应GBK等编码\n\tunsigned char show_str_real[]=\"real:000\";\t//每个中文字符实际由两个字节组成, 对应GBK等编码\n  unsigned char show_can_addr[]=\"can:00\";\t// \n\t\n\t_Font_Info mFont_Info = _FONT_INIT();\n\t\n\tcount_step = sizeof(\"read:\")-1;\n\tshow_str[count_step++] = read_num/100+'0'; \n\tshow_str[count_step++] = read_num/10%10+'0';\n\tshow_str[count_step++] = read_num%10+'0';\n\t\n\tcount_step = sizeof(\"real:\")-1;\n\tshow_str_real[count_step++] = real_num/100+'0';\n\tshow_str_real[count_step++] = real_num/10%10+'0';\n\tshow_str_real[count_step++] = real_num%10+'0';\n\t \n\tcount_step = sizeof(\"can:\")-1; \n\tshow_can_addr[count_step++] = mApp_Param.can_addr/10%10+'0';\n\tshow_can_addr[count_step++] = mApp_Param.can_addr%10+'0';\n\t\n\t//汉字显示测试\n\tmFont_Info.p_text = show_str;\n\tscreen_show_string(&mFont_Info);\n\n\tmFont_Info.p_text = show_str_real;\n\tmFont_Info.screen = SCREEN_RIGHT;\n\tscreen_show_string(&mFont_Info);\n\t\n\tmFont_Info.y = 16;\n\tmFont_Info.p_text = show_can_addr;\n\tmFont_Info.screen = SCREEN_RIGHT;\n\tscreen_show_string(&mFont_Info);\n\t\n\tscreen_refresh_all(); //刷新显示 \n}\n",
							"origin_encoding": "GB2312",
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 20,
					"file": "hardware/src/st_crc.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 882,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#include \"st_crc.h\"\n#include \"main.h\"\n\nCRC_HandleTypeDef hcrc;\n\n/*==================================================================================\n* 函 数 名： st_crc_init\n* 参    数： None\n* 功能描述:  st crc初始化\n* 返 回 值： none\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-10 182605\n==================================================================================*/ \nvoid st_crc_init(void)\n{\n\thcrc.Instance = CRC;\n  HAL_CRC_Init(&hcrc);\n}\n\n/*==================================================================================\n* 函 数 名： st_crc32\n* 参    数： None\n* 功能描述:  st crc校验\n* 返 回 值： none\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-10-16 162442\n==================================================================================*/ \nuint32_t st_crc32(uint8_t *buff, uint16_t len)\n{ \n\t//复位\n\tCRC->CR = CRC_CR_RESET;\n\t\n\tfor(int i=0; i<len; i++)\n\t{\n\t\tCRC->DR = buff[i];\n\t} \n\t\n\treturn (CRC->DR);\n}\n\n",
							"origin_encoding": "GB2312",
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 15,
					"type": "text"
				},
				{
					"buffer": 21,
					"file": "hardware/inc/oled_drv.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1572,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#ifndef  __OLED_DRV_H\n#define  __OLED_DRV_H\n#include \"spi_class.h\"\n\n#define MAX_SCREEN_NUM\t\t\t2\t\t\t//最大屏幕数量\n\n#define X_MAX_PIXEL\t\t\t\t\t128\t\t//最大像素点个数\n#define Y_MAX_PIXEL\t\t\t\t\t64\t\t//最大像素点个数\n\n#define DISP_WIDTH        128\n#define DISP_HEIGHT        8\n\ntypedef  enum\n{\n\tFONT_16 = 16,\t\t//16*16  16号字\n\tFONT_24 = 24,\t\t//24*24\t 24号字\n\tFONT_32 = 32,\t\t//32*32\t 32号字\n}_Font_Size;\n\ntypedef enum\n{\n\tSCREEN_LEFT = 0,\t\t//左屏\n\tSCREEN_RIGHT,\t\t\t\t//右屏\n}_Screen_Type;\n\ntypedef enum\n{\n\tBLACK = 0,\t\t//黑\n\tWHITE,\t\t\t\t//白\n}_Font_Color;\n\ntypedef struct\n{\n\tuint8_t type;\n\tuint8_t mode;\n\tuint8_t frame_buffer[DISP_WIDTH][DISP_HEIGHT];\n}_Screen_Info,*_pScreen_Info;\n\ntypedef struct\n{\n\tuint8_t x;\n\tuint8_t y;\n\t_Screen_Type screen;\t\t\t\t//屏幕\n\t_Font_Color  font_color;\t\t//字体颜色\n\t_Font_Size \t font_size;\t\t\t//字体大小 （16 24 32）\n\tuint8_t      font_scale; \t\t//字体转换比例系数，默认为1，不进行缩放\n\tuint8_t      *p_text;\t\t\t\t//要显示的字符串编码\n}_Font_Info, *_pFont_Info;\n\n#define  _FONT_INIT()  {0, 0, SCREEN_LEFT, WHITE, FONT_16, 1, NULL}\n\ntypedef  unsigned long  (*gt_get_func)(uint8_t , uint8_t, uint8_t, uint8_t, uint8_t*);\t//获取字库芯片数据\n\n\n#define OLED_CMD  \t\t\t\t0\t//写命令\n#define OLED_DATA \t\t\t\t1\t//写数据\n \n#define OLED_DC_LOW()\t \t\t\tdo{HAL_GPIO_WritePin(GPIOB, OLED_DC_Pin, GPIO_PIN_RESET);}while(0)\n#define OLED_DC_HIGH()  \t\tdo{HAL_GPIO_WritePin(GPIOB, OLED_DC_Pin, GPIO_PIN_SET);}while(0)\n\n#define ALL_RES_HIGH()\t\t\tdo{GPIOB->BSRR = OLED_RES1_Pin; GPIOB->BSRR = OELD_RES2_Pin;}while(0)\n#define ALL_RES_LOW()\t\t\t\tdo{GPIOB->BSRR = (uint32_t)OLED_RES1_Pin << 16u; GPIOB->BSRR = (uint32_t)OELD_RES2_Pin << 16u;}while(0)\n\t\nvoid oled_gt_init(void);\n\n#endif\n",
							"origin_encoding": "GB2312",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 26,
					"type": "text"
				},
				{
					"buffer": 22,
					"file": "application/src/application.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2710,
						"regions":
						{
						},
						"selection":
						[
							[
								1874,
								1874
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#include \"application.h\"\n#include \"includes.h\"\n\n\n_App_Param mApp_Param= \n{\n\t.sys_init_complete = 0,\t//系统初始化标志，没有初始化完成，不允许执行中断\n\t.can_addr \t\t= 2,\t\t\t//空地址\n};\n\n/*==================================================================================\n* 函 数 名： systerm_init\n* 参    数： None\n* 功能描述:  系统初始化\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-24 111301\n==================================================================================*/\nvoid systerm_init(void)\n{\n//中断向量表初始化\n#if  EN_DEBUG\n\tSCB->VTOR = FLASH_BASE | 0X10000; /* Vector Table Relocation in Internal FLASH. */\n#else\n\n#endif\n\t\n\tHAL_Init();\n\n\t__disable_irq();   // 关闭总中断\n\n\t//读取配置参数\n\tread_config_param(&mApp_Param);\n\t\n\t//系统板级初始化\n\tbsp_init(mApp_Param.can_addr);\n\tst_crc_init(); \n\t\n\t//can协议初始化\n\tcan_instance_init();\n\t\n\t//外设初始化\n\tinter_init();\n\t\n\t//使能外部中断\n\t__enable_irq();    // 开启总中断\n\t\n\t//初始化OLED, 字库\n\toled_gt_init();\n\n\t//读卡器初始化\n//\trfid_st25_init();\n\t\n\t//开启任务\n\tEnableTask(TASK_RFID_READ);\n\n\t//系统初始化完成\n\tmApp_Param.sys_init_complete = 0x01;\n\tprintf(\"slave box init complete\\n\");\n\t\n\t//运行系统中断\n\tHAL_Delay(100+((mApp_Param.can_addr<10)?(mApp_Param.can_addr*10):(100)));\n\t\n\t//使能中断\n\tsysterm_init_complete();\n\n\tprintf(\"can addr = %d\\n\", mApp_Param.can_addr);\n}\n\n/*==================================================================================\n* 函 数 名： HAL_SysTick_Callback\n* 参    数： None\n* 功能描述:  系统滴答回调\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-06 115746\n==================================================================================*/\nvoid HAL_SysTick_Callback(void)\n{\n\t//标记任务\n\tTaskRemarks();\n}\n\n/*==================================================================================\n* 函 数 名： app_dispatch\n* 参    数： None\n* 功能描述:  系统任务调度\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-06 115746\n==================================================================================*/\nvoid app_dispatch(void)\n{\n\t//定时任务查询\n\tTaskProcess(0);\n\t\n\t//协议解析\n\tcan_rev_decode();\n}\n \n/*==================================================================================\n* 函 数 名： test_loop_task\n* 参    数： None\n* 功能描述:  测试任务\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2019-09-29 170658\n==================================================================================*/\nvoid test_loop_task(void* argv)\n{\n\tstatic uint32_t frame_step = 0;\n\tstatic uint8_t count_step = 0;\n\tuint8_t s_count = 0;\n//  test_send();\n\tuint8_t sed_buff[255] = {0};\n\tfor(int i=0;i<sizeof(sed_buff); i++)\n\t{\n\t\tsed_buff[i] = i;\n\t}\n\t\n\tframe_step++;\n\tsed_buff[s_count++] = frame_step>>24;\n\tsed_buff[s_count++] = frame_step>>16;\n\tsed_buff[s_count++] = frame_step>>8;\n\tsed_buff[s_count++] = frame_step>>0;\n\n\tcan_sed_link_pkg(0x03, 0xAE,  sed_buff,  count_step++);\n}\n\n\n",
							"origin_encoding": "GB2312",
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 18,
					"type": "text"
				},
				{
					"buffer": 23,
					"file": "event_manage/src/mini_dispatch.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4570,
						"regions":
						{
						},
						"selection":
						[
							[
								569,
								569
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#include \"mini_dispatch.h\"\n \n\nextern void can_sed_loop_task(void* argv); \nextern void can_rev_loop_task(void* argv); \nextern void adc_scan_loop_task(void* argv);\t\t//低优先级任务\nextern void  rfid_loop_read_task(void *argv); \t//读卡\nextern void test_loop_task(void* argv);\nextern void loop_sed_new_tag_info(void* argv);\n\n/*==================================================================================\n* 函 数 名： TaskComps\n* 参    数： None\n* 功能描述:  任务表\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2017-7-28 15:12:42\n==================================================================================*/\nTASK_COMPONENTS TaskComps[] = \n{\n\t{0, TASK_ENABLE, 10, 10, can_sed_loop_task},            \t//优先级 1\n\t{0, TASK_ENABLE, 30, 30, loop_sed_new_tag_info},            \t//优先级 2\n\t{0, TASK_DISABLE, 100, 100, rfid_loop_read_task},            \t//优先级 3\n\t{0, TASK_ENABLE, 1000, 1000, adc_scan_loop_task},            \t//优先级 4\n\t{0, TASK_DISABLE, 300, 300, test_loop_task},            \t//循环测试任务\n};\n\n/*==================================================================================\n* 函 数 名： EnableTask\n* 参    数： None\n* 功能描述:  使能任务\n* 返 回 值： None\n* 备    注： 0:没有使能  1：使能   0xff:未知通道\n* 作    者： xiaozh\n* 创建时间： 2017-7-28 15:12:42\n==================================================================================*/\nuint8_t IsTaskEnable(TASK_LIST Task)\n{\n\tif(Task > TASKS_MAX)\n\t\treturn 0xff;\n\t\n\tif(TaskComps[Task].RunState == TASK_ENABLE)\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n}\n\n/*==================================================================================\n* 函 数 名： TaskRefresh\n* 参    数： None\n* 功能描述:  刷新更新时间\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2017-7-28 15:12:42\n==================================================================================*/\nvoid TaskRefresh(TASK_LIST Task)\n{\n \tif(Task > TASKS_MAX)\n\t\treturn;\n\t\n\tTaskComps[Task].Timer = TaskComps[Task].ItvTime; \n}\n\n/*==================================================================================\n* 函 数 名： EnableTask\n* 参    数： None\n* 功能描述:  使能任务\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2017-7-28 15:12:42\n==================================================================================*/\nvoid EnableTask(TASK_LIST Task)\n{\n\tif(Task > TASKS_MAX)\n\t\treturn;\n\t\n//\tTaskComps[Task].Timer = TaskComps[Task].ItvTime;\n\tTaskComps[Task].RunState = TASK_ENABLE;\n}\n\n/*==================================================================================\n* 函 数 名： DisableTask\n* 参    数： None\n* 功能描述:  失能任务\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2017-7-28 15:12:42\n==================================================================================*/\nvoid DisableTask(TASK_LIST Task)\n{\n\tif(Task > TASKS_MAX)\n\t\treturn;\n\n\tTaskComps[Task].Timer = TaskComps[Task].ItvTime;\n\tTaskComps[Task].RunState = TASK_DISABLE;\n}\n\n/*==================================================================================\n* 函 数 名： TaskSetTimes\n* 参    数： None\n* 功能描述:  任务标志标记函数\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2017-7-28 15:12:42\n==================================================================================*/\nvoid TaskSetTimes(TASK_LIST Task , uint32_t Times)\n{\n\tif(Task > TASKS_MAX)\n\t\treturn;\n\t\n\tTaskComps[Task].Timer = Times;\n\tTaskComps[Task].RunState = TASK_ENABLE;\n}\n\n/*==================================================================================\n* 函 数 名： TaskRemarks\n* 参    数： None\n* 功能描述:  任务标志标记函数\n* 返 回 值： None\n* 备    注： \n* 作    者： xiaozh\n* 创建时间： 2017-7-28 15:12:42\n==================================================================================*/\nvoid TaskRemarks(void)\n{\n\tuint8_t i = 0;\n\tfor (i=0; i<TASKS_MAX; i++)          // 逐个任务时间处理\n\t{\n\t\tif(TaskComps[i].RunState == TASK_ENABLE)\t\t//如果使能了当前任务检测，则进行检测操作\n\t\t{\n\t\t\tif (TaskComps[i].Timer)          // 时间不为0\n\t\t\t{\n\t\t\t\tTaskComps[i].Timer--;         // 减去一个节拍\n\t\t\t\tif (TaskComps[i].Timer == 0)       // 时间减完了\n\t\t\t\t{\n\t\t\t\t\t TaskComps[i].Timer = TaskComps[i].ItvTime;       // 恢复计时器值，从新下一次\n\t\t\t\t\t TaskComps[i].Run = 1;           // 任务可以运行\n\t\t\t\t}\n\t\t\t}\n\t\t}\n  }\n}\n \n/*==================================================================================\n* 函 数 名： TaskRemarks\n* 参    数： None\n* 功能描述:  任务处理\n* 返 回 值： None\n* 备    注： 建议在中循环中调用，在定时中断中调用注意操作时间\n* 作    者： xiaozh\n* 创建时间： 2017-7-28 15:12:42\n==================================================================================*/\nvoid TaskProcess(void *who)\n{\n\tuint8_t i;\n\tfor (i=0; i<TASKS_MAX; i++)           // 逐个任务时间处理\n\t{\n\t\tif (TaskComps[i].Run)           // 时间不为0\n\t\t{\n\t\t\t TaskComps[i].TaskHook(who);         // 运行任务\n\t\t\t TaskComps[i].Run = 0;          // 标志清0\n\t\t\t //return ;  //每次循环只执行一个任务\n\t\t}\n\t}\n}\n\n",
							"origin_encoding": "GB2312",
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 23,
					"type": "text"
				},
				{
					"buffer": 24,
					"file": "event_manage/src/can_def_fifo.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 451,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#include \"can_def_fifo.h\"\n\n\n#define func_name   can_xjy\n\n//申请结构 \nDEF_SAFE_FIFO(can_xjy, _Can_Item, uint16_t, uint8_t)     \nDEF_SAFE_FIFO_END\n\n\nstatic _Can_Fifo_Func mCan_Fifo_Func = \n{\n\t.init_s\t\t\t\t\t\t=  \tFIFO_INIT_S_X(can_xjy),\n\t.init_m\t\t\t\t\t\t=  \tFIFO_INIT_M_X(can_xjy),\n\t.is_empty \t\t\t\t= \tFIFO_IS_EMPTY_X(can_xjy),\n\t.push\t \t\t\t\t\t\t= \tFIFO_PUSH_X(can_xjy),\n\t.pop \t\t\t\t\t\t\t= \tFIFO_POP_X(can_xjy),\n};\n\nconst _pCan_Fifo_Func pCan_Fifo_Func = &mCan_Fifo_Func;\n\n\n",
							"origin_encoding": "GB2312",
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 22,
					"type": "text"
				},
				{
					"buffer": 25,
					"file": "event_manage/src/debug_task.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2886,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#include \"debug_task.h\"\n#include \"main.h\"\n#include \"def_fifo.h\"\n\n\nDEF_SAFE_FIFO_U8(cmd_fifo, uint16_t, uint8_t)\n\n\n \nstatic _cmd_cache mCmd_Cache = \n{\n\t.is_value\t\t\t\t= 0,\t//是否接收有效命令\n\t.rev_count\t\t\t= 0,\n\t.r_point\t\t\t\t= 0,\n};\n\n//命令格式  [命令字符串]空格[参数1]空格[参数2]空格[...]\\r\\n \n\nstatic void DEF_NAME_FUNC(help)(void *argv);\nstatic void DEF_NAME_FUNC(shell)(void *argv);\n\n_cmd_list  mCmd_List_Table[] = \n{\n\tCMD_FUNC_DEF(help),\n\tCMD_FUNC_DEF(shell),\n};\n\n//help\nstatic void DEF_NAME_FUNC(help)(void *argv)\n{\n\tprintf(\"cmd frame: [命令字符串] [参数1] [参数2] ...\\n\");\n}\n//entyr shell\nstatic void DEF_NAME_FUNC(shell)(void *argv)\n{\n\tprintf(\"cmd frame: [命令字符串] [参数1] [参数2] ...\\n\");\n}\n\n/*==================================================================================\n* 函 数 名： push_cmd_cache\n* 参    数： None\n* 功能描述:  把接收到的命令字符放到缓存\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-11-12 172859\n==================================================================================*/\nvoid push_cmd_cache(uint8_t ch)\n{\n\tif(ch == '\\r')\n\t{\n\t\tmCmd_Cache.is_value  = 0x01;\t\t//接到的完整命令\n\t}\n\t\n\tmCmd_Cache.rev_buff[mCmd_Cache.r_point++] = ch;\n\tmCmd_Cache.rev_count++;\n\tmCmd_Cache.is_value++;\n}\n\n/*==================================================================================\n* 函 数 名： execute_cmd\n* 参    数： None\n* 功能描述:  命令处理\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-11-12 172859\n==================================================================================*/\nstatic void execute_cmd(const char *cmd_buf, uint16_t len)\n{\n\n}\n\n/*==================================================================================\n* 函 数 名： cmd_string_handle\n* 参    数： None\n* 功能描述:  字符串命令处理\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-11-12 172859\n==================================================================================*/ \np_func find_func(char *cmd_str)\n{ \n\tfor(int i=0; i<  MAX_NUM(mCmd_List_Table); i++)\n\t{ \n\t\tprintf(\"cmd = %s\\n\", mCmd_List_Table[i].cmd_name);\n\t}\n\t\n\treturn 0;\n}\n\n\n/*==================================================================================\n* 函 数 名： cmd_handle_func_task\n* 参    数： None\n* 功能描述:  字符串命令处理\n* 返 回 值： None\n* 备    注： None\n* 作    者： xiaozh\n* 创建时间： 2019-11-12 172859\n==================================================================================*/ \nvoid cmd_handle_func_task(void)\n{\n\tp_func pfunc = 0;\n\tchar cmd_str[16] = {0};\n\tuint8_t param_tab[8] = {0};\n\tuint8_t *p = 0;\n\tuint8_t point = 0;\n\t\n\tif(!mCmd_Cache.is_value)\n\t{\n\t\treturn ;\n\t}\n\t\n\t//进行命令解析\n\tdo{\n\t\t\n\t\t//获取命令\n\t\tdo{cmd_str[point++] =  mCmd_Cache.rev_buff[mCmd_Cache.r_point++]; mCmd_Cache.rev_count--;}while(cmd_str[point-1] != '\\r');\n\t\t\n\t\t//查找函数\n\t\tpfunc = find_func(cmd_str);\n\t\t\n\t\t//执行命令\n\t\tpfunc(param_tab);\n\t\t\n\t\t//修正参数\n\t\t(mCmd_Cache.is_value>0)?(mCmd_Cache.is_value--):(mCmd_Cache.is_value=0);\n\t}while(mCmd_Cache.is_value);\n\t\n\t//清空缓存\n\tmCmd_Cache.rev_count = 0;\n\tmCmd_Cache.r_point = 0;\n\t \n}\n\n",
							"origin_encoding": "GB2312",
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 21,
					"type": "text"
				},
				{
					"buffer": 26,
					"file": "event_manage/inc/mini_dispatch.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1031,
						"regions":
						{
						},
						"selection":
						[
							[
								722,
								722
							]
						],
						"settings":
						{
							"in_converting": true,
							"origin_content": "#ifndef  __MINI_DISPATCH_H\n#define  __MINI_DISPATCH_H\n#include <stdint.h>\n\n\ntypedef enum \n{\n\tTASK_ENABLE=1,\n\tTASK_DISABLE\n}TASK_STA;\n\n// 任务结构\ntypedef struct _TASK_COMPONENTS\n{\n\tuint8_t \t\tRun;                 \t\t//程序运行标记：0-不运行，1运行\n\tTASK_STA\t\tRunState;\t\t\t\t\t\t\t\t//运行状态，TASK_ENABLE：使能检测    TASK_DISABLE：不进行检测\n\t//\t\tuint16_t    Priority;\t\t\t\t\t\t\t\t//优先级\n\tuint32_t \t\tTimer;              \t\t//计时器\n\tuint32_t \t\tItvTime;              \t//任务运行间隔时间，下一次填充时间\n\tvoid (*TaskHook)(void*);    \t\t// 要运行的任务函数\n} TASK_COMPONENTS;       \t\t\t\t\t// 任务定义\n\n\n// 任务清单\ntypedef enum _TASK_LIST\n{ \n\tTASK_CAN_SED = 0,\t\t\t\t\t\t\t\t//CAN发送数据\n\tTASK_SED_TAG_INFO,\t\t\t\t\t\t\t//发送卡片信息\n\tTASK_RFID_READ,\t\t\t\t\t\t\t//rfid读卡\n\tTASK_ADC_CONV,\t\t\t\t\t\t\t//ADC转换\n\t\n\tTASK_TEST_LOOP,\t\t\t\t\t\t\t//循环测试任务\n\tTASKS_MAX                     // 总的可供分配的定时任务数目\n} TASK_LIST;\n\nvoid TaskSetTimes(TASK_LIST Task , uint32_t Times);\nvoid TaskRefresh(TASK_LIST Task);\nuint8_t IsTaskEnable(TASK_LIST Task);\nvoid EnableTask(TASK_LIST Task);\nvoid DisableTask(TASK_LIST Task);\nvoid TaskRemarks(void);\nvoid TaskProcess(void*);\n#endif\n",
							"origin_encoding": "GB2312",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 17,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 32.0
	},
	"input":
	{
		"height": 44.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"output.raw_line_edit_view":
	{
		"height": 702.0
	},
	"pinned_build_system": "",
	"project": "CAN_BOX.sublime-project",
	"replace":
	{
		"height": 60.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 392.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 592.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 217.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
